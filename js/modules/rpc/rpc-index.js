/**
 * ================================================================================
 * RPC NDEX - TOKENCAFE
 * ================================================================================
 * nterface para gerao de lnks RPC usando o sstema consolidado
 * ================================================================================
 */

// Importar m√≥dulos consolidados
import BlockchainCore from '../blockchain.js';
import { SharedUtilities } from '../../core/shared_utilities_es6.js';
import { DebugSystem } from './debug-system.js';

// Inicializar core consolidado
const blockchainCore = new BlockchainCore();
const utils = new SharedUtilities();
const debug = new DebugSystem();

// VariÔøΩveis globais
let allNetworks = [];
let selectedNetwork = null;

// IDs dos elementos (segundo o padro do lnk_ndex.js)
const networkSearchId = 'networkSearch';
const networkAutocompleteId = 'networkAutocomplete';
const rpcUrlId = 'rpcUrl';
const explorerUrlId = 'explorerUrl';

// Carregar redes dispon√≠veis
async function loadNetworks() {
    try {
        debug.log('üöÄ Iniciando carregamento de redes...');
        
        // Tentar usar ChainList API primeiro
        if (typeof chainListAPI !== 'undefined') {
            try {
                debug.log('üåê Tentando carregar redes do ChainList...');
                const chainListNetworks = await chainListAPI.fetchChains();
                
                if (chainListNetworks && chainListNetworks.length > 0) {
                    // Converter formato do ChainList para nosso formato
                    allNetworks = chainListNetworks.map(chain => ({
                        chainId: chain.chainId,
                        name: chain.name,
                        shortName: chain.shortName || chain.chain,
                        nativeCurrency: chain.nativeCurrency,
                        rpc: Array.isArray(chain.rpc) ? chain.rpc.map(rpc => 
                            typeof rpc === 'string' ? rpc : rpc.url
                        ).filter(url => url && url.startsWith('https://')) : [],
                        explorers: chain.explorers || [],
                        infoURL: chain.infoURL,
                        icon: chain.icon
                    }));
                    
                    debug.log(`‚úÖ ${allNetworks.length} redes carregadas do ChainList`);
                    return;
                }
            } catch (chainListError) {
                debug.error('‚ö†Ô∏è Erro ao carregar do ChainList, tentando fallback...', chainListError);
            }
        }
        
        // Fallback: tentar buscar redes usando o blockchain core consolidado
        allNetworks = await blockchainCore.fetchAllNetworks();
        
        if (allNetworks && allNetworks.length > 0) {
            debug.log(`‚úÖ ${allNetworks.length} redes carregadas com sucesso (fallback)`, allNetworks.slice(0, 3));
        } else {
            throw new Error('Nenhuma rede encontrada');
        }
        
    } catch (error) {
        debug.error('‚ùå Erro ao carregar redes da API', error);
        
        // Usar redes de fallback
        allNetworks = [
            {
                chainId: 1,
                name: 'Ethereum Mainnet',
                nativeCurrency: { name: 'Ethereum', symbol: 'ETH', decimals: 18 },
                rpc: ['https://eth.llamarpc.com'],
                explorers: [{ url: 'https://etherscan.io' }]
            },
            {
                chainId: 56,
                name: 'Binance Smart Chain',
                nativeCurrency: { name: 'BNB', symbol: 'BNB', decimals: 18 },
                rpc: ['https://bsc-dataseed.binance.org'],
                explorers: [{ url: 'https://bscscan.com' }]
            },
            {
                chainId: 137,
                name: 'Polygon',
                nativeCurrency: { name: 'MATIC', symbol: 'MATIC', decimals: 18 },
                rpc: ['https://polygon-rpc.com'],
                explorers: [{ url: 'https://polygonscan.com' }]
            },
            {
                chainId: 11155111,
                name: 'Sepolia Testnet',
                nativeCurrency: { name: 'Ethereum', symbol: 'ETH', decimals: 18 },
                rpc: ['https://sepolia.infura.io/v3/'],
                explorers: [{ url: 'https://sepolia.etherscan.io' }]
            }
        ];
        
        console.log(` Usando ${allNetworks.length} redes de fallback`);
    }
}

// Fun√ß√£o para mostrar autocomplete (adaptada do link_token_utils.js)
function showAutocomplete(networks, containerId) {
    debug.log('üîç Mostrando autocomplete', { networksCount: networks.length, containerId });
    
    const container = document.getElementById(containerId);
    if (!container) {
        debug.error(`‚ùå Container n√£o encontrado: ${containerId}`);
        return;
    }

    container.innerHTML = '';
    
    networks.slice(0, 10).forEach(network => {
        const item = document.createElement('div');
        item.className = 'autocomplete-item p-2 border-bottom cursor-pointer';
        
        // Aplicar estilos inline para garantir visibilidade
        item.style.cssText = `
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid #dee2e6;
            cursor: pointer;
            transition: all 0.2s ease;
            color: white;
        `;
        
        item.innerHTML = `
            <div class="d-flex justify-content-between align-items-center">
                <div>
                    <div class="fw-medium" style="color: white;">${network.name}</div>
                    <small style="color: #ccc;">Chain ID: ${network.chainId}</small>
                </div>
                <i class="fas fa-chevron-right" style="color: #ccc;"></i>
            </div>
        `;
        
        item.addEventListener('click', async () => {
            debug.log('üéØ Rede selecionada', network);
            await selectNetwork(network);
            container.style.display = 'none';
        });
        
        // Hover effects melhorados
        item.addEventListener('mouseenter', () => {
            item.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            item.style.borderColor = '#adb5bd';
            item.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';
        });
        
        item.addEventListener('mouseleave', () => {
            item.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
            item.style.borderColor = '#dee2e6';
            item.style.boxShadow = 'none';
        });
        
        container.appendChild(item);
    });
    
    // Mostrar container se houver resultados
    if (networks.length > 0) {
        container.style.display = 'block';
        debug.log(`‚úÖ Autocomplete exibido com ${networks.length} resultados`);
    } else {
        container.style.display = 'none';
        debug.log('‚ÑπÔ∏è Nenhum resultado para exibir');
    }
}

// Seleconar rede (adaptada do lnk_ndex.js)
async function selectNetwork(network) {
    selectedNetwork = network;
    debug.log('üéØ Rede selecionada', network);
    
    // Preencher campos da se√ß√£o 1 (sele√ß√£o de rede)
    document.getElementById(networkSearchId).value = `${network.name} (${network.chainId})`;
    document.getElementById(networkAutocompleteId).style.display = 'none';
    
    // Preencher campos ocultos para manter dados em mem√≥ria
    document.getElementById('chainId').value = network.chainId;
    document.getElementById('networkName').value = network.name;
    
    // Preencher campos de moeda nativa (agora na se√ß√£o 1)
    const nativeCurrencyName = network.nativeCurrency && network.nativeCurrency.name 
        ? network.nativeCurrency.name 
        : (network.nativeCurrency && network.nativeCurrency.symbol 
            ? network.nativeCurrency.symbol 
            : 'N/A');
    
    const nativeCurrencySymbol = network.nativeCurrency && network.nativeCurrency.symbol 
        ? network.nativeCurrency.symbol 
        : 'N/A';
    
    document.getElementById('nativeCurrency').value = nativeCurrencyName;
    document.getElementById('nativeCurrencySymbol').value = nativeCurrencySymbol;
    
    debug.log('üí∞ Moeda nativa configurada', {
        name: nativeCurrencyName,
        symbol: nativeCurrencySymbol,
        originalData: network.nativeCurrency
    });
    
    // Preencher campos da se√ß√£o 2 (informa√ß√µes da rede)
    document.getElementById(rpcUrlId).value = network.rpc[0];
    document.getElementById(explorerUrlId).value = network.explorers ? network.explorers[0].url : '';
    
    // Mostrar se√ß√µes ocultas com nova estrutura
    const nativeCurrencySection = document.getElementById('native-currency-section');
    const networkUrlsSection = document.getElementById('network-urls-section');
    const networkInfoSection = document.getElementById('network-info-section');
    const rpcConfigSection = document.getElementById('rpc-config-section');
    const addNetworkSection = document.getElementById('add-network-section');
    
    if (nativeCurrencySection) nativeCurrencySection.classList.remove('hidden-section');
    if (networkUrlsSection) networkUrlsSection.classList.remove('hidden-section');
    if (networkInfoSection) networkInfoSection.classList.remove('hidden-section');
    if (rpcConfigSection) rpcConfigSection.classList.remove('hidden-section');
    if (addNetworkSection) addNetworkSection.classList.remove('hidden-section');
    
    // Carregar RPCs personalizadas existentes
    await loadExistingCustomRpcs();
    
    // Atualizar status do bot√£o
    updateAddNetworkButton();
    
    debug.log('‚úÖ Rede selecionada e campos preenchidos', {
        name: network.name,
        chainId: network.chainId,
        rpc: network.rpc[0],
        explorer: network.explorers ? network.explorers[0].url : 'N/A'
    });
}

// Fun√ß√£o para adicionar rede ao MetaMask
async function addNetwork() {
    console.log('üî• IN√çCIO - Fun√ß√£o addNetwork chamada');
    
    if (!selectedNetwork) {
        console.error('‚ùå ERRO: Nenhuma rede selecionada');
        showMessage('Selecione uma rede primeiro.', 'error');
        debug.error('‚ùå Tentativa de adicionar rede sem sele√ß√£o');
        return;
    }

    console.log('‚úÖ Rede selecionada:', selectedNetwork);

    // Verificar MetaMask apenas no momento de adicionar
    if (typeof window.ethereum === 'undefined') {
        console.error('‚ùå ERRO: MetaMask n√£o encontrado');
        showMessage('MetaMask n√£o encontrado. Instale a extens√£o para continuar.', 'error');
        debug.error('‚ùå MetaMask n√£o encontrado');
        return;
    }

    console.log('‚úÖ MetaMask detectado:', window.ethereum);

    try {
        debug.log('üöÄ Iniciando adi√ß√£o de rede ao MetaMask', selectedNetwork);
        
        // Obter dados da rede selecionada
        const networkName = selectedNetwork.name;
        const chainId = selectedNetwork.chainId;
        const nativeCurrencyName = selectedNetwork.nativeCurrency?.name || 'ETH';
        const nativeCurrencySymbol = selectedNetwork.nativeCurrency?.symbol || 'ETH';
        const nativeCurrencyDecimals = selectedNetwork.nativeCurrency?.decimals || 18;
        
        console.log('üìã Dados b√°sicos da rede:', {
            networkName,
            chainId,
            nativeCurrencyName,
            nativeCurrencySymbol,
            nativeCurrencyDecimals
        });
        
        // Obter URLs RPC (padr√£o + personalizada se houver)
        // IMPORTANTE: Limpar completamente backticks, espa√ßos e caracteres especiais
        let rpcUrls = [...selectedNetwork.rpc].map(url => cleanUrl(url));
        
        const customRpcField = document.getElementById('customRpcUrl');
        if (customRpcField && customRpcField.value.trim()) {
            console.log('üìù RPCs personalizadas encontradas:', customRpcField.value);
            // Dividir por linhas OU ponto e v√≠rgula e filtrar linhas vazias, aplicar limpeza
            const customUrls = customRpcField.value.trim()
                .split(/[\n;]/) // Dividir por quebra de linha OU ponto e v√≠rgula
                .map(url => cleanUrl(url))
                .filter(url => {
                    // Aceitar URLs HTTP e HTTPS v√°lidas
                    if (url.length > 0 && (url.startsWith('https://') || url.startsWith('http://'))) {
                        return true;
                    }
                    return false;
                });
            
            if (customUrls.length > 0) {
                // Separar URLs HTTP e HTTPS para feedback
                const httpsUrls = customUrls.filter(url => url.startsWith('https://'));
                const httpUrls = customUrls.filter(url => url.startsWith('http://'));
                
                rpcUrls.push(...customUrls);
                console.log('üîó RPCs v√°lidas adicionadas:', customUrls);
                
                // Mostrar feedback detalhado
                let feedbackMsg = `${customUrls.length} RPC(s) personalizada(s) adicionada(s)`;
                if (httpUrls.length > 0) {
                    feedbackMsg += ` (${httpUrls.length} HTTP, ${httpsUrls.length} HTTPS)`;
                }
                console.log('‚úÖ ' + feedbackMsg);
            } else {
                console.warn('‚ö†Ô∏è Nenhuma RPC personalizada v√°lida encontrada');
                showMessage('Nenhuma RPC personalizada v√°lida encontrada. Verifique o formato das URLs.', 'warning');
            }
            console.log('üîó RPCs ap√≥s adicionar personalizadas:', rpcUrls);
        } else {
            console.log('üìù Nenhuma RPC personalizada, usando padr√£o:', rpcUrls);
        }
        
        // Obter URLs do block explorer
        let blockExplorerUrls = [];
        if (selectedNetwork.explorers && selectedNetwork.explorers.length > 0) {
            blockExplorerUrls = selectedNetwork.explorers.map(explorer => cleanUrl(explorer.url));
        }
        
        console.log('üîç Block Explorer URLs:', blockExplorerUrls);
        
        const networkData = {
            chainId: `0x${chainId.toString(16)}`,
            chainName: networkName,
            nativeCurrency: {
                name: nativeCurrencyName,
                symbol: nativeCurrencySymbol,
                decimals: nativeCurrencyDecimals
            },
            rpcUrls: rpcUrls,
            blockExplorerUrls: blockExplorerUrls
        };

        console.log('üì° DADOS FINAIS PARA METAMASK:', JSON.stringify(networkData, null, 2));
        debug.log('üì° Dados da rede preparados', networkData);
        
        console.log('üöÄ Chamando MetaMask API...');
        
        // Chamar diretamente a API do MetaMask
        const result = await window.ethereum.request({
            method: 'wallet_addEthereumChain',
            params: [networkData]
        });
        
        console.log('‚úÖ SUCESSO: MetaMask retornou:', result);
        
        // IMPORTANTE: Tentar trocar para a rede rec√©m-adicionada para for√ßar o MetaMask a carregar as RPCs
        try {
            console.log('üîÑ Tentando trocar para a rede rec√©m-adicionada...');
            const switchResult = await window.ethereum.request({
                method: 'wallet_switchEthereumChain',
                params: [{ chainId: networkData.chainId }]
            });
            console.log('‚úÖ SUCESSO: Trocou para a rede:', switchResult);
            
            // Aguardar um momento para o MetaMask processar a troca
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Verificar se realmente trocou para a rede
            const currentChainId = await window.ethereum.request({ method: 'eth_chainId' });
            console.log('üîç Chain ID atual ap√≥s troca:', currentChainId);
            console.log('üîç Chain ID esperado:', networkData.chainId);
            
            if (currentChainId === networkData.chainId) {
                console.log('‚úÖ CONFIRMADO: MetaMask est√° na rede correta');
                showMessage(`Rede ${networkData.chainName} adicionada e ativada com sucesso!`, 'success');
            } else {
                console.log('‚ö†Ô∏è AVISO: MetaMask n√£o trocou para a rede esperada');
                showMessage(`Rede ${networkData.chainName} adicionada, mas n√£o foi poss√≠vel ativar automaticamente. Troque manualmente no MetaMask.`, 'success');
            }
            
        } catch (switchError) {
            console.log('‚ÑπÔ∏è N√£o foi poss√≠vel trocar automaticamente:', switchError.message);
            console.log('üìã Detalhes do erro de troca:', switchError);
            showMessage(`Rede ${networkData.chainName} adicionada com sucesso! Troque manualmente no MetaMask para usar.`, 'success');
        }
        
        // Salvar RPCs personalizadas se houver
        if (customRpcField && customRpcField.value.trim()) {
            saveCustomRpcs(rpcUrls);
        }
        
        // Mostrar feedback detalhado sobre as RPCs adicionadas
        const customUrls = customRpcField && customRpcField.value.trim() ? 
            customRpcField.value.trim()
                .split(/[\n;]/)
                .map(url => cleanUrl(url))
                .filter(url => url.length > 0 && (url.startsWith('https://') || url.startsWith('http://'))) : [];
        
        if (customUrls.length > 0) {
            const httpsUrls = customUrls.filter(url => url.startsWith('https://'));
            const httpUrls = customUrls.filter(url => url.startsWith('http://'));
            
            let detailedMsg = `Rede ${networkData.chainName} adicionada com ${rpcUrls.length} RPC(s) total`;
            if (customUrls.length > 0) {
                detailedMsg += ` (${customUrls.length} personalizada(s)`;
                if (httpUrls.length > 0) {
                    detailedMsg += `: ${httpsUrls.length} HTTPS, ${httpUrls.length} HTTP`;
                }
                detailedMsg += ')';
            }
            console.log('üìä ' + detailedMsg);
        }
        
        // N√£o mostrar mensagem gen√©rica aqui, pois j√° foi mostrada acima baseada no resultado da troca
        debug.log('‚úÖ Rede adicionada ao MetaMask com sucesso');
        
        // Limpar dados ap√≥s sucesso (aguardar 2 segundos para mostrar mensagem)
        setTimeout(() => {
            clearAllFields();
        }, 2000);
        
    } catch (error) {
        console.error('‚ùå ERRO DETALHADO:', {
            message: error.message,
            code: error.code,
            data: error.data,
            stack: error.stack
        });
        debug.error('‚ùå Erro ao adicionar rede', error);
        
        // Tratamento espec√≠fico para diferentes tipos de erro
        let userMessage = '';
        
        console.log('üîç C√≥digo do erro:', error.code);
        console.log('üîç Mensagem do erro:', error.message);
        
        switch (error.code) {
            case 4001:
                userMessage = 'üö´ Opera√ß√£o cancelada pelo usu√°rio.\n\n‚úÖ Para adicionar a rede:\n1. Clique novamente em "Adicionar Rede ao MetaMask"\n2. Aceite a solicita√ß√£o no popup do MetaMask\n3. Clique em "Aprovar" ou "Add Network"';
                break;
            case 4902:
                userMessage = '‚ùå Rede n√£o reconhecida pelo MetaMask. Verifique os dados da rede.';
                break;
            case -32602:
                userMessage = '‚ùå Par√¢metros inv√°lidos. Verifique as URLs RPC e dados da rede.';
                break;
            case -32603:
                userMessage = '‚ùå Erro interno do MetaMask. Tente novamente em alguns segundos.';
                break;
            default:
                userMessage = `‚ùå Erro ao adicionar rede: ${error.message}\n\nüí° Dica: Se voc√™ cancelou no MetaMask, tente novamente e aceite a solicita√ß√£o.`;
        }
        
        showMessage(userMessage, 'error');
        
        // Log adicional para debug
        console.log('üîç Dica: Para adicionar a rede com sucesso:');
        console.log('  1. Aceite a solicita√ß√£o no popup do MetaMask');
        console.log('  2. Verifique se as URLs RPC s√£o v√°lidas');
        console.log('  3. Certifique-se de que o MetaMask est√° desbloqueado');
    }
}

// Fun√ß√£o para mostrar mensagens de status
function showMessage(message, type = 'info') {
    const errorMessage = document.getElementById('errorMessage');
    const successMessage = document.getElementById('successMessage');
    const errorText = document.getElementById('errorText');
    const successText = document.getElementById('successText');
    
    // Esconder todas as mensagens primeiro
    if (errorMessage) {
        errorMessage.style.display = 'none';
    }
    if (successMessage) {
        successMessage.style.display = 'none';
    }
    
    // Mostrar a mensagem apropriada
    if (type === 'success' && successMessage && successText) {
        successText.innerHTML = message.replace(/\n/g, '<br>');
        successMessage.style.display = 'block';
    } else if (errorMessage && errorText) {
        errorText.innerHTML = message.replace(/\n/g, '<br>');
        errorMessage.style.display = 'block';
    }
    
    // Auto-hide ap√≥s 10 segundos para mensagens de erro
    if (type === 'error') {
        setTimeout(() => {
            hideMessage();
        }, 10000);
    }
}

// Fun√ß√£o para ocultar mensagens
function hideMessage() {
    const errorMessage = document.getElementById('errorMessage');
    const successMessage = document.getElementById('successMessage');
    
    if (errorMessage) {
        errorMessage.style.display = 'none';
    }
    if (successMessage) {
        successMessage.style.display = 'none';
    }
}

// FunÔøΩÔøΩo para atualizar o botÔøΩo de adicionar rede
function updateAddNetworkButton() {
    const addNetworkBtn = document.getElementById('addNetworkBtn');
    const walletStatus = document.getElementById('walletStatus');
    
    if (!addNetworkBtn) return;
    
    if (!selectedNetwork) {
        addNetworkBtn.disabled = true;
        if (walletStatus) {
            walletStatus.textContent = 'Selecione uma rede para continuar';
        }
    } else {
        addNetworkBtn.disabled = false;
        if (walletStatus) {
            walletStatus.textContent = `Rede selecionada: ${selectedNetwork.name}`;
        }
    }
}

// Inicializa√ß√£o quando o DOM estiver carregado
document.addEventListener('DOMContentLoaded', async () => {
    debug.log('üöÄ Inicializando RPC Index...');
    
    // Verificar elementos essenciais
    debug.checkElement(networkSearchId);
    debug.checkElement(networkAutocompleteId);
    debug.checkElement(rpcUrlId);
    debug.checkElement(explorerUrlId);
    
    try {
        // Carregar redes
        await loadNetworks();
        debug.log(`‚úÖ Redes carregadas: ${allNetworks.length}`);
    } catch (error) {
        debug.error('‚ùå Erro ao carregar redes', error);
    }
    
    // Configurar event listener para o bot√£o de adicionar rede
    const addNetworkBtn = document.getElementById('addNetworkBtn');
    if (addNetworkBtn) {
        addNetworkBtn.addEventListener('click', addNetwork);
        debug.log('‚úÖ Event listener do bot√£o configurado');
    } else {
        debug.error('‚ùå Bot√£o addNetworkBtn n√£o encontrado');
    }
    
    // Configurar event listener para o bot√£o de limpar
    const clearBtn = document.getElementById('clearBtn');
    if (clearBtn) {
        clearBtn.addEventListener('click', clearAllFields);
        debug.log('‚úÖ Event listener do bot√£o limpar configurado');
    } else {
        debug.error('‚ùå Bot√£o clearBtn n√£o encontrado');
    }
    
    // Event listeners para o campo de busca de rede
    const networkSearch = document.getElementById(networkSearchId);
    if (networkSearch) {
        debug.log('‚úÖ Campo de busca de rede encontrado');
        
        networkSearch.addEventListener('input', function() {
            const query = this.value.trim();
            debug.log('üîç Busca realizada', { query, length: query.length });
            
            if (query.length >= 2) {
                // Filtrar redes baseado na query
                const filteredNetworks = allNetworks.filter(network => {
                    const searchTerm = query.toLowerCase();
                    return network.name.toLowerCase().includes(searchTerm) ||
                           network.chainId.toString().includes(searchTerm) ||
                           (network.nativeCurrency && network.nativeCurrency.symbol && 
                            network.nativeCurrency.symbol.toLowerCase().includes(searchTerm));
                });
                
                debug.log(`üéØ Redes filtradas: ${filteredNetworks.length}`, filteredNetworks.slice(0, 3));
                
                // Mostrar autocomplete com redes filtradas
                showAutocomplete(filteredNetworks, networkAutocompleteId);
            } else {
                const autocompleteContainer = document.getElementById(networkAutocompleteId);
                if (autocompleteContainer) {
                    autocompleteContainer.style.display = 'none';
                }
                debug.log('‚ÑπÔ∏è Query muito curta, ocultando autocomplete');
            }
        });
        
        // Event listener para focus
        networkSearch.addEventListener('focus', function() {
            debug.log('üéØ Campo de busca focado');
            if (this.value.trim().length >= 2) {
                const autocompleteContainer = document.getElementById(networkAutocompleteId);
                if (autocompleteContainer && autocompleteContainer.children.length > 0) {
                    autocompleteContainer.style.display = 'block';
                }
            }
        });
        
    } else {
        debug.error('‚ùå Campo de busca de rede n√£o encontrado');
    }
    
    // Esconder autocomplete quando clicar fora
    document.addEventListener('click', function(e) {
        const autocompleteContainer = document.getElementById(networkAutocompleteId);
        const searchInput = document.getElementById(networkSearchId);
        
        if (!e.target.closest('#' + networkAutocompleteId) && e.target.id !== networkSearchId) {
            if (autocompleteContainer) {
                autocompleteContainer.style.display = 'none';
                debug.log('‚ÑπÔ∏è Autocomplete ocultado (clique fora)');
            }
        }
    });
    
    debug.log('‚úÖ RPC Index inicializado com sucesso');
    debug.generateReport();
});


// Fun√ß√£o para limpar todos os campos e voltar ao estado inicial
function clearAllFields() {
    debug.log('üßπ Limpando todos os campos...');
    
    // Limpar campo de busca
    const networkSearch = document.getElementById(networkSearchId);
    if (networkSearch) {
        networkSearch.value = '';
    }
    
    // Limpar campos de informa√ß√µes da rede
    document.getElementById('nativeCurrency').value = '';
    document.getElementById('nativeCurrencySymbol').value = '';
    document.getElementById(rpcUrlId).value = '';
    document.getElementById(explorerUrlId).value = '';
    
    // Limpar campo de RPC personalizada
    const customRpcField = document.getElementById('customRpcUrl');
    if (customRpcField) {
        customRpcField.value = '';
        customRpcField.placeholder = 'Cole suas URLs RPC aqui (uma por linha ou separadas por ;)';
    }
    
    // Limpar campos ocultos
    document.getElementById('chainId').value = '';
    document.getElementById('networkName').value = '';
    
    // Limpar localStorage de RPCs personalizadas para todas as redes
    try {
        const keys = Object.keys(localStorage);
        keys.forEach(key => {
            if (key.startsWith('custom-rpcs-')) {
                localStorage.removeItem(key);
                debug.log('üóëÔ∏è Removido do localStorage:', key);
            }
        });
    } catch (error) {
        debug.error('‚ùå Erro ao limpar localStorage:', error);
    }
    
    // Ocultar todas as se√ß√µes
    const sectionsToHide = [
        'native-currency-section',
        'network-urls-section', 
        'network-info-section',
        'rpc-config-section',
        'add-network-section'
    ];
    
    sectionsToHide.forEach(sectionId => {
        const section = document.getElementById(sectionId);
        if (section) {
            section.classList.add('hidden-section');
        }
    });
    
    // Ocultar autocomplete
    const autocompleteContainer = document.getElementById(networkAutocompleteId);
    if (autocompleteContainer) {
        autocompleteContainer.style.display = 'none';
    }
    
    // Ocultar mensagens de status
    hideMessage();
    
    // Resetar vari√°vel global
    selectedNetwork = null;
    
    // Desabilitar bot√£o de adicionar rede
    updateAddNetworkButton();
    
    debug.log('‚úÖ Campos limpos com sucesso');
}

// Fun√ß√£o para carregar RPCs personalizadas existentes no textarea
async function loadExistingCustomRpcs() {
    if (!selectedNetwork) return;
    
    const customRpcField = document.getElementById('customRpcUrl');
    if (!customRpcField) return;
    
    try {
        // Primeiro, tentar obter RPCs do ChainList se dispon√≠vel
        let chainListRpcs = [];
        if (typeof chainListAPI !== 'undefined') {
            try {
                debug.log('üåê Buscando RPCs do ChainList para a rede selecionada...');
                const workingRpcs = await chainListAPI.getWorkingRpcs(selectedNetwork.chainId);
                if (workingRpcs && workingRpcs.length > 0) {
                    chainListRpcs = workingRpcs.slice(0, 5); // Limitar a 5 RPCs do ChainList
                    debug.log(`‚úÖ ${chainListRpcs.length} RPCs encontradas no ChainList`, chainListRpcs);
                }
            } catch (error) {
                debug.log('‚ö†Ô∏è Erro ao buscar RPCs do ChainList:', error);
            }
        }
        
        // Segundo, tentar obter RPCs do MetaMask se dispon√≠vel
        let existingRpcs = [];
        
        if (window.ethereum) {
            try {
                // Verificar se j√° estamos na rede selecionada
                const currentChainId = await window.ethereum.request({ method: 'eth_chainId' });
                const targetChainId = `0x${selectedNetwork.chainId.toString(16)}`;
                
                if (currentChainId === targetChainId) {
                    // Se estivermos na rede, tentar obter informa√ß√µes da rede atual
                    const networkInfo = await window.ethereum.request({
                        method: 'wallet_getPermissions'
                    });
                    
                    // Nota: MetaMask n√£o exp√µe diretamente as RPCs configuradas
                    // Vamos usar o localStorage como fallback
                    debug.log('‚ÑπÔ∏è Usando localStorage para RPCs (MetaMask n√£o exp√µe RPCs diretamente)');
                }
            } catch (error) {
                debug.log('‚ÑπÔ∏è N√£o foi poss√≠vel obter RPCs do MetaMask, usando localStorage');
            }
        }
        
        // Carregar RPCs salvas no localStorage
        const savedCustomRpcs = localStorage.getItem(`custom-rpcs-${selectedNetwork.chainId}`);
        let localRpcs = [];
        if (savedCustomRpcs) {
            try {
                const rpcs = JSON.parse(savedCustomRpcs);
                if (Array.isArray(rpcs) && rpcs.length > 0) {
                    // Aplicar limpeza completa nas RPCs carregadas do localStorage
                    localRpcs = rpcs.map(url => cleanUrl(url));
                }
            } catch (error) {
                debug.error('‚ùå Erro ao carregar RPCs do localStorage:', error);
            }
        }
        
        // Combinar todas as RPCs: ChainList primeiro, depois populares, depois locais
        const popularRpcs = getPopularRpcsForNetwork(selectedNetwork.chainId);
        const allRpcs = [
            ...chainListRpcs,
            ...popularRpcs,
            ...localRpcs
        ];
        
        // Remover duplicatas mantendo a ordem
        const uniqueRpcs = [...new Set(allRpcs)];
        
        if (uniqueRpcs.length > 0) {
            customRpcField.value = uniqueRpcs.join('\n');
            debug.log('‚úÖ RPCs carregadas (ChainList + populares + locais)', uniqueRpcs);
        } else {
            customRpcField.value = '';
            debug.log('‚ÑπÔ∏è Nenhuma RPC encontrada para esta rede');
        }
        
    } catch (error) {
        debug.error('‚ùå Erro ao carregar RPCs personalizadas', error);
        // Em caso de erro, mostrar RPCs populares
        const popularRpcs = getPopularRpcsForNetwork(selectedNetwork.chainId);
        if (popularRpcs.length > 0) {
            customRpcField.value = popularRpcs.join('\n');
        }
    }
}

// Fun√ß√£o centralizada para limpeza completa de URLs
function cleanUrl(url) {
    if (!url) return '';
    
    let cleanUrl = url.toString();
    
    // Remover backticks e caracteres especiais
    cleanUrl = cleanUrl.replace(/[`'"]/g, '');
    
    // Remover espa√ßos no in√≠cio e fim
    cleanUrl = cleanUrl.trim();
    
    // Remover quebras de linha e caracteres de controle
    cleanUrl = cleanUrl.replace(/[\r\n\t]/g, '');
    
    // Remover espa√ßos extras internos (mas manter espa√ßos necess√°rios em URLs)
    cleanUrl = cleanUrl.replace(/\s+/g, '');
    
    return cleanUrl;
}

// Fun√ß√£o para obter RPCs populares para uma rede espec√≠fica
function getPopularRpcsForNetwork(chainId) {
    const popularRpcs = {
        97: [ // BNB Smart Chain Testnet
            'https://data-seed-prebsc-1-s1.binance.org:8545/',
            'https://data-seed-prebsc-2-s1.binance.org:8545/',
            'https://bsc-testnet.public.blastapi.io'
        ],
        56: [ // BNB Smart Chain Mainnet
            'https://bsc-dataseed1.binance.org/',
            'https://bsc-dataseed2.binance.org/',
            'https://bsc-dataseed3.binance.org/',
            'https://bsc-dataseed4.binance.org/'
        ],
        1: [ // Ethereum Mainnet
            'https://rpc.ankr.com/eth',
            'https://eth-mainnet.g.alchemy.com/v2/demo',
            'https://mainnet.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161'
        ],
        137: [ // Polygon Mainnet
            'https://polygon-rpc.com',
            'https://rpc-mainnet.matic.network',
            'https://matic-mainnet.chainstacklabs.com'
        ],
        80001: [ // Polygon Mumbai Testnet
            'https://rpc-mumbai.maticvigil.com',
            'https://matic-mumbai.chainstacklabs.com',
            'https://rpc-mumbai.matic.today'
        ]
    };
    
    // Aplicar limpeza em todas as URLs
    const rpcs = popularRpcs[chainId] || [];
    return rpcs.map(url => cleanUrl(url));
}

// Fun√ß√£o para salvar RPCs personalizadas
function saveCustomRpcs(rpcUrls) {
    if (!selectedNetwork || !rpcUrls || rpcUrls.length === 0) return;
    
    try {
        // Filtrar apenas as RPCs que n√£o s√£o padr√£o da rede e aplicar limpeza
        const customRpcs = rpcUrls
            .filter(url => !selectedNetwork.rpc.includes(url))
            .map(url => cleanUrl(url));
        
        if (customRpcs.length > 0) {
            localStorage.setItem(`custom-rpcs-${selectedNetwork.chainId}`, JSON.stringify(customRpcs));
            debug.log('‚úÖ RPCs personalizadas salvas', customRpcs);
        }
    } catch (error) {
        debug.error('‚ùå Erro ao salvar RPCs personalizadas', error);
    }
}


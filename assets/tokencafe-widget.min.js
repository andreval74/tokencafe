// TOKENCAFE WIDGET LOADER (Standalone)
// Este arquivo √© o √∫nico necess√°rio para incorporar widgets em sites externos
// Vers√£o: 1.0.0
// Uso: <script src="/assets/tokencafe-widget.min.js" async></script>
//      <div class="tokencafe-widget" data-owner="0x..." data-code="..."></div>

(function () {
  "use strict";

  // ============================================================================
  // CONFIGURA√á√ÉO E UTILIT√ÅRIOS
  // ============================================================================

  const CONFIG = {
    jsonBasePath: "/widget/gets/", // Caminho base para JSONs de configura√ß√£o
    ethersJsCDN: "https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js",
    version: "1.0.0",
  };

  /**
   * Fallbacks de RPC por chainId conhecido
   */
  function getFallbackRpc(chainId) {
    const rpcs = {
      1: "https://eth.llamarpc.com",
      56: "https://bsc-dataseed.binance.org",
      97: "https://bsc-testnet.publicnode.com",
      137: "https://polygon-rpc.com",
      80001: "https://rpc-mumbai.maticvigil.com",
    };
    return rpcs[Number(chainId)] || "";
  }

  /**
   * Log unificado (pode ser desabilitado)
   */
  function log(msg, type = "info") {
    const prefix = "[TokenCafe Widget]";
    if (type === "error") console.error(prefix, msg);
    else if (type === "warn") console.warn(prefix, msg);
    else console.log(prefix, msg);
  }

  /**
   * Exibe erro amig√°vel no container
   */
  function showError(container, message) {
    try {
      if (typeof window.notify === "function") {
        window.notify(String(message || ""), "error", { container });
        return;
      }
    } catch (_) {}
    container.innerHTML = `
      <div style="padding:1rem;border:2px solid #dc3545;border-radius:8px;background:#ffe6e6;color:#721c24;font-family:sans-serif;">
        <strong>‚ö†Ô∏è Erro ao carregar widget:</strong>
        <p style="margin:0.5rem 0 0;">${message}</p>
      </div>
    `;
  }

  /**
   * Carrega ethers.js se n√£o existir
   */
  function ensureEthers() {
    if (typeof ethers !== "undefined") {
      return Promise.resolve();
    }

    return new Promise((resolve, reject) => {
      const script = document.createElement("script");
      script.src = CONFIG.ethersJsCDN;
      script.onload = resolve;
      script.onerror = () => reject(new Error("Falha ao carregar ethers.js"));
      document.head.appendChild(script);
    });
  }

  // ============================================================================
  // CARREGAR E VALIDAR CONFIGURA√á√ÉO
  // ============================================================================

  /**
   * Busca JSON de configura√ß√£o do widget
   * @param {string} owner - Endere√ßo owner (checksum)
   * @param {string} code - C√≥digo do widget
   * @returns {Promise<Object>} Configura√ß√£o JSON
   */
  async function loadWidgetConfig(owner, code) {
    const url = `${CONFIG.jsonBasePath}${owner}/${code}.json`;

    log(`Carregando configura√ß√£o de: ${url}`);

    try {
      const response = await fetch(url, {
        cache: "no-store",
        headers: { Accept: "application/json" },
      });

      log(`Response status: ${response.status}`);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const config = await response.json();

      log("Configura√ß√£o carregada com sucesso");

      // Validar campos obrigat√≥rios
      if (!config.contracts || !config.contracts.sale) {
        throw new Error("Configura√ß√£o inv√°lida: contrato Sale ausente");
      }
      if (!config.contracts.receiverWallet) {
        throw new Error("Configura√ß√£o inv√°lida: carteira recebedora ausente");
      }
      if (!config.network || !config.network.chainId) {
        throw new Error("Configura√ß√£o inv√°lida: chainId ausente");
      }

      return config;
    } catch (error) {
      log(`Erro ao carregar ${url}: ${error.message}`, "error");
      throw error;
    }
  }

  // ============================================================================
  // RENDERIZA√á√ÉO DO WIDGET
  // ============================================================================

  /**
   * Cria HTML do widget (UI m√≠nima e limpa)
   * @param {Object} config - Configura√ß√£o JSON do widget
   * @returns {string} HTML do widget
   */
  function createWidgetHTML(config) {
    const ui = config.ui || {};
    const theme = ui.theme || "light";
    const texts = ui.texts || {};
    const contracts = config.contracts || {};
    const network = config.network || {};

    const title = texts.title || "Comprar Tokens";
    const buyButton = texts.buyButton || "Conectar MetaMask";
    const currencySymbol = ui.currencySymbol || "BNB";
    const tokenSymbol = contracts.tokenSymbol || "TOKEN";
    const tokenPrice = ui.tokenPrice || "0.01";
    const availableTokens = ui.availableTokens || "1M";

    // Estilos seguindo o design do XCafe
    const isDark = theme === "dark";
    const primaryColor = isDark ? "#1e88e5" : "#0d6efd";
    const bgColor = isDark ? "#1a1a1a" : "#ffffff";
    const textColor = isDark ? "#e0e0e0" : "#333333";
    const borderColor = isDark ? "#0d6efd" : "#0d6efd";
    const cardBg = isDark ? "#2a2a2a" : "#f8f9fa";
    const warningBg = isDark ? "#ffc107" : "#fff3cd";
    const warningText = isDark ? "#000" : "#856404";

    return `
      <div class="tokencafe-widget-container" style="
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        max-width: 420px;
        margin: 0 auto;
        padding: 1.5rem;
        background: ${bgColor};
        color: ${textColor};
        border: 3px solid ${borderColor};
        border-radius: 16px;
        box-shadow: 0 4px 20px rgba(13,110,253,0.15);
        position: relative;
      ">
        <!-- Badge DEMO -->
        <div style="
          position: absolute;
          top: 1rem;
          right: 1rem;
          background: #28a745;
          color: white;
          padding: 0.25rem 0.75rem;
          border-radius: 12px;
          font-size: 0.75rem;
          font-weight: 700;
          text-transform: uppercase;
        ">
          DEMO
        </div>
        
        <!-- Cabe√ßalho com √≠cone -->
        <div style="margin-bottom: 1.5rem;">
          <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 1.5rem;">
            <div style="
              width: 48px;
              height: 48px;
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              border-radius: 50%;
              display: flex;
              align-items: center;
              justify-content: center;
              font-size: 1.5rem;
            ">
              ü™ô
            </div>
            <div style="flex: 1;">
              <h3 style="margin: 0; font-size: 1.1rem; font-weight: 600; display: flex; align-items: center; gap: 0.5rem;">
                ${tokenSymbol} Token
                <span style="
                  background: ${primaryColor};
                  color: white;
                  padding: 0.15rem 0.5rem;
                  border-radius: 6px;
                  font-size: 0.75rem;
                  font-weight: 700;
                ">
                  ${tokenSymbol.toUpperCase()}
                </span>
              </h3>
            </div>
          </div>
          
          <!-- Pre√ßo e Disponibilidade -->
          <div style="
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            padding: 1rem;
            background: ${cardBg};
            border-radius: 8px;
            margin-bottom: 1.5rem;
          ">
            <div>
              <div style="font-size: 0.85rem; color: ${isDark ? "#aaa" : "#666"}; margin-bottom: 0.25rem;">Pre√ßo</div>
              <div style="font-size: 1.25rem; font-weight: 700; color: ${primaryColor};">
                $${tokenPrice} USDT
              </div>
            </div>
            <div style="text-align: right;">
              <div style="font-size: 0.85rem; color: ${isDark ? "#aaa" : "#666"}; margin-bottom: 0.25rem;">Dispon√≠vel</div>
              <div style="font-size: 1.25rem; font-weight: 700; color: ${primaryColor};">
                ${availableTokens} Tokens
              </div>
            </div>
          </div>
        </div>
        
        <!-- Campo de Quantidade -->
        <div style="margin-bottom: 1rem;">
          <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; font-size: 0.9rem;">
            Quantidade de Tokens
          </label>
          <div style="position: relative;">
            <input 
              type="number" 
              id="widget-quantity" 
              min="1" 
              step="1" 
              value="100"
              placeholder="100"
              style="
                width: 100%;
                padding: 0.75rem;
                padding-right: 80px;
                font-size: 1rem;
                border: 2px solid ${isDark ? "#444" : "#dee2e6"};
                border-radius: 8px;
                background: ${bgColor};
                color: ${textColor};
                box-sizing: border-box;
                font-weight: 500;
              "
            />
            <div style="
              position: absolute;
              right: 0;
              top: 0;
              bottom: 0;
              background: ${primaryColor};
              color: white;
              padding: 0 1rem;
              display: flex;
              align-items: center;
              border-radius: 0 8px 8px 0;
              font-weight: 600;
              font-size: 0.9rem;
            ">
              Tokens
            </div>
          </div>
        </div>
        
        <!-- Total -->
        <div style="
          padding: 0.75rem 1rem;
          background: ${cardBg};
          border-radius: 8px;
          margin-bottom: 1.5rem;
          display: flex;
          justify-content: space-between;
          align-items: center;
        ">
          <span style="font-weight: 600;">Total:</span>
          <span id="widget-total" style="font-size: 1.25rem; font-weight: 700; color: ${primaryColor};">
            $1.00 USDT
          </span>
        </div>
        
        <!-- Aviso de carteira -->
        <div id="widget-wallet-warning" style="
          padding: 0.75rem 1rem;
          background: ${warningBg};
          border: 1px solid #ffc107;
          border-radius: 8px;
          margin-bottom: 1rem;
          display: flex;
          align-items: center;
          gap: 0.5rem;
          color: ${warningText};
          font-size: 0.9rem;
        ">
          <span style="font-size: 1.2rem;">üîê</span>
          <span style="font-weight: 500;">Conecte sua carteira para continuar</span>
        </div>
        
        <!-- Bot√£o principal -->
        <button 
          id="widget-buy-btn"
          style="
            width: 100%;
            padding: 1rem;
            font-size: 1.1rem;
            font-weight: 700;
            color: white;
            background: ${primaryColor};
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
          "
          onmouseover="this.style.background='#0b5ed7'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(13,110,253,0.3)'"
          onmouseout="this.style.background='${primaryColor}'; this.style.transform='translateY(0)'; this.style.boxShadow='none'"
        >
          <span>‚óÜ</span>
          ${buyButton}
        </button>
        
        <!-- Status/mensagens -->
        <div 
          id="widget-status" 
          style="
            margin-top: 1rem;
            padding: 0.75rem;
            border-radius: 6px;
            font-size: 0.9rem;
            text-align: center;
            display: none;
          "
        ></div>
        
        <!-- Footer -->
        <div style="
          margin-top: 1.5rem;
          padding-top: 1rem;
          border-top: 1px solid ${isDark ? "#444" : "#dee2e6"};
          text-align: center;
          font-size: 0.75rem;
          color: ${isDark ? "#777" : "#999"};
        ">
          <div style="display: flex; align-items: center; justify-content: center; gap: 0.35rem; margin-bottom: 0.5rem;">
            <span style="font-size: 1rem;">üîí</span>
            <span>Transa√ß√£o segura via blockchain</span>
          </div>
          <div style="display: flex; align-items: center; justify-content: center; gap: 0.35rem;">
            <span style="font-size: 0.9rem;">üíª</span>
            <span>Desenvolvido por <strong>tokencafe.app</strong></span>
          </div>
        </div>
      </div>
    `;
  }

  /**
   * Exibe mensagem de status no widget
   */
  function showStatus(container, message, type = "info") {
    try {
      if (typeof window.notify === "function") {
        window.notify(String(message || ""), String(type || "info"), { container });
        return;
      }
    } catch (_) {}
    const statusEl = container.querySelector("#widget-status");
    if (!statusEl) return;
    const colors = {
      info: { bg: "#e3f2fd", text: "#1976d2", border: "#1976d2" },
      success: { bg: "#e8f5e9", text: "#388e3c", border: "#388e3c" },
      error: { bg: "#ffebee", text: "#c62828", border: "#c62828" },
      warning: { bg: "#fff3e0", text: "#f57c00", border: "#f57c00" },
    };
    const color = colors[type] || colors.info;
    statusEl.style.display = "block";
    statusEl.style.background = color.bg;
    statusEl.style.color = color.text;
    statusEl.style.border = `1px solid ${color.border}`;
    statusEl.textContent = message;
  }

  // ============================================================================
  // L√ìGICA DE INTERA√á√ÉO COM BLOCKCHAIN
  // ============================================================================

  /**
   * Testa configura√ß√£o com estimateGas (sem enviar transa√ß√£o)
   */
  async function testWidget(config, container) {
    showStatus(container, "üîç Testando configura√ß√£o...", "info");

    try {
      // Criar provider (RPC do config ou fallback)
      const rpcUrl = config.network.rpcUrl || getFallbackRpc(config.network.chainId);
      if (!rpcUrl) throw new Error(`RPC n√£o configurado para chainId ${config.network.chainId}`);
      const provider = new ethers.providers.JsonRpcProvider(rpcUrl);

      // Verificar se Sale existe na rede
      const saleAddr = config.contracts.sale;
      const saleCode = await provider.getCode(saleAddr);
      if (!saleCode || saleCode === "0x") throw new Error("Contrato Sale n√£o encontrado na rede");

      // Entradas da UI (se existirem)
      const qtyInput = container.querySelector("#widget-quantity");
      const valInput = container.querySelector("#widget-value");
      const funcName = config.purchase.functionName || "buy";
      const valueStr = (valInput?.value || "").trim();
      let value;
      try {
        value = ethers.utils.parseEther(valueStr && !isNaN(+valueStr) ? valueStr : "0.01");
      } catch {
        value = ethers.utils.parseEther("0.01");
      }

      // ABI m√≠nima
      const minAbiSale = config.advanced?.minAbi?.sale || [`function ${funcName}() payable`, `function ${funcName}(uint256) payable`];
      const minAbiToken = config.advanced?.minAbi?.token || ["function decimals() view returns (uint8)"];

      // Descobrir decimals do token (se dispon√≠vel)
      let decimals = 18;
      const tokenAddr = config.contracts.token;
      if (tokenAddr) {
        try {
          const token = new ethers.Contract(tokenAddr, minAbiToken, provider);
          decimals = await token.decimals();
        } catch (e) {
          log(`N√£o foi poss√≠vel obter decimals do token, assumindo 18. Motivo: ${e.message}`, "warn");
          decimals = 18;
        }
      }

      // Quantidade
      let quantityUnits = null;
      if (config.purchase.argsMode !== "none") {
        const qtyStr = (qtyInput?.value || "100").trim();
        try {
          quantityUnits = ethers.utils.parseUnits(qtyStr || "100", decimals);
        } catch {
          quantityUnits = ethers.utils.parseUnits("100", decimals);
        }
      }

      // Primeiro: tentar com carteira (se dispon√≠vel) para uma estimativa mais realista
      if (window.ethereum) {
        try {
          const web3 = new ethers.providers.Web3Provider(window.ethereum);
          // N√£o solicitar contas ainda; tentar usar conta atual se j√° conectada
          let signer;
          try {
            signer = web3.getSigner();
            // For√ßa acesso ao address para validar conex√£o
            await signer.getAddress();
          } catch (_e) {
            signer = null;
          }
          if (signer) {
            const saleWithSigner = new ethers.Contract(saleAddr, minAbiSale, signer);
            let gasEstimate;
            if (config.purchase.argsMode === "none") {
              gasEstimate = await saleWithSigner.estimateGas[funcName]({
                value,
              });
            } else {
              gasEstimate = await saleWithSigner.estimateGas[funcName](quantityUnits, { value });
            }
            showStatus(container, `‚úÖ Teste OK! Gas estimado: ${gasEstimate.toString()}`, "success");
            log(`Teste (com carteira) OK. Gas: ${gasEstimate.toString()}`);
            return;
          }
        } catch (e) {
          log(`Estimate com carteira falhou: ${e.message}`, "warn");
        }
      }

      // Segundo: fallback sem carteira
      const saleRead = new ethers.Contract(saleAddr, minAbiSale, provider);

      // a) Tentar callStatic (sem gas), s√≥ para verificar se n√£o reverte
      try {
        if (config.purchase.argsMode === "none") {
          await saleRead.callStatic[funcName]({ value });
        } else {
          await saleRead.callStatic[funcName](quantityUnits, { value });
        }
        // b) Tentar estimateGas com from fict√≠cio (alguns RPCs exigem)
        let gasEstimate;
        const overrides = {
          value,
          from: config.contracts.receiverWallet || config.owner || undefined,
        };
        try {
          if (config.purchase.argsMode === "none") {
            gasEstimate = await saleRead.estimateGas[funcName](overrides);
          } else {
            gasEstimate = await saleRead.estimateGas[funcName](quantityUnits, overrides);
          }
          showStatus(container, `‚úÖ Teste OK! Gas estimado: ${gasEstimate.toString()}`, "success");
          log(`Teste (sem carteira) OK. Gas: ${gasEstimate.toString()}`);
        } catch (egErr) {
          // Sem carteira, alguns RPCs n√£o estimam gas; reportar que callStatic passou
          log(`estimateGas sem carteira falhou: ${egErr.message}`, "warn");
          showStatus(container, "‚úÖ Teste OK (callStatic). Estimativa de gas indispon√≠vel sem carteira.", "success");
        }
      } catch (csErr) {
        log(`callStatic falhou: ${csErr.message}`, "error");
        showStatus(container, `‚ùå Erro no teste: ${csErr.message}`, "error");
      }
    } catch (error) {
      log(`Erro no teste: ${error.message}`, "error");
      showStatus(container, `‚ùå Erro: ${error.message}`, "error");
    }
  }

  /**
   * Executa compra real (requer MetaMask)
   */
  async function executeBuy(config, container) {
    showStatus(container, "üîó Conectando carteira...", "info");

    try {
      // Verificar MetaMask
      if (!window.ethereum) {
        throw new Error("MetaMask n√£o detectado. Instale para continuar.");
      }

      // Solicitar acesso
      await window.ethereum.request({ method: "eth_requestAccounts" });

      const provider = new ethers.providers.Web3Provider(window.ethereum);
      const signer = provider.getSigner();
      const address = await signer.getAddress();

      log(`Conectado como ${address}`);
      showStatus(container, `üîó Conectado: ${address.slice(0, 6)}...${address.slice(-4)}`, "info");

      // Verificar rede
      const network = await provider.getNetwork();
      if (network.chainId !== config.network.chainId) {
        throw new Error(`Troque para a rede correta (ChainId ${config.network.chainId})`);
      }

      // Pegar valores dos inputs
      const quantityInput = container.querySelector("#widget-quantity");
      const valueInput = container.querySelector("#widget-value");

      const quantity = quantityInput?.value || "100";
      const valueBNB = valueInput?.value || "0.1";

      const value = ethers.utils.parseEther(valueBNB);

      // Descobrir decimals do token (se dispon√≠vel)
      let decimals = 18;
      const tokenAddr = config.contracts.token;
      if (tokenAddr && config.purchase.argsMode !== "none") {
        try {
          const minAbiToken = config.advanced?.minAbi?.token || ["function decimals() view returns (uint8)"];
          const token = new ethers.Contract(tokenAddr, minAbiToken, provider);
          decimals = await token.decimals();
          log(`Token decimals: ${decimals}`);
        } catch (e) {
          log(`N√£o foi poss√≠vel obter decimals do token, assumindo 18. Motivo: ${e.message}`, "warn");
          decimals = 18;
        }
      }

      // ABI m√≠nima do Sale
      const minAbi = config.advanced?.minAbi?.sale || [`function ${config.purchase.functionName || "buy"}() payable`, `function ${config.purchase.functionName || "buy"}(uint256) payable`];

      const saleContract = new ethers.Contract(config.contracts.sale, minAbi, signer);
      const funcName = config.purchase.functionName || "buy";

      showStatus(container, "‚è≥ Aguardando confirma√ß√£o...", "info");

      // Executar compra
      let tx;
      if (config.purchase.argsMode === "none") {
        tx = await saleContract[funcName]({ value });
      } else {
        const quantityUnits = ethers.utils.parseUnits(quantity, decimals);
        log(`Comprando: ${quantity} tokens (${quantityUnits.toString()} units com ${decimals} decimals) por ${valueBNB} BNB`);
        tx = await saleContract[funcName](quantityUnits, { value });
      }

      showStatus(container, `‚è≥ Transa√ß√£o enviada. Aguardando confirma√ß√£o...`, "info");
      log(`Tx hash: ${tx.hash}`);

      const receipt = await tx.wait();

      showStatus(container, `‚úÖ Compra confirmada! Tx: ${tx.hash.slice(0, 10)}...`, "success");
      log(`Compra confirmada em bloco ${receipt.blockNumber}`);
    } catch (error) {
      log(`Erro na compra: ${error.message}`, "error");

      let errorMsg = error.message;
      if (error.code === "ACTION_REJECTED") {
        errorMsg = "Transa√ß√£o rejeitada pelo usu√°rio";
      } else if (error.code === "INSUFFICIENT_FUNDS") {
        errorMsg = "Saldo insuficiente para executar a transa√ß√£o";
      }

      showStatus(container, `‚ùå ${errorMsg}`, "error");
    }
  }

  // ============================================================================
  // INICIALIZA√á√ÉO DO WIDGET
  // ============================================================================

  /**
   * Inicializa um widget no container
   */
  async function initWidget(container) {
    const owner = container.getAttribute("data-owner");
    const code = container.getAttribute("data-code");

    if (!owner || !code) {
      showError(container, "Atributos data-owner e data-code s√£o obrigat√≥rios");
      return;
    }

    log(`Inicializando widget: owner=${owner}, code=${code}`);

    try {
      // Carregar ethers.js
      await ensureEthers();

      // Carregar configura√ß√£o
      const config = await loadWidgetConfig(owner, code);
      log("Configura√ß√£o carregada:", config);

      // Renderizar UI
      container.innerHTML = createWidgetHTML(config);

      // Vincular eventos
      const buyBtn = container.querySelector("#widget-buy-btn");
      const testBtn = container.querySelector("#widget-test-btn");
      const quantityInput = container.querySelector("#widget-quantity");
      const totalDisplay = container.querySelector("#widget-total");

      // Calcular total automaticamente
      const tokenPrice = parseFloat(config.ui?.tokenPrice || "0.01");

      function updateTotal() {
        const quantity = parseFloat(quantityInput.value) || 0;
        const total = (quantity * tokenPrice).toFixed(2);
        totalDisplay.textContent = `$${total} USDT`;
      }

      if (quantityInput) {
        quantityInput.addEventListener("input", updateTotal);
        updateTotal(); // Calcular inicial
      }

      if (buyBtn) {
        buyBtn.addEventListener("click", () => executeBuy(config, container));
      }

      if (testBtn) {
        testBtn.addEventListener("click", () => testWidget(config, container));
      }

      log("Widget inicializado com sucesso");
    } catch (error) {
      showError(container, error.message);
    }
  }

  // ============================================================================
  // AUTO-INICIALIZA√á√ÉO
  // ============================================================================

  /**
   * Procura e inicializa todos os widgets na p√°gina
   */
  function initAllWidgets() {
    log("initAllWidgets() chamado");

    const widgets = document.querySelectorAll(".tokencafe-widget[data-owner][data-code]");

    log(`Seletor encontrou ${widgets.length} elemento(s)`);

    if (!widgets.length) {
      log("Nenhum widget encontrado na p√°gina", "warn");
      return;
    }

    log(`Encontrados ${widgets.length} widget(s). Inicializando...`);

    widgets.forEach((widget, index) => {
      log(`Inicializando widget #${index + 1}`);
      setTimeout(() => initWidget(widget), index * 100); // Pequeno delay entre widgets
    });
  }

  // Aguardar DOM pronto
  log("Script carregado. Estado do documento:", document.readyState);

  if (document.readyState === "loading") {
    log("DOM ainda carregando. Aguardando DOMContentLoaded...");
    document.addEventListener("DOMContentLoaded", initAllWidgets);
  } else {
    log("DOM j√° pronto. Inicializando imediatamente...");
    initAllWidgets();
  }
})();

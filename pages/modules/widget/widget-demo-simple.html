<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mini Widget Demo (Simples)</title>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <style>
    body { font-family: Inter, Arial, sans-serif; background:#f7f7f8; margin:0; padding:24px; }
    .card { background:#fff; border-radius:14px; box-shadow:0 6px 18px rgba(0,0,0,.08); max-width:640px; margin:0 auto; padding:20px; }
    h2 { margin:0 0 10px; font-size:20px; }
    .muted { color:#555; font-size:0.92em; }
    label { display:block; margin-top:10px; font-weight:600; }
    select, button { width:100%; padding:10px; margin-top:6px; border:1px solid #d0d7de; border-radius:10px; }
    button { background:#2F6DF6; color:#fff; border:none; cursor:pointer; font-weight:600; }
    button:hover { background:#2559c7; }
    .row { display:flex; gap:10px; }
    .row > div { flex:1; }
    .msg { margin-top:10px; padding:10px; border-radius:10px; font-weight:600; }
    .success { background:#d1fae5; color:#065f46; }
    .error { background:#fee2e2; color:#7f1d1d; }
    .status { margin-top:6px; font-size:0.9em; color:#444; white-space:pre-wrap; }
  </style>
</head>
<body>
  <div class="card">
    <h2>Mini Widget • Compra Simples</h2>
    <div class="muted">Configuração interna, pronto para copiar e colar.</div>

    <!-- UI mínima -->
    <div class="row">
      <div>
        <label>Moeda de pagamento</label>
        <select id="currency"></select>
      </div>
      <div>
        <label>Quantidade</label>
        <select id="quantity"></select>
      </div>
    </div>

    <div id="totalInfo" class="muted" style="margin-top:8px">Total: aguardando configuração...</div>

    <button id="buyBtn">Comprar via MetaMask</button>
    <button id="copyReceiptBtn" style="margin-top:8px;background:#10b981">Copiar recibo</button>
    <button id="verifyBtn" style="margin-top:8px;background:#6b7280">Verificar contrato</button>

    <div id="msg" class="msg" style="display:none"></div>
    <div id="out" class="status"></div>
    <div class="muted" style="margin-top:6px">Com contrato de venda: o pagamento e a entrega de tokens são automatizados on-chain.</div>
    <div id="verifyOut" class="status"></div>
  </div>

  <script>
    // =============================
    // Configuração Interna (edite aqui)
    // =============================
    const CONFIG = {
      chainIdHex: '0x61', // BSC Testnet (97)
      readRpc: 'https://bsc-testnet.publicnode.com',
      destinationWallet: '0xEe02E32d8d2888E9f1D6d13391E716Bc7F41f6Ae', // carteira recebedora
      saleTokenContract: '0x2cf724171a998C3d470048AC2F1b187a48A5cafE', // contrato do token comprado (referência)
      paymentTarget: 'contract', // com contrato de venda: usar 'contract' para chamar o método de compra
      // Configuração do contrato de venda:
      saleContractAddress: '0x822Def5c0d5fAD70faCcA3fe040DA3329F1f9b9d', // SUBSTITUA PELO ENDEREÇO DO CONTRATO IMPLANTADO
      saleAbi: [
        "function buy(uint256 quantity) payable",
        "function buyWithUSDT(uint256 quantity)"
      ],
      saleMethod: 'buy', // método de compra padrão (BNB)
      saleParams: ['$quantity'], // parâmetros do método de compra, sem incluir o { value }
      bscscanApiKey: '', // opcional: API key do BscScan Testnet para auto-busca de ABI
      currencies: ['TBNB', 'USDT'],
      prices: { // preço por token por moeda
        TBNB: '0.001',
        USDT: '0.25'
      },
      usdtContract: '0x0000000000000000000000000000000000000000', // contrato USDT (BEP20) — configure se usar USDT
      quantities: [100, 500, 1000],
      defaultCurrency: 'TBNB',
      defaultQuantity: 100,
    };

    const erc20Abi = [
      'function transfer(address to, uint256 amount) returns (bool)',
      'function decimals() view returns (uint8)'
    ];

    const els = {
      currency: document.getElementById('currency'),
      quantity: document.getElementById('quantity'),
      totalInfo: document.getElementById('totalInfo'),
      buyBtn: document.getElementById('buyBtn'),
      copyReceiptBtn: document.getElementById('copyReceiptBtn'),
      verifyBtn: document.getElementById('verifyBtn'),
      msg: document.getElementById('msg'),
      out: document.getElementById('out'),
      verifyOut: document.getElementById('verifyOut'),
    };

    function showMessage(text, ok = true) {
      els.msg.style.display = 'block';
      els.msg.className = 'msg ' + (ok ? 'success' : 'error');
      els.msg.textContent = text;
    }

    function formatAmountBNB(bn) { return ethers.utils.formatEther(bn) + ' TBNB'; }
    function formatAmountUSDT(bn, decimals) { return ethers.utils.formatUnits(bn, decimals) + ' USDT'; }

    function getQuantity() { return parseInt(els.quantity.value, 10) || 0; }

    async function ensureChain(provider) {
      const net = await provider.getNetwork();
      const current = '0x' + net.chainId.toString(16);
      if (current !== CONFIG.chainIdHex) {
        await window.ethereum.request({
          method: 'wallet_switchEthereumChain',
          params: [{ chainId: CONFIG.chainIdHex }]
        });
      }
    }

    async function calculateTotal() {
      const currency = els.currency.value;
      const qty = getQuantity();
      if (!qty) { els.totalInfo.textContent = 'Total: informe quantidade.'; return; }
      try {
        if (currency === 'TBNB') {
          const priceWei = ethers.utils.parseEther(String(CONFIG.prices.TBNB || '0'));
          const total = priceWei.mul(ethers.BigNumber.from(qty));
          els.totalInfo.textContent = 'Total: ' + formatAmountBNB(total);
        } else {
          const readProvider = new ethers.providers.JsonRpcProvider(CONFIG.readRpc);
          const usdt = new ethers.Contract(CONFIG.usdtContract, erc20Abi, readProvider);
          let decimals = 6; try { decimals = await usdt.decimals(); } catch {}
          const priceUnits = ethers.utils.parseUnits(String(CONFIG.prices.USDT || '0'), decimals);
          const total = priceUnits.mul(ethers.BigNumber.from(qty));
          els.totalInfo.textContent = 'Total: ' + formatAmountUSDT(total, decimals);
        }
      } catch (e) {
        els.totalInfo.textContent = 'Total: inválido.';
      }
    }

    async function buy() {
      try {
        if (!window.ethereum) { showMessage('MetaMask não detectada.', false); return; }
        const provider = new ethers.providers.Web3Provider(window.ethereum);
        await window.ethereum.request({ method: 'eth_requestAccounts' });
        await ensureChain(provider);
        const signer = provider.getSigner();
        const user = await signer.getAddress();

        const currency = els.currency.value;
        const qty = getQuantity();
        if (!qty) { showMessage('Informe a quantidade.', false); return; }
        if (!CONFIG.destinationWallet || CONFIG.destinationWallet === '0x0000000000000000000000000000000000000000') {
          showMessage('Configure a carteira de destino no arquivo.', false);
          return;
        }

        if (currency === 'TBNB') {
          const priceWei = ethers.utils.parseEther(String(CONFIG.prices.TBNB || '0'));
          const total = priceWei.mul(ethers.BigNumber.from(qty));
          const gasPrice = await provider.getGasPrice();
          const gasLimit = ethers.BigNumber.from(21000);
          const balance = await provider.getBalance(user);
          const need = total.add(gasPrice.mul(gasLimit));
          if (balance.lt(need)) {
            showMessage('Saldo insuficiente. Necessário ' + ethers.utils.formatEther(need) + ' TBNB; saldo ' + ethers.utils.formatEther(balance) + ' TBNB.', false);
            return;
          }
          // alvo de pagamento: contrato (compra direta) ou carteira
          const target = (CONFIG.paymentTarget === 'contract') ? CONFIG.saleContractAddress : CONFIG.destinationWallet;
          if (!target || target === '0x0000000000000000000000000000000000000000') {
            showMessage('Configure o alvo de pagamento (contrato/carteira) no arquivo.', false);
            return;
          }
          // se for contrato, garantir que é um endereço de contrato
          if (CONFIG.paymentTarget === 'contract') {
            const code = await provider.getCode(target);
            if (!code || code === '0x') {
              showMessage('Endereço configurado não é um contrato. Ajuste saleContractAddress.', false);
              return;
            }
            // Se houver configuração de método/ABI de compra, chamar diretamente o método com value
            const hasSaleCall = Array.isArray(CONFIG.saleAbi) && CONFIG.saleAbi.length > 0 && !!CONFIG.saleMethod;
            
            // Chamar o contrato de venda com o método configurado
            if (hasSaleCall) {
              try {
                const saleContract = new ethers.Contract(target, CONFIG.saleAbi, signer);
                
                // Preparar parâmetros substituindo placeholders
                const params = (CONFIG.saleParams || []).map(p => {
                  if (p === '$buyer') return user;
                  if (p === '$quantity') return qty;
                  return p;
                });
                
                // Chamar o método de compra com value
                const tx = await saleContract[CONFIG.saleMethod](...params, { value: total });
                els.out.textContent = 'Comprando tokens via contrato...';
                const receipt = await tx.wait();
                
                // Registrar dados da compra para recibo
                window.__lastPurchase = {
                  buyer: user,
                  quantity: qty,
                  total: ethers.utils.formatEther(total),
                  currency: 'TBNB',
                  txHash: receipt.transactionHash
                };
                
                showMessage('Compra realizada com sucesso! Tokens enviados automaticamente.', true);
                els.out.textContent = 'Comprador: ' + user + '\nTx: ' + receipt.transactionHash + '\nQuant.: ' + qty + '\nTotal: ' + ethers.utils.formatEther(total) + ' TBNB';
                
                if (els.copyReceiptBtn) {
                  els.copyReceiptBtn.style.display = 'inline-block';
                }
                
                return;
              } catch (e) {
                showMessage('Erro na compra via contrato: ' + e.message, false);
                return;
              }
            }
            
            // Tentar auto-configurar a chamada de compra via ABI no BscScan Testnet quando não configurado
            async function tryAutoFetchSaleAbi(addr) {
              try {
                const apiKey = CONFIG.bscscanApiKey ? '&apikey=' + encodeURIComponent(CONFIG.bscscanApiKey) : '';
                const url = 'https://api-testnet.bscscan.com/api?module=contract&action=getabi&address=' + addr + apiKey;
                const res = await fetch(url);
                const json = await res.json();
                if (!json || json.status !== '1') return false;
                const abi = JSON.parse(json.result);
                if (!Array.isArray(abi)) return false;
                // procurar por métodos comuns pagáveis
                const candidates = ['buy', 'buyTokens', 'purchase', 'mint', 'buyFor'];
                let picked = null;
                for (const name of candidates) {
                  const item = abi.find(x => x.type === 'function' && x.name === name && (x.stateMutability === 'payable' || x.payable === true));
                  if (item) { picked = item; break; }
                }
                if (!picked) return false;
                // montar ABI mínimo do método escolhido
                CONFIG.saleAbi = [picked];
                CONFIG.saleMethod = picked.name;
                // parâmetros dinâmicos: se exigir address, usar '$buyer'; se exigir uint256, usar '$qty'
                CONFIG.saleParams = (picked.inputs || []).map(inp => {
                  if (inp.type === 'address') return '$buyer';
                  if (inp.type === 'uint256' || inp.type === 'uint') return '$qty';
                  return '';
                }).filter(x => x !== '');
                return true;
              } catch (_) {
                return false;
              }
            }
            let effectiveHasSaleCall = hasSaleCall;
            if (!effectiveHasSaleCall) {
              const autoOk = await tryAutoFetchSaleAbi(target);
              effectiveHasSaleCall = autoOk && Array.isArray(CONFIG.saleAbi) && CONFIG.saleAbi.length > 0 && !!CONFIG.saleMethod;
            }
            if (effectiveHasSaleCall) {
              try {
                const sale = new ethers.Contract(target, CONFIG.saleAbi, signer);
                showMessage('Chamando método de compra no contrato...');
                const dynamicParams = (CONFIG.saleParams || []).map(p => {
                  if (p === '$buyer') return user;
                  if (p === '$qty') return ethers.BigNumber.from(qty);
                  return p;
                });
                const tx = await sale[CONFIG.saleMethod](...dynamicParams, { value: total, gasPrice });
                await tx.wait();
                showMessage('Compra realizada no contrato. Tokens devem ser creditados ao comprador.', true);
                els.out.textContent = 'Tx: ' + tx.hash + '\nTotal: ' + ethers.utils.formatEther(total) + ' TBNB';
                return;
              } catch (err) {
                showMessage('Falha ao chamar método de compra: ' + (err && err.message ? err.message : 'erro desconhecido'), false);
                return;
              }
            } else {
              // Heurística: contratos de token (ERC20/BEP20) geralmente não aceitam TBNB diretamente
              try {
                const erc20 = new ethers.Contract(target, [
                  'function symbol() view returns (string)',
                  'function decimals() view returns (uint8)'
                ], provider);
                await erc20.decimals();
                showMessage('O endereço parece ser um contrato de token (ERC20/BEP20) e não aceita TBNB diretamente. Configure saleAbi/saleMethod para compra direta no contrato.', false);
                return;
              } catch (_) {
                // Não parece claramente um ERC20: tentar envio direto de valor para o contrato (payable receive)
              }
            }
          }
          showMessage(CONFIG.paymentTarget === 'contract' ? 'Enviando TBNB ao contrato (receive payable)...' : 'Enviando pagamento TBNB à carteira destino...');
          const tx = await signer.sendTransaction({ to: target, value: total, gasLimit, gasPrice });
          await tx.wait();
          showMessage(CONFIG.paymentTarget === 'contract' ? 'Pagamento TBNB enviado ao contrato. Tokens são entregues pelo contrato.' : 'Pagamento TBNB enviado.', true);
          els.out.textContent = 'Comprador: ' + user + '\nTx: ' + tx.hash + '\nQuant.: ' + qty + '\nTotal: ' + ethers.utils.formatEther(total) + ' TBNB';
          window.__lastPurchase = {
            buyer: user,
            qty,
            currency: 'TBNB',
            totalWei: total.toString(),
            totalFormatted: ethers.utils.formatEther(total),
            txHash: tx.hash,
            timestamp: Date.now()
          };
        } else {
          if (!CONFIG.usdtContract || CONFIG.usdtContract === '0x0000000000000000000000000000000000000000') {
            showMessage('Configure o contrato USDT no arquivo.', false);
            return;
          }
          const readProvider = new ethers.providers.JsonRpcProvider(CONFIG.readRpc);
          const usdtRead = new ethers.Contract(CONFIG.usdtContract, erc20Abi, readProvider);
          let decimals = 6; try { decimals = await usdtRead.decimals(); } catch {}
          const priceUnits = ethers.utils.parseUnits(String(CONFIG.prices.USDT || '0'), decimals);
          const totalUnits = priceUnits.mul(ethers.BigNumber.from(qty));
          const usdt = new ethers.Contract(CONFIG.usdtContract, erc20Abi, signer);
          
          // Verificar se é para usar o contrato de venda
          if (CONFIG.paymentTarget === 'contract' && CONFIG.saleContractAddress && CONFIG.saleContractAddress !== '0x0000000000000000000000000000000000000000') {
            try {
              // Aprovar USDT para o contrato de venda
              showMessage('Aprovando USDT para o contrato de venda...');
              let approveGasLimit; try { approveGasLimit = await usdt.estimateGas.approve(CONFIG.saleContractAddress, totalUnits); } catch { approveGasLimit = ethers.BigNumber.from(70000); }
              const approveTx = await usdt.approve(CONFIG.saleContractAddress, totalUnits, { gasLimit: approveGasLimit });
              await approveTx.wait();
              
              // Chamar método de compra com USDT
              showMessage('Comprando tokens via contrato...');
              const saleContract = new ethers.Contract(CONFIG.saleContractAddress, CONFIG.saleAbi, signer);
              const buyTx = await saleContract.buyWithUSDT(qty);
              const receipt = await buyTx.wait();
              
              showMessage('Compra com USDT realizada via contrato!', true);
              els.out.textContent = 'Comprador: ' + user + '\nTx: ' + buyTx.hash + '\nQuant.: ' + qty + '\nTotal: ' + ethers.utils.formatUnits(totalUnits, decimals) + ' USDT';
              window.__lastPurchase = {
                buyer: user,
                qty,
                currency: 'USDT',
                totalUnits: totalUnits.toString(),
                usdtDecimals: decimals,
                totalFormatted: ethers.utils.formatUnits(totalUnits, decimals),
                txHash: buyTx.hash,
                timestamp: Date.now()
              };
              return;
            } catch (e) {
              showMessage('Erro na compra com USDT via contrato: ' + (e?.message || String(e)), false);
              return;
            }
          }
          
          // Transferência direta de USDT
          showMessage('Enviando pagamento USDT...');
          let gasLimit; try { gasLimit = await usdt.estimateGas.transfer(CONFIG.destinationWallet, totalUnits); } catch { gasLimit = ethers.BigNumber.from(70000); }
          const tx = await usdt.transfer(CONFIG.destinationWallet, totalUnits, { gasLimit });
          await tx.wait();
          showMessage('Pagamento USDT enviado.', true);
          els.out.textContent = 'Comprador: ' + user + '\nTx: ' + tx.hash + '\nQuant.: ' + qty + '\nTotal: ' + ethers.utils.formatUnits(totalUnits, decimals) + ' USDT';
          window.__lastPurchase = {
            buyer: user,
            qty,
            currency: 'USDT',
            totalUnits: totalUnits.toString(),
            usdtDecimals: decimals,
            totalFormatted: ethers.utils.formatUnits(totalUnits, decimals),
            txHash: tx.hash,
            timestamp: Date.now()
          };
        }
      } catch (e) {
        console.error(e);
        showMessage('Erro: ' + (e?.message || String(e)), false);
      }
    }

    async function copyReceipt() {
      try {
        const r = window.__lastPurchase;
        if (!r) { showMessage('Nenhum recibo disponível ainda.', false); return; }
        const receipt = JSON.stringify(r, null, 2);
        await navigator.clipboard.writeText(receipt);
        showMessage('Recibo copiado para a área de transferência.', true);
        els.out.textContent = receipt;
      } catch (e) {
        showMessage('Falha ao copiar recibo: ' + (e?.message || String(e)), false);
      }
    }

    // Verificação do contrato: tenta identificar BEP20 e funções pagáveis (via BscScan)
    async function verifyContract() {
      try {
        els.verifyOut.textContent = '';
        const provider = new ethers.providers.JsonRpcProvider(CONFIG.readRpc);
        const addr = CONFIG.saleTokenContract;
        if (!addr || addr === '0x0000000000000000000000000000000000000000') {
          showMessage('Configure o endereço do contrato de venda (saleTokenContract).', false);
          return;
        }
        const code = await provider.getCode(addr);
        if (!code || code === '0x') {
          showMessage('O endereço informado não é um contrato.', false);
          els.verifyOut.textContent = 'Endereço: ' + addr + '\nTipo: Externally Owned Account (EOA)';
          return;
        }

        // Tenta ler informações BEP20/ERC20
        let isToken = false;
        let name = '', symbol = '', decimals = null, totalSupply = null;
        try {
          const token = new ethers.Contract(addr, [
            'function name() view returns (string)',
            'function symbol() view returns (string)',
            'function decimals() view returns (uint8)',
            'function totalSupply() view returns (uint256)'
          ], provider);
          name = await token.name();
          symbol = await token.symbol();
          decimals = await token.decimals();
          totalSupply = await token.totalSupply();
          isToken = true;
        } catch (_) {
          // pode não ser um token padrão
        }

        // Busca ABI na BscScan (testnet) se houver API key
        let abiInfo = null;
        let candidates = [];
        if (CONFIG.bscscanApiKey) {
          try {
            const abi = await fetchAbiFromBscScan(addr);
            abiInfo = abi;
            const commonBuyNames = ['buy','buyTokens','purchase','mint','buyFor','contribute'];
            candidates = abi.filter(i => i.type === 'function' && i.stateMutability === 'payable' && commonBuyNames.includes(i.name));
          } catch (e) {
            console.warn('Falha ao obter ABI:', e);
          }
        }

        const lines = [];
        lines.push('Contrato: ' + addr);
        lines.push('É contrato: sim');
        if (isToken) {
          lines.push('Tipo: BEP20/ERC20 Token');
          if (name) lines.push('Nome: ' + name);
          if (symbol) lines.push('Símbolo: ' + symbol);
          if (decimals !== null) lines.push('Decimais: ' + decimals);
          if (totalSupply) lines.push('Total Supply: ' + ethers.utils.formatUnits(totalSupply, decimals || 18));
          lines.push('Observação: contratos de token geralmente NÃO aceitam TBNB diretamente.');
        } else {
          lines.push('Não parece expor interface BEP20 padrão.');
        }
        if (abiInfo) {
          const payableNames = abiInfo.filter(i => i.type === 'function' && i.stateMutability === 'payable').map(i => i.name);
          lines.push('Funções pagáveis detectadas: ' + (payableNames.length ? payableNames.join(', ') : 'nenhuma'));
          if (candidates.length) {
            const c = candidates[0];
            lines.push('Possível método de compra: ' + c.name + '(' + c.inputs.map(i => i.type).join(', ') + ')');
            lines.push('Dica: se este for o contrato de VENDA, configure saleAbi e saleMethod com este ABI.');
          } else {
            lines.push('Nenhuma função de compra pagável comum encontrada neste contrato.');
          }
        } else {
          lines.push('ABI não obtida (configure bscscanApiKey para auto-verificação).');
        }
        els.verifyOut.textContent = lines.join('\n');
      } catch (e) {
        console.error(e);
        showMessage('Erro ao verificar contrato: ' + (e?.message || String(e)), false);
      }
    }

    async function fetchAbiFromBscScan(address) {
      const base = 'https://api-testnet.bscscan.com/api';
      const url = `${base}?module=contract&action=getabi&address=${address}&apikey=${CONFIG.bscscanApiKey}`;
      const res = await fetch(url);
      const json = await res.json();
      if (json.status !== '1' || !json.result) throw new Error('Falha ao obter ABI: ' + (json.message || 'erro'));
      return JSON.parse(json.result);
    }

    // Inicialização simples
    (function init() {
      // popular selects
      els.currency.innerHTML = CONFIG.currencies.map(c => `<option value="${c}">${c}</option>`).join('');
      els.quantity.innerHTML = CONFIG.quantities.map(q => `<option value="${q}">${q}</option>`).join('');
      els.currency.value = CONFIG.defaultCurrency || CONFIG.currencies[0];
      els.quantity.value = String(CONFIG.defaultQuantity || CONFIG.quantities[0]);
      calculateTotal();
      els.currency.addEventListener('change', calculateTotal);
      els.quantity.addEventListener('change', calculateTotal);
      els.buyBtn.addEventListener('click', buy);
      els.copyReceiptBtn && els.copyReceiptBtn.addEventListener('click', copyReceipt);
      els.verifyBtn && els.verifyBtn.addEventListener('click', verifyContract);
    })();
  </script>
</body>
</html>
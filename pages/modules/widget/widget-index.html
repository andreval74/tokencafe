<!DOCTYPE html>
<html>
<body>
  <script>
    // Conex√£o centralizada de carteira no Widget usando WalletConnector
    async function connectWallet(provider = 'metamask') {
      try {
        if (!window.walletConnector || typeof window.walletConnector.connect !== 'function') {
          alert('Sistema de conex√£o de carteira indispon√≠vel. Atualize a p√°gina e tente novamente.');
          return;
        }
        const result = await window.walletConnector.connect(provider);
        if (!result || !result.success) {
          alert('Falha ao conectar a carteira.');
          return;
        }
        console.log('Carteira conectada:', result.account);
        const statusEl = document.getElementById('contract-validation-status');
        if (statusEl && !statusEl.innerHTML) {
          statusEl.innerHTML = '<div class="alert alert-info">‚úÖ Carteira conectada. Voc√™ pode validar e testar o contrato.</div>';
        }
      } catch (e) {
        console.error('Erro na conex√£o de carteira:', e);
        alert(e?.message || 'Falha na conex√£o. Verifique sua carteira e tente novamente.');
      }
    }

    // Vari√°veis globais
    let provider;
    const fallbackRpcs = [
      'https://data-seed-prebsc-1-s1.binance.org:8545/',  // Binance oficial testnet
      'https://data-seed-prebsc-2-s1.binance.org:8545/',  // Binance oficial testnet
      'https://bsc-testnet.public.blastapi.io',           // BlastAPI testnet
      'https://bsc-testnet-rpc.publicnode.com',           // PublicNode testnet
      'https://data-seed-prebsc-1-s2.binance.org:8545/',  // Binance backup
      'https://data-seed-prebsc-2-s2.binance.org:8545/',  // Binance backup
      'https://bsc-testnet.blockpi.network/v1/rpc/public', // BlockPI testnet
      'https://endpoints.omniatech.io/v1/bsc/testnet/public' // OmniaTech testnet
    ];

    // Fun√ß√£o para verificar se endere√ßo √© v√°lido
    function isValidEthereumAddress(address) {
      return /^0x[a-fA-F0-9]{40}$/.test(address);
    }

    // Fun√ß√£o para inicializar provider
    async function initializeProvider(useMetaMask = true) {
      if (!window.ethereum || metamaskBlacklisted) {
        return false;
      }
      
      try {
        // Usar 'any' para evitar falhas de detec√ß√£o de rede
        const provider = new ethers.providers.Web3Provider(window.ethereum, 'any');
        
        // Teste rigoroso: usar exatamente a mesma opera√ß√£o que est√° falhando
        // Usar endere√ßo de contrato BSC TESTNET conhecido (PancakeSwap Router Testnet)
        const testContractAddress = '0xD99D1c33F9fC3444f8101754aBC46c52416550D1';
        
        // Criar promise com timeout de 3 segundos
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Timeout: MetaMask n√£o respondeu em 3 segundos')), 3000);
        });
        
        // Testar getCode() com timeout - exatamente a opera√ß√£o que est√° falhando
        const codePromise = provider.getCode(testContractAddress);
        
        await Promise.race([codePromise, timeoutPromise]);
        
        console.log('‚úÖ MetaMask passou no teste rigoroso de getCode()');
        return true;
      } catch (error) {
        console.warn('‚ùå MetaMask falhou no teste rigoroso:', error.message);
        
        // Blacklist imediata para qualquer erro relacionado a RPC
        if (error.message.includes('Internal JSON-RPC error') || 
            error.message.includes('Timeout') ||
            error.message.includes('missing trie node') ||
            error.code === -32603 ||
            error.code === -32002) {
          metamaskBlacklisted = true;
          console.warn('üö´ MetaMask foi adicionado √† blacklist devido a problemas de RPC detectados no teste rigoroso');
        }
        return false;
      }
    }

    // Fun√ß√£o auxiliar para criar providers alternativos
    async function getAlternativeProviders(skipMetaMask = false) {
      const providers = [];
      
      // Testar MetaMask primeiro antes de adicionar √† lista (a menos que seja ignorado)
      let metamaskWorking = false;
      if (!skipMetaMask) {
        metamaskWorking = await testMetaMaskHealth();
      }
      
      if (metamaskWorking) {
        console.log('MetaMask est√° funcionando, adicionando √† lista de providers');
        providers.push(new ethers.providers.Web3Provider(window.ethereum));
      } else {
        console.log(skipMetaMask ? 'Ignorando MetaMask por escolha, usando RPCs p√∫blicos' : 'MetaMask n√£o est√° dispon√≠vel ou com problemas, usando apenas RPCs p√∫blicos');
        
        // Mostrar feedback imediato para o usu√°rio
        const statusEl = document.getElementById('contract-validation-status');
        if (statusEl) {
          if (skipMetaMask) {
            statusEl.innerHTML = '<div class="alert alert-info">üîÑ Validando usando RPCs p√∫blicos da BSC Testnet (ignorando MetaMask).</div>';
          } else if (!statusEl.innerHTML.includes('MetaMask indispon√≠vel')) {
            statusEl.innerHTML = '<div class="alert alert-warning">‚ö†Ô∏è MetaMask indispon√≠vel. Usando RPCs p√∫blicos BSC...</div>';
          }
        }
      }
      
      // Melhores RPCs BSC TESTNET de 2024 (ordenados por performance)
      const bscRPCs = [
        'https://data-seed-prebsc-1-s1.binance.org:8545/',  // Binance oficial testnet
        'https://data-seed-prebsc-2-s1.binance.org:8545/',  // Binance oficial testnet
        'https://bsc-testnet.public.blastapi.io',           // BlastAPI testnet
        'https://bsc-testnet-rpc.publicnode.com',           // PublicNode testnet
        'https://data-seed-prebsc-1-s2.binance.org:8545/',  // Binance backup
        'https://data-seed-prebsc-2-s2.binance.org:8545/',  // Binance backup
        'https://bsc-testnet.blockpi.network/v1/rpc/public', // BlockPI testnet
        'https://endpoints.omniatech.io/v1/bsc/testnet/public' // OmniaTech testnet
      ];
      
      bscRPCs.forEach(rpc => {
        try {
          // SOLU√á√ÉO RADICAL: Provider com configura√ß√£o est√°tica completa da BSC TESTNET
          // N√£o permite detec√ß√£o autom√°tica de rede para evitar "could not detect network"
          const networkConfig = {
            name: "bsc-testnet",
            chainId: 97,
            ensAddress: null,
            _defaultProvider: null
          };
          
          const provider = new ethers.providers.StaticJsonRpcProvider(rpc, networkConfig);
          
          // For√ßar configura√ß√£o est√°tica para evitar detec√ß√£o autom√°tica
          provider._network = networkConfig;
          provider.detectNetwork = () => Promise.resolve(networkConfig);
          
          providers.push(provider);
        } catch (e) {
          console.warn(`Falha ao criar provider para ${rpc}:`, e);
        }
      });
      
      return providers;
    }
    
    // Fun√ß√£o auxiliar SIMPLIFICADA para retry com diferentes providers
    // FALLBACK DIRETO sem valida√ß√µes que causam problemas
    async function retryWithProviders(operation, maxRetries = 8, skipMetaMask = false) {
      const providers = await getAlternativeProviders(skipMetaMask); // Agora √© async
      let lastError;
      const backoffBaseMs = 300; // backoff exponencial leve
      
      if (providers.length === 0) {
        throw new Error('Nenhum provider dispon√≠vel');
      }
      
      for (let i = 0; i < providers.length && i < maxRetries; i++) {
        try {
          const isMetaMask = providers[i] instanceof ethers.providers.Web3Provider;
          const providerName = isMetaMask ? 'MetaMask' : `RPC BSC ${i + 1}`;
          
          console.log(`Tentativa ${i + 1} com provider ${providerName}`);
          
          // SOLU√á√ÉO RADICAL: Executar opera√ß√£o diretamente sem valida√ß√µes pr√©vias
          return await operation(providers[i]);
        } catch (error) {
          lastError = error;
          console.warn(`Tentativa ${i + 1} falhou:`, error.message);
          
          // FALLBACK DIRETO: Qualquer erro, passa para o pr√≥ximo provider
          // N√£o fazer distin√ß√£o de tipos de erro para evitar complica√ß√µes
          console.log(`üîÑ Passando para pr√≥ximo provider...`);
          // Backoff leve antes da pr√≥xima tentativa
          const delay = Math.min(backoffBaseMs * (i + 1), 2000);
          await new Promise(resolve => setTimeout(resolve, delay));
          continue;
        }
      }
      
      throw lastError;
    }
    
    // Fun√ß√£o melhorada para verificar se contrato existe com fallback
    async function checkContractExists(address, description = 'contrato') {
      console.log(`üîç [checkContractExists] Verificando exist√™ncia de ${description}: ${address}`);
      
      if (!address || !isValidEthereumAddress(address)) {
        console.warn(`‚ö†Ô∏è [checkContractExists] Endere√ßo inv√°lido para ${description}`);
        return false;
      }

      let normalizedAddress;
      try {
        normalizedAddress = ethers.utils.getAddress(address);
      } catch (err) {
        console.warn(`‚ö†Ô∏è [checkContractExists] Erro na normaliza√ß√£o de ${description}: ${err.message}`);
        return false;
      }

      // Tenta com provider atual (MetaMask)
      if (provider) {
        try {
          const code = await provider.getCode(normalizedAddress);
          const exists = code !== '0x';
          console.log(`‚úÖ [checkContractExists] ${description} via MetaMask: ${exists ? 'existe' : 'n√£o existe'}`);
          return exists;
        } catch (error) {
          console.warn(`‚ùå [checkContractExists] Erro via MetaMask para ${description}: ${error.message}`);
        }
      }

      // Fallback para RPCs diretos
      for (const rpcUrl of fallbackRpcs) {
        try {
          const fallbackProvider = new ethers.providers.JsonRpcProvider(rpcUrl);
          const code = await fallbackProvider.getCode(normalizedAddress);
          const exists = code !== '0x';
          console.log(`‚úÖ [checkContractExists] ${description} via RPC ${rpcUrl}: ${exists ? 'existe' : 'n√£o existe'}`);
          return exists;
        } catch (error) {
          console.warn(`‚ùå [checkContractExists] Erro via RPC ${rpcUrl} para ${description}: ${error.message}`);
          continue;
        }
      }

      console.error(`‚ùå [checkContractExists] Falha total ao verificar ${description}`);
      return false;
    }

    // Fun√ß√£o para verificar se uma fun√ß√£o existe no contrato
    async function checkContractFunction(contractAddress, functionSignature, description = 'fun√ß√£o') {
      console.log(`üîß [checkContractFunction] Verificando ${description} no contrato: ${contractAddress}`);
      
      if (!contractAddress || !isValidEthereumAddress(contractAddress)) {
        console.warn(`‚ö†Ô∏è [checkContractFunction] Endere√ßo de contrato inv√°lido para ${description}`);
        return false;
      }

      let normalizedAddress;
      try {
        normalizedAddress = ethers.utils.getAddress(contractAddress);
      } catch (err) {
        console.warn(`‚ö†Ô∏è [checkContractFunction] Erro na normaliza√ß√£o para ${description}: ${err.message}`);
        return false;
      }

      const testABI = [functionSignature];

      // Tenta com provider atual (MetaMask)
      if (provider) {
        try {
          const contract = new ethers.Contract(normalizedAddress, testABI, provider);
          const functionName = functionSignature.split('(')[0].replace('function ', '');
          
          // Tenta chamar a fun√ß√£o (se for view/pure)
          if (functionSignature.includes('view') || functionSignature.includes('pure')) {
            await contract[functionName]();
          }
          
          console.log(`‚úÖ [checkContractFunction] ${description} existe via MetaMask`);
          return true;
        } catch (error) {
          // Se o erro n√£o for sobre fun√ß√£o inexistente, pode ser outro problema
          if (!error.message.includes('function') && !error.message.includes('method')) {
            console.log(`‚úÖ [checkContractFunction] ${description} provavelmente existe (erro de execu√ß√£o, n√£o de exist√™ncia)`);
            return true;
          }
          console.warn(`‚ùå [checkContractFunction] ${description} n√£o existe via MetaMask: ${error.message}`);
        }
      }

      // Fallback para RPCs diretos
      for (const rpcUrl of fallbackRpcs) {
        try {
          const fallbackProvider = new ethers.providers.JsonRpcProvider(rpcUrl);
          const contract = new ethers.Contract(normalizedAddress, testABI, fallbackProvider);
          const functionName = functionSignature.split('(')[0].replace('function ', '');
          
          if (functionSignature.includes('view') || functionSignature.includes('pure')) {
            await contract[functionName]();
          }
          
          console.log(`‚úÖ [checkContractFunction] ${description} existe via RPC ${rpcUrl}`);
          return true;
        } catch (error) {
          if (!error.message.includes('function') && !error.message.includes('method')) {
            console.log(`‚úÖ [checkContractFunction] ${description} provavelmente existe via RPC ${rpcUrl}`);
            return true;
          }
          console.warn(`‚ùå [checkContractFunction] ${description} n√£o existe via RPC ${rpcUrl}: ${error.message}`);
          continue;
        }
      }

      console.error(`‚ùå [checkContractFunction] Falha total ao verificar ${description}`);
      return false;
    }

    async function detectContractInformation() {
      console.log('üîç [detectContractInformation] Iniciando detec√ß√£o de informa√ß√µes do contrato');
      
      try {
        const contractAddressEl = document.getElementById('deployedContractAddress');
        const tokenAddressEl = document.getElementById('contractTokenAddress');
        
        if (!contractAddressEl || !tokenAddressEl) {
          const errorMsg = 'Campos de endere√ßo n√£o encontrados na UI';
          console.error(`‚ùå [detectContractInformation] ${errorMsg}`);
          alert(errorMsg);
          return;
        }
        
        const contractAddress = contractAddressEl.value.trim();
        const tokenAddress = tokenAddressEl.value.trim();
        
        if (!contractAddress) {
          const errorMsg = 'Por favor, informe o endere√ßo do contrato de venda deployado';
          console.warn(`‚ö†Ô∏è [detectContractInformation] ${errorMsg}`);
          alert(errorMsg);
          return;
        }
        
        // Validar formato dos endere√ßos
        if (!isValidEthereumAddress(contractAddress)) {
          const errorMsg = 'Endere√ßo do contrato inv√°lido';
          console.error(`‚ùå [detectContractInformation] ${errorMsg}: ${contractAddress}`);
          alert(errorMsg);
          return;
        }
        
        // Inicializar provider (MetaMask se dispon√≠vel, sen√£o RPC p√∫blico)
        if (!provider) {
          console.log('üîó [detectContractInformation] Provider n√£o inicializado, tentando inicializar...');
          await initializeProvider(true).catch(err => console.warn(`‚ö†Ô∏è [detectContractInformation] Falha ao inicializar provider: ${err.message}`));
          if (!provider) {
            console.log('üîÑ [detectContractInformation] Tentando fallback para RPC p√∫blico...');
            await initializeProvider(false).catch(err => console.error(`‚ùå [detectContractInformation] Fallback de provider falhou: ${err.message}`));
          }
          if (!provider) {
            throw new Error('N√£o foi poss√≠vel inicializar nenhum provider');
          }
        }
        
        // Mostrar status de carregamento
        const statusEl = document.getElementById('contract-validation-status');
        if (statusEl) {
          statusEl.innerHTML = '<div class="alert alert-info">üîç Verificando exist√™ncia do contrato...</div>';
        }
        
        // Verificar se o contrato existe com fun√ß√£o melhorada
        console.log('üîç [detectContractInformation] Verificando exist√™ncia do contrato...');
        const contractExists = await checkContractExists(contractAddress, 'contrato de venda');
        
        if (!contractExists) {
          const errorMsg = 'Contrato n√£o encontrado no endere√ßo informado. Verifique se o endere√ßo est√° correto e se o contrato foi deployado.';
          console.error(`‚ùå [detectContractInformation] ${errorMsg}`);
          if (statusEl) {
            statusEl.innerHTML = `<div class="alert alert-danger">‚ùå ${errorMsg}</div>`;
          }
          return;
        }
        
        console.log('‚úÖ [detectContractInformation] Contrato existe, prosseguindo com detec√ß√£o...');
        if (statusEl) {
          statusEl.innerHTML = '<div class="alert alert-info">üîç Detectando informa√ß√µes do contrato...</div>';
        }
        
        // Se n√£o tiver endere√ßo do token, tentar detectar automaticamente
        if (!tokenAddress) {
          try {
            const detectedTokenAddress = await retryWithProviders(async (currentProvider) => {
              // Tentar m√∫ltiplas assinaturas comuns para endere√ßo de token
              try {
                const cSaleToken = new ethers.Contract(contractAddress, ["function saleToken() view returns (address)"], currentProvider);
                return await cSaleToken.saleToken();
              } catch (_) {
                try {
                  const cToken = new ethers.Contract(contractAddress, ["function token() view returns (address)"], currentProvider);
                  return await cToken.token();
                } catch (_) {
                  try {
                    const cTokenAddr = new ethers.Contract(contractAddress, ["function tokenAddress() view returns (address)"], currentProvider);
                    return await cTokenAddr.tokenAddress();
                  } catch (_) {
                    try {
                      const cPaymentToken = new ethers.Contract(contractAddress, ["function paymentToken() view returns (address)"], currentProvider);
                      return await cPaymentToken.paymentToken();
                    } catch (_) {
                      const cGetToken = new ethers.Contract(contractAddress, ["function getToken() view returns (address)"], currentProvider);
                      return await cGetToken.getToken();
                    }
                  }
                }
              }
            }, 8, true);
            
            if (detectedTokenAddress && detectedTokenAddress !== '0x0000000000000000000000000000000000000000') {
              tokenAddressEl.value = detectedTokenAddress;
              
              if (statusEl) {
                statusEl.innerHTML = '<div class="alert alert-info">üîç Detectando informa√ß√µes do token...</div>';
              }
              
              // Detectar informa√ß√µes do token automaticamente com retry
              const tokenInfo = await retryWithProviders(async (currentProvider) => {
                const tokenContract = new ethers.Contract(detectedTokenAddress, [
                  "function name() view returns (string)",
                  "function symbol() view returns (string)",
                  "function decimals() view returns (uint8)"
                ], currentProvider);
                
                const [name, symbol, decimals] = await Promise.all([
                  tokenContract.name(),
                  tokenContract.symbol(),
                  tokenContract.decimals()
                ]);
                
                return { name, symbol, decimals };
              });
              
              if (statusEl) {
                statusEl.innerHTML = `
                  <div class="alert alert-success">
                    ‚úÖ Informa√ß√µes detectadas automaticamente:<br>
                    <strong>Token:</strong> ${tokenInfo.name} (${tokenInfo.symbol})<br>
                    <strong>Endere√ßo do Token:</strong> ${detectedTokenAddress}<br>
                    <strong>Decimais:</strong> ${tokenInfo.decimals}
                  </div>
                `;
              }
            } else {
              throw new Error('Endere√ßo do token n√£o encontrado no contrato');
            }
          } catch (error) {
            console.error('Erro ao detectar token:', error);
            if (statusEl) {
              const errorMsg = error.message.includes('missing trie node') 
                ? 'Problema tempor√°rio de sincroniza√ß√£o da rede. Tente novamente em alguns segundos.'
                : 'N√£o foi poss√≠vel detectar automaticamente o endere√ßo do token. Por favor, informe manualmente.';
              statusEl.innerHTML = `<div class="alert alert-warning">‚ö†Ô∏è ${errorMsg}</div>`;
            }
          }
        } else {
          // Se j√° tem o endere√ßo do token, apenas validar
          try {
            if (statusEl) {
              statusEl.innerHTML = '<div class="alert alert-info">üîç Validando informa√ß√µes do token...</div>';
            }
            
            const tokenInfo = await retryWithProviders(async (currentProvider) => {
              const tokenContract = new ethers.Contract(tokenAddress, [
                "function name() view returns (string)",
                "function symbol() view returns (string)",
                "function decimals() view returns (uint8)"
              ], currentProvider);
              
              const [name, symbol, decimals] = await Promise.all([
                tokenContract.name(),
                tokenContract.symbol(),
                tokenContract.decimals()
              ]);
              
              return { name, symbol, decimals };
            });
            
            if (statusEl) {
              statusEl.innerHTML = `
                <div class="alert alert-success">
                  ‚úÖ Token validado:<br>
                  <strong>Nome:</strong> ${tokenInfo.name} (${tokenInfo.symbol})<br>
                  <strong>Decimais:</strong> ${tokenInfo.decimals}
                </div>
              `;
            }
          } catch (error) {
            console.error('Erro ao validar token:', error);
            if (statusEl) {
              const errorMsg = error.message.includes('missing trie node') 
                ? 'Problema tempor√°rio de sincroniza√ß√£o da rede. Tente novamente em alguns segundos.'
                : 'Erro ao validar o token. Verifique o endere√ßo.';
              statusEl.innerHTML = `<div class="alert alert-danger">‚ùå ${errorMsg}</div>`;
            }
          }
        }
        
      } catch (error) {
        console.error('Erro ao detectar informa√ß√µes do contrato:', error);
        const statusEl = document.getElementById('contract-validation-status');
        if (statusEl) {
          let errorMsg = error.message;
          if (error.message.includes('missing trie node') || error.message.includes('Internal JSON-RPC error')) {
            errorMsg = 'Problema tempor√°rio de sincroniza√ß√£o da rede. Tente novamente em alguns segundos.';
          }
          statusEl.innerHTML = `<div class="alert alert-danger">‚ùå Erro: ${errorMsg}</div>`;
        }
      }
    }
    
    // Fun√ß√£o melhorada para validar o contrato de venda
    async function validateContractFunction() {
      console.log('üîß [validateContractFunction] Iniciando valida√ß√£o do contrato');
      
      try {
        const contractAddressEl = document.getElementById('deployedContractAddress');
        const tokenAddressEl = document.getElementById('contractTokenAddress');
        
        if (!contractAddressEl || !tokenAddressEl) {
          const errorMsg = 'Campos de endere√ßo n√£o encontrados na UI';
          console.error(`‚ùå [validateContractFunction] ${errorMsg}`);
          alert(errorMsg);
          return;
        }
        
        const contractAddress = contractAddressEl.value.trim();
        const tokenAddress = tokenAddressEl.value.trim();
        
        if (!contractAddress || !tokenAddress) {
          const errorMsg = 'Por favor, informe os endere√ßos do contrato e do token';
          console.warn(`‚ö†Ô∏è [validateContractFunction] ${errorMsg}`);
          alert(errorMsg);
          return;
        }
        
        // Validar formato dos endere√ßos
        if (!isValidEthereumAddress(contractAddress)) {
          const errorMsg = 'Endere√ßo do contrato inv√°lido';
          console.error(`‚ùå [validateContractFunction] ${errorMsg}: ${contractAddress}`);
          alert(errorMsg);
          return;
        }
        
        if (!isValidEthereumAddress(tokenAddress)) {
          const errorMsg = 'Endere√ßo do token inv√°lido';
          console.error(`‚ùå [validateContractFunction] ${errorMsg}: ${tokenAddress}`);
          alert(errorMsg);
          return;
        }
        
        // N√£o obrigar conex√£o de carteira para valida√ß√£o de leitura
        if (!provider) {
          console.warn('üîó [validateContractFunction] Provider padr√£o indispon√≠vel, usando RPCs p√∫blicos para validar');
        }
        
        const statusEl = document.getElementById('contract-validation-status');
        if (statusEl) {
          statusEl.innerHTML = '<div class="alert alert-info">üîç Validando contrato...</div>';
        }
        
        // Verificar exist√™ncia do contrato primeiro
        console.log('üîç [validateContractFunction] Verificando exist√™ncia do contrato...');
        const contractExists = await checkContractExists(contractAddress, 'contrato de venda');
        
        if (!contractExists) {
          const errorMsg = 'Contrato n√£o encontrado ou sem c√≥digo na BSC Testnet (97)';
          console.error(`‚ùå [validateContractFunction] ${errorMsg}`);
          if (statusEl) {
            statusEl.innerHTML = `<div class="alert alert-danger">‚ùå ${errorMsg}</div>`;
          }
          return;
        }
        
        // Verificar exist√™ncia do token
        console.log('üîç [validateContractFunction] Verificando exist√™ncia do token...');
        const tokenExists = await checkContractExists(tokenAddress, 'token');
        
        if (!tokenExists) {
          const errorMsg = 'Token n√£o encontrado no endere√ßo informado';
          console.error(`‚ùå [validateContractFunction] ${errorMsg}`);
          if (statusEl) {
            statusEl.innerHTML = `<div class="alert alert-danger">‚ùå ${errorMsg}</div>`;
          }
          return;
        }
        
        console.log('‚úÖ [validateContractFunction] Ambos os contratos existem, validando fun√ß√µes...');
        
        // Validar informa√ß√µes do contrato usando fallback robusto
        const { contractToken, tokenPrice, owner, isPaused } = await retryWithProviders(async (currentProvider) => {

          // Resgatar endere√ßo do token: tentar v√°rias assinaturas comuns
          let ct;
          try {
            const scSaleToken = new ethers.Contract(contractAddress, ["function saleToken() view returns (address)"], currentProvider);
            ct = await scSaleToken.saleToken();
          } catch (_) {
            try {
              const scToken = new ethers.Contract(contractAddress, ["function token() view returns (address)"], currentProvider);
              ct = await scToken.token();
            } catch (_) {
              try {
                const scTokenAddr = new ethers.Contract(contractAddress, ["function tokenAddress() view returns (address)"], currentProvider);
                ct = await scTokenAddr.tokenAddress();
              } catch (_) {
                try {
                  const scPaymentToken = new ethers.Contract(contractAddress, ["function paymentToken() view returns (address)"], currentProvider);
                  ct = await scPaymentToken.paymentToken();
                } catch (_) {
                  const scGetToken = new ethers.Contract(contractAddress, ["function getToken() view returns (address)"], currentProvider);
                  ct = await scGetToken.getToken();
                }
              }
            }
          }

          // Resgatar pre√ßo (BNB) preferencialmente; fallback para tokenPrice()
          let tp;
          try {
            const scBnbPrice = new ethers.Contract(contractAddress, ["function bnbPrice() view returns (uint256)"], currentProvider);
            tp = await scBnbPrice.bnbPrice();
          } catch (_) {
            const scTokenPrice = new ethers.Contract(contractAddress, ["function tokenPrice() view returns (uint256)"], currentProvider);
            tp = await scTokenPrice.tokenPrice();
          }

          // Owner
          let ow;
          try {
            const scOwner = new ethers.Contract(contractAddress, ["function owner() view returns (address)"], currentProvider);
            ow = await scOwner.owner();
          } catch (_) {
            const scGetOwner = new ethers.Contract(contractAddress, ["function getOwner() view returns (address)"], currentProvider);
            ow = await scGetOwner.getOwner();
          }

          // Pausa (opcional). Se n√£o existir, assume false
          let ps = false;
          try {
            const scPaused = new ethers.Contract(contractAddress, ["function paused() view returns (bool)"], currentProvider);
            ps = await scPaused.paused();
          } catch (_) {
            try {
              const scIsPaused = new ethers.Contract(contractAddress, ["function isPaused() view returns (bool)"], currentProvider);
              ps = await scIsPaused.isPaused();
            } catch (_) {
              ps = false;
            }
          }

          return { contractToken: ct, tokenPrice: tp, owner: ow, isPaused: ps };
        }, 8, true);
        
        // Verificar se o token do contrato corresponde ao informado
        if (contractToken.toLowerCase() !== tokenAddress.toLowerCase()) {
          throw new Error(`Token do contrato (${contractToken}) n√£o corresponde ao informado (${tokenAddress})`);
        }
        
        // Obter informa√ß√µes do token via fallback
        const { tokenName, tokenSymbol, tokenDecimals } = await retryWithProviders(async (currentProvider) => {
          const tc = new ethers.Contract(tokenAddress, [
            "function name() view returns (string)",
            "function symbol() view returns (string)",
            "function decimals() view returns (uint8)"
          ], currentProvider);
          const [tn, ts, td] = await Promise.all([
            tc.name(),
            tc.symbol(),
            tc.decimals()
          ]);
          return { tokenName: tn, tokenSymbol: ts, tokenDecimals: td };
        }, 8, true);
        
        const priceInBNB = ethers.utils.formatEther(tokenPrice);
        
        if (statusEl) {
          statusEl.innerHTML = `
            <div class="alert alert-success">
              ‚úÖ <strong>Contrato validado com sucesso!</strong><br><br>
              <strong>Token:</strong> ${tokenName} (${tokenSymbol})<br>
              <strong>Pre√ßo:</strong> ${priceInBNB} BNB por token<br>
              <strong>Owner:</strong> ${owner}<br>
              <strong>Status:</strong> ${isPaused ? '‚è∏Ô∏è Pausado' : '‚ñ∂Ô∏è Ativo'}<br>
              <strong>Decimais:</strong> ${tokenDecimals}
            </div>
          `;
        }
        
        // Habilitar o bot√£o "Testar Sistema"
        const goToStep5Btn = document.getElementById('goToStep5');
        if (goToStep5Btn) {
          goToStep5Btn.disabled = false;
          goToStep5Btn.classList.remove('btn-secondary');
          goToStep5Btn.classList.add('btn-primary');
        }
        
      } catch (error) {
        console.error('Erro ao validar contrato:', error);
        const statusEl = document.getElementById('contract-validation-status');
        if (statusEl) {
          let msg = error && error.message ? error.message : String(error);
          if (msg.includes('Internal JSON-RPC error') || msg.includes('-32603')) {
            msg = 'Falha no RPC (MetaMask). Validando via RPCs p√∫blicos da BSC Testnet. Tente novamente.';
          } else if (msg.includes('CALL_EXCEPTION') || msg.includes('token()')) {
            msg = 'A chamada token() reverteu. Verifique se o endere√ßo √© do contrato de venda correto e se a fun√ß√£o token() existe no ABI.';
          }
          statusEl.innerHTML = `<div class="alert alert-danger">‚ùå Erro na valida√ß√£o: ${msg}</div>`;
        }
        
        // Desabilitar o bot√£o "Testar Sistema"
        const goToStep5Btn = document.getElementById('goToStep5');
        if (goToStep5Btn) {
          goToStep5Btn.disabled = true;
          goToStep5Btn.classList.remove('btn-primary');
          goToStep5Btn.classList.add('btn-secondary');
        }
      }
    }
  </script>
</body>
</html>
<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Widget de Compra de Tokens</title>
<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
<style>
body { font-family: Arial, sans-serif; background:#f5f5f5; padding:20px; }
.card { background:#fff; padding:20px; border-radius:12px; margin-bottom:20px; box-shadow:0 4px 12px rgba(0,0,0,0.1); }
h2 { margin-top:0; }
label { display:block; margin-top:10px; font-weight:bold; }
input, select, button { width:100%; padding:8px; margin-top:4px; border-radius:6px; border:1px solid #ccc; }
button { background:#0066ff; color:#fff; border:none; cursor:pointer; }
button:hover { background:#0052cc; }
pre { background:#eee; padding:10px; border-radius:8px; overflow-x:auto; }
.msg { padding:10px; border-radius:8px; margin-top:10px; font-weight:bold; }
.success { background:#d4f8d4; color:#157d17; }
.error { background:#ffd4d4; color:#b30000; }
.flex { display:flex; gap:10px; align-items:center; }
.flex input { flex:1; }
.small { font-size:0.9em; color:#555; }
</style>
</head>
<body>

<div class="card">
  <h2>Configuração da Venda</h2>
  <label>Contrato do Token (BEP20)</label>
  <input id="tokenContract" value="0x2cf724171a998C3d470048AC2F1b187a48A5cafE">

  <label>Moeda de pagamento</label>
  <select id="paymentCurrency">
    <option value="TBNB">TBNB (Testnet)</option>
    <option value="USDT">USDT BEP20</option>
  </select>

  <label>Valor do Token</label>
  <input type="number" id="tokenPrice" value="0.25" step="0.0001">

  <label>Quantidade mínima por carteira</label>
  <input type="number" id="minBuy" value="100">

  <label>Quantidade máxima por carteira</label>
  <input type="number" id="maxBuy" value="100000">

  <label>Percentual de comissão (%)</label>
  <input type="number" id="commissionPercent" value="5" step="0.1">

  <label>Carteira de comissão</label>
  <input id="commissionWallet" value="0xB4a045aF12A74e5BEb8Ff763f474B943cc2Cfa0a">

  <label>Carteira oficial (95%)</label>
  <input id="officialWallet" value="0xEe02E32d8d2888E9f1D6d13391E716Bc7F41f6Ae">

  <button id="generateWidget">Gerar Widget de Compra</button>
</div>

<div id="widgetContainer"></div>

<script>
const erc20Abi = [
  "function transfer(address to, uint256 amount) returns (bool)",
  "function decimals() view returns (uint8)",
  "function balanceOf(address) view returns (uint256)"
];

// RPC público para leituras estáveis na BSC Testnet
const READ_RPC = 'https://bsc-testnet.publicnode.com';

async function ensureBSC() {
  const provider = new ethers.providers.Web3Provider(window.ethereum);
  const { chainId } = await provider.getNetwork();
  if (chainId !== 97) {
    try {
      await window.ethereum.request({
        method: 'wallet_switchEthereumChain',
        params: [{ chainId: '0x61' }] // 97 em hex
      });
      alert('Rede trocada para BSC Testnet');
      window.location.reload();
    } catch (err) {
      alert('Por favor, selecione manualmente a BSC Testnet na MetaMask.');
      throw new Error('Rede incorreta');
    }
  }
}

function getPurchases() {
  const data = localStorage.getItem('tokenPurchases');
  return data ? JSON.parse(data) : {};
}
function savePurchase(address, amount) {
  const purchases = getPurchases();
  purchases[address] = (purchases[address] || 0) + amount;
  localStorage.setItem('tokenPurchases', JSON.stringify(purchases));
}

document.getElementById('generateWidget').addEventListener('click', async () => {
  const cfg = {
    tokenContract: document.getElementById('tokenContract').value.trim(),
    paymentCurrency: document.getElementById('paymentCurrency').value,
    tokenPrice: parseFloat(document.getElementById('tokenPrice').value),
    minBuy: parseInt(document.getElementById('minBuy').value),
    maxBuy: parseInt(document.getElementById('maxBuy').value),
    commissionPercent: parseFloat(document.getElementById('commissionPercent').value),
    commissionWallet: document.getElementById('commissionWallet').value.trim(),
    officialWallet: document.getElementById('officialWallet').value.trim()
  };

  const container = document.getElementById('widgetContainer');
  container.innerHTML = `
    <div class="card">
      <h2>Comprar Token</h2>
      <div class="flex">
        <input type="number" id="buyAmount" placeholder="100" min="${cfg.minBuy}" max="${cfg.maxBuy}">
        <span class="small" id="contractBalanceInfo">Saldo do contrato: carregando...</span>
      </div>
      <button id="buyBtn">Comprar via MetaMask</button>
      <div id="msg" class="msg" style="display:none"></div>
      <pre id="txOutput"></pre>
    </div>
  `;

  const msg = document.getElementById('msg');
  const txOut = document.getElementById('txOutput');
  const balanceInfo = document.getElementById('contractBalanceInfo');
  const buyBtn = document.getElementById('buyBtn');

  function showMessage(text, success=true) {
    msg.style.display = 'block';
    msg.className = 'msg ' + (success ? 'success' : 'error');
    msg.textContent = text;
  }

  // ✅ Garante que está na testnet BSC
  await ensureBSC();

  // === Ler saldo do contrato ===
  let tokenDecimals = 18;
  let contractBalanceTokens = 0;
  try {
    const readProvider = new ethers.providers.JsonRpcProvider(READ_RPC);
    const tokenContract = new ethers.Contract(cfg.tokenContract, erc20Abi, readProvider);

    // Verificar se o contrato existe na rede atual usando RPC público
    let code = '0x';
    try {
      code = await readProvider.getCode(cfg.tokenContract);
    } catch (e) {
      console.warn('Falha ao consultar getCode no RPC público', e);
      balanceInfo.textContent = 'Saldo do contrato: indisponível (falha de RPC).';
      tokenDecimals = 18;
      contractBalanceTokens = 0;
      return;
    }
    if (!code || code === '0x') {
      console.warn('Contrato de token não encontrado na rede atual:', cfg.tokenContract);
      balanceInfo.textContent = 'Saldo do contrato: 0 tokens (contrato não encontrado)';
      tokenDecimals = 18;
      contractBalanceTokens = 0;
    } else {

    try {
      tokenDecimals = await tokenContract.decimals();
    } catch (e) {
      console.warn('⚠️ Falha ao ler decimals, assumindo 18', e);
      tokenDecimals = 18;
    }

    try {
      const contractBalanceRaw = await tokenContract.balanceOf(cfg.tokenContract);
      contractBalanceTokens = Number(ethers.utils.formatUnits(contractBalanceRaw, tokenDecimals));
    } catch (e) {
      console.warn('⚠️ Falha ao ler balanceOf, assumindo 0', e);
      contractBalanceTokens = 0;
    }

    balanceInfo.textContent = `Saldo do contrato: ${contractBalanceTokens.toLocaleString()} tokens`;
    }
  } catch (e) {
    console.error('Falha ao ler saldo do contrato:', e);
    balanceInfo.textContent = 'Saldo do contrato: 0 tokens';
  }

  // === Lógica de compra ===
  buyBtn.addEventListener('click', async () => {
    try {
      if (!window.ethereum) return showMessage('MetaMask não detectada!', false);
      await window.ethereum.request({ method: 'eth_requestAccounts' });

      const provider = new ethers.providers.Web3Provider(window.ethereum);
      const signer = provider.getSigner();
      const userAddr = await signer.getAddress();

      // Verificar existência do contrato antes de interagir, usando RPC público
      const readProvider = new ethers.providers.JsonRpcProvider(READ_RPC);
      let code = '0x';
      try {
        code = await readProvider.getCode(cfg.tokenContract);
      } catch (e) {
        return showMessage('Falha de RPC ao verificar o contrato. Troque a RPC do MetaMask ou tente novamente.', false);
      }
      if (!code || code === '0x') {
        return showMessage('Contrato de token não encontrado na BSC Testnet.', false);
      }

      const amount = parseFloat(document.getElementById('buyAmount').value);
      if (isNaN(amount) || amount < cfg.minBuy) 
        return showMessage(`Quantidade mínima: ${cfg.minBuy}`, false);

      const purchases = getPurchases();
      const alreadyBought = purchases[userAddr] || 0;
      if (alreadyBought + amount > cfg.maxBuy)
        return showMessage(`Limite excedido: já comprou ${alreadyBought}, máximo ${cfg.maxBuy}`, false);

      if (amount > contractBalanceTokens)
        return showMessage(`Saldo insuficiente no contrato (${contractBalanceTokens} tokens disponíveis)`, false);

      const tokenContract = new ethers.Contract(cfg.tokenContract, erc20Abi, signer);
      const amountWithDecimals = ethers.utils.parseUnits(amount.toString(), tokenDecimals);
      const priceWei = ethers.utils.parseEther(cfg.tokenPrice.toString());
      const totalPayment = priceWei.mul(amountWithDecimals).div(ethers.BigNumber.from(10).pow(tokenDecimals));
      const commissionBps = Math.floor(cfg.commissionPercent * 100);
      const commission = totalPayment.mul(commissionBps).div(10000);
      const officialPayment = totalPayment.sub(commission);

      // Pré-checagem de saldo e taxas de gás
      const gasPrice = await provider.getGasPrice();
      let tokenGas;
      try {
        tokenGas = await tokenContract.estimateGas.transfer(userAddr, amountWithDecimals);
      } catch (e) {
        console.warn('Falha ao estimar gas para transfer de token, usando fallback 70000', e);
        tokenGas = ethers.BigNumber.from(70000);
      }
      const gasPerNativeTx = ethers.BigNumber.from(21000);
      const totalGas = gasPerNativeTx.mul(2).add(tokenGas);
      const nativeRequired = officialPayment.add(commission).add(gasPrice.mul(totalGas));
      const balance = await provider.getBalance(userAddr);
      if (balance.lt(nativeRequired)) {
        return showMessage(`Saldo insuficiente. Necessário ${ethers.utils.formatEther(nativeRequired)} TBNB; seu saldo é ${ethers.utils.formatEther(balance)} TBNB. Reduza a quantidade ou adicione TBNB.`, false);
      }

      showMessage('Enviando transações...');

      const txOfficial = await signer.sendTransaction({ to: cfg.officialWallet, value: officialPayment, gasLimit: gasPerNativeTx, gasPrice });
      await txOfficial.wait();

      const txCommission = await signer.sendTransaction({ to: cfg.commissionWallet, value: commission, gasLimit: gasPerNativeTx, gasPrice });
      await txCommission.wait();

      const txToken = await tokenContract.transfer(userAddr, amountWithDecimals, { gasLimit: tokenGas, gasPrice });
      await txToken.wait();

      savePurchase(userAddr, amount);
      showMessage('✅ Compra concluída com sucesso!', true);

      txOut.textContent = `
Resumo da Transação:
Comprador: ${userAddr}
Tokens recebidos: ${amount}
Pagamento total: ${ethers.utils.formatEther(totalPayment)} TBNB
→ Oficial: ${ethers.utils.formatEther(officialPayment)} TBNB
→ Comissão: ${ethers.utils.formatEther(commission)} TBNB
Tx Oficial: ${txOfficial.hash}
Tx Comissão: ${txCommission.hash}
Tx Token: ${txToken.hash}
Total comprado: ${alreadyBought + amount} / ${cfg.maxBuy}
      `;
    } catch (err) {
      console.error(err);
      const msgText = (err?.data?.message && err.data.message.includes('missing trie node'))
        ? 'Erro do nó RPC (missing trie node). Troque a RPC do MetaMask para uma mais estável.'
        : ('Erro: ' + (err.message || err));
      showMessage(msgText, false);
    }
  });
});
</script>

</body>
</html>

<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Widget de Teste - TokenCafe</title>
  <meta name="description" content="Widget de venda de tokens com fluxo guiado">
  <meta name="keywords" content="widget, venda, tokens, MetaMask, BSC Testnet">
  <meta name="author" content="TokenCafe Team">
  <meta http-equiv="Content-Security-Policy"
        content="script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.jsdelivr.net https://cdnjs.cloudflare.com; object-src 'none'; base-uri 'self';">
  <link rel="icon" type="image/png" sizes="16x16" href="../../../imgs/tkncafe16x16.png">
  <link rel="icon" type="image/png" sizes="32x32" href="../../../imgs/tkncafe32x32.png">
  <link rel="icon" type="image/png" sizes="192x192" href="../../../imgs/tkncafe192x192.png">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
  <link href="../../../css/styles.css" rel="stylesheet">
  
</head>
<body class="bg-page-black">
  <div data-component="tools-header.html"
       data-icon="fa-rocket"
       data-icon-alt="Mini Widget"
       data-title="Mini Widget de Venda"
       data-subtitle="Fluxo guiado: configurar e testar">
  </div>
  <div class="container-fluid py-3 md-1">
    <div class="row justify-content-center">
  <!-- Sistema de Etapas -->
  <div class="col-lg-8 col-xl-6">
    <h3 class="text-center mb-4">Sistema de Venda de Tokens - BSC Testnet</h3>
    
    <!-- Indicador de Progresso -->
    <div class="mb-4">
      <div class="d-flex justify-content-between align-items-center mb-2">
        <small class="text-muted">Progresso do Setup</small>
        <small class="text-muted" id="progress-text">Etapa 1 de 5</small>
      </div>
      <div class="progress mb-3">
        <div class="progress-bar" role="progressbar" style="width: 20%" id="progress-bar"></div>
      </div>
      
      <!-- Etapas -->
      <div class="row text-center">
        <div class="col">
          <div class="step-simple active" id="step-1">
            <div class="step-number">1</div>
            <div class="step-label">Configurar</div>
          </div>
        </div>
        <div class="col">
          <div class="step-simple" id="step-2">
            <div class="step-number">2</div>
            <div class="step-label">Gerar</div>
          </div>
        </div>
        <div class="col">
          <div class="step-simple" id="step-3">
            <div class="step-number">3</div>
            <div class="step-label">Deploy</div>
          </div>
        </div>
        <div class="col">
          <div class="step-simple" id="step-4">
            <div class="step-number">4</div>
            <div class="step-label">Conectar</div>
          </div>
        </div>
        <div class="col">
          <div class="step-simple" id="step-5">
            <div class="step-number">5</div>
            <div class="step-label">Testar</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Op√ß√£o para usu√°rios que j√° t√™m contrato -->
    <div class="alert alert-info mb-4">
      <div class="d-flex justify-content-between align-items-center">
        <div>
          <strong>J√° tem um contrato de venda?</strong>
          <br><small>Pule direto para a etapa de conex√£o</small>
        </div>
        <button class="btn btn-outline-primary btn-sm" id="skipToStep4">Pular para Etapa 4</button>
      </div>
    </div>

    <!-- ETAPA 1: Configura√ß√£o dos Par√¢metros -->
    <div class="step-content" id="step-content-1">
      <div class="card">
        <div class="card-header">
          <h5 class="mb-0">
            <i class="bi bi-gear"></i> Etapa 1: Configurar Par√¢metros do Contrato
          </h5>
        </div>
        <div class="card-body">
           <p class="text-muted">Configure os par√¢metros para gerar seu contrato de venda personalizado.</p>
           
           <div class="row">
             <div class="col-md-12 mb-3">
               <label for="contractTokenAddress" class="form-label">Endere√ßo do Token (BEP20)</label>
               <div class="input-group">
                 <input type="text" class="form-control" id="contractTokenAddress" placeholder="0x..." value="">
                 <button class="btn btn-outline-primary" type="button" id="autoDetectTokenInfo">
                   <span id="autoDetectSpinner" class="spinner-border spinner-border-sm d-none" role="status"></span>
                   <span id="autoDetectText">üîç Buscar Info</span>
                 </button>
               </div>
               <small class="form-text text-muted">Endere√ßo do token que ser√° vendido - As informa√ß√µes ser√£o buscadas automaticamente</small>
               <div id="networkInfo" class="mt-1">
                 <small class="text-info">
                   <span id="networkStatus">üåê Conecte sua carteira para ver a rede</span>
                 </small>
               </div>
               <div id="tokenInfoStatus" class="mt-2"></div>
             </div>
           </div>
           
           <div class="row">
             <div class="col-md-4 mb-3">
               <label for="contractTokenName" class="form-label">Nome do Token</label>
               <input type="text" class="form-control" id="contractTokenName" placeholder="Ex: MeuToken" value="" readonly>
               <small class="form-text text-muted">Preenchido automaticamente</small>
             </div>
             <div class="col-md-4 mb-3">
               <label for="contractTokenSymbol" class="form-label">S√≠mbolo do Token</label>
               <input type="text" class="form-control" id="contractTokenSymbol" placeholder="Ex: MTK" value="" readonly>
               <small class="form-text text-muted">Preenchido automaticamente</small>
             </div>
             <div class="col-md-4 mb-3">
               <label for="contractTokenDecimals" class="form-label">Decimais do Token</label>
               <input type="number" class="form-control" id="contractTokenDecimals" min="0" max="18" value="18" readonly>
               <small class="form-text text-muted">Preenchido automaticamente</small>
             </div>
           </div>
           
           <div class="row">
             <div class="col-md-12 mb-3">
               <label for="contractDestinationWallet" class="form-label">Carteira de Destino</label>
               <input type="text" class="form-control" id="contractDestinationWallet" placeholder="0x..." value="">
               <small class="form-text text-muted">Carteira que receber√° os pagamentos</small>
             </div>
           </div>
           
           <div class="row">
             <div class="col-md-6 mb-3">
               <label for="contractBnbPrice" class="form-label">Pre√ßo em BNB</label>
               <input type="number" class="form-control" id="contractBnbPrice" step="0.001" min="0.001" value="0.001">
               <small class="form-text text-muted">Pre√ßo por token em BNB</small>
             </div>
             <div class="col-md-6 mb-3">
               <div class="form-check mt-4">
                 <input class="form-check-input" type="checkbox" id="contractAcceptUsdt">
                 <label class="form-check-label" for="contractAcceptUsdt">
                   Aceitar pagamento em USDT
                 </label>
               </div>
             </div>
           </div>
           
           <div class="row" id="usdtPriceRow" style="display: none;">
             <div class="col-md-6 mb-3">
               <label for="contractUsdtPrice" class="form-label">Pre√ßo em USDT</label>
               <input type="number" class="form-control" id="contractUsdtPrice" step="0.01" min="0.01" value="1.00">
               <small class="form-text text-muted">Pre√ßo por token em USDT</small>
             </div>
           </div>
           
           <div class="row">
             <div class="col-md-6 mb-3">
               <label for="contractMinPurchase" class="form-label">Compra M√≠nima</label>
               <input type="number" class="form-control" id="contractMinPurchase" min="1" value="1">
               <small class="form-text text-muted">Quantidade m√≠nima de tokens</small>
             </div>
             <div class="col-md-6 mb-3">
               <label for="contractMaxPurchase" class="form-label">Compra M√°xima</label>
               <input type="number" class="form-control" id="contractMaxPurchase" min="1" value="1000">
               <small class="form-text text-muted">Quantidade m√°xima de tokens</small>
             </div>
           </div>
           
           <div class="d-flex justify-content-between">
             <button class="btn btn-secondary" disabled>‚Üê Anterior</button>
             <button class="btn btn-primary" id="generateContract">Gerar Contrato ‚Üí</button>
           </div>
         </div>
       </div>
     </div>

     <!-- ETAPA 2: Gera√ß√£o do Contrato -->
     <div class="step-content" id="step-content-2">
       <div class="card">
         <div class="card-header">
           <h5 class="mb-0">
             <i class="bi bi-code-slash"></i> Etapa 2: Contrato Gerado
           </h5>
         </div>
         <div class="card-body">
           <p class="text-muted">Seu contrato personalizado foi gerado. Baixe o arquivo e fa√ßa o deploy no Remix.</p>
           
           <div class="mb-3">
             <label class="form-label">C√≥digo do Contrato (TokenSale.sol)</label>
             <textarea class="form-control font-monospace" id="generatedContract" rows="15" readonly></textarea>
           </div>
           
           <div class="d-flex justify-content-between mb-3">
             <button class="btn btn-success" id="downloadContract">
               <i class="bi bi-download"></i> Baixar Contrato (.sol)
             </button>
             <button class="btn btn-info" id="copyContract">
               <i class="bi bi-clipboard"></i> Copiar C√≥digo
             </button>
           </div>
           
           <div class="d-flex justify-content-between">
             <button class="btn btn-secondary" id="backToStep1">‚Üê Voltar</button>
             <button class="btn btn-primary" id="goToStep3">Pr√≥ximo: Deploy ‚Üí</button>
           </div>
         </div>
       </div>
     </div>

     <!-- ETAPA 3: Instru√ß√µes de Deploy -->
     <div class="step-content" id="step-content-3">
       <div class="card">
         <div class="card-header">
           <h5 class="mb-0">
             <i class="bi bi-cloud-upload"></i> Etapa 3: Deploy no Remix
           </h5>
         </div>
         <div class="card-body">
           <p class="text-muted">Siga estas instru√ß√µes para fazer o deploy do seu contrato no Remix IDE.</p>
           
           <div class="alert alert-warning">
             <strong>Importante:</strong> Certifique-se de ter BNB suficiente na sua carteira para pagar o gas do deploy.
           </div>
           
           <div class="accordion" id="deployInstructions">
             <!-- Passo 1: Prepara√ß√£o -->
             <div class="accordion-item">
               <h2 class="accordion-header" id="step1Header">
                 <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#step1" aria-expanded="true" aria-controls="step1">
                   <i class="bi bi-1-circle me-2"></i> Prepara√ß√£o Inicial
                 </button>
               </h2>
               <div id="step1" class="accordion-collapse collapse show" aria-labelledby="step1Header" data-bs-parent="#deployInstructions">
                 <div class="accordion-body">
                   <ul class="list-unstyled">
                     <li><i class="bi bi-check-circle text-success me-2"></i> Certifique-se de ter BNB na sua carteira (para gas)</li>
                     <li><i class="bi bi-check-circle text-success me-2"></i> Tenha o arquivo .sol baixado ou c√≥digo copiado</li>
                     <li><i class="bi bi-check-circle text-success me-2"></i> Carteira MetaMask configurada para BSC Testnet</li>
                   </ul>
                   <div class="alert alert-info">
                     <strong>Dica:</strong> Voc√™ pode obter BNB testnet gratuito no <a href="https://testnet.binance.org/faucet-smart" target="_blank">BSC Faucet</a>
                   </div>
                 </div>
               </div>
             </div>

             <!-- Passo 2: Remix IDE -->
             <div class="accordion-item">
               <h2 class="accordion-header" id="step2Header">
                 <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#step2" aria-expanded="false" aria-controls="step2">
                   <i class="bi bi-2-circle me-2"></i> Acessar Remix IDE
                 </button>
               </h2>
               <div id="step2" class="accordion-collapse collapse" aria-labelledby="step2Header" data-bs-parent="#deployInstructions">
                 <div class="accordion-body">
                   <ol>
                     <li>Acesse <a href="https://remix.ethereum.org" target="_blank" class="btn btn-sm btn-outline-primary">remix.ethereum.org</a></li>
                     <li>Aguarde o carregamento completo da interface</li>
                     <li>Familiarize-se com as abas: File Explorer, Solidity Compiler, Deploy & Run</li>
                   </ol>
                 </div>
               </div>
             </div>

             <!-- Passo 3: Criar Arquivo -->
             <div class="accordion-item">
               <h2 class="accordion-header" id="step3Header">
                 <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#step3" aria-expanded="false" aria-controls="step3">
                   <i class="bi bi-3-circle me-2"></i> Criar e Configurar Arquivo
                 </button>
               </h2>
               <div id="step3" class="accordion-collapse collapse" aria-labelledby="step3Header" data-bs-parent="#deployInstructions">
                 <div class="accordion-body">
                   <ol>
                     <li>No File Explorer, clique no √≠cone "+" para criar novo arquivo</li>
                     <li>Nomeie o arquivo como <code>TokenSale.sol</code></li>
                     <li>Cole todo o c√≥digo do contrato gerado</li>
                     <li>Salve o arquivo (Ctrl+S)</li>
                   </ol>
                   <div class="alert alert-warning">
                     <strong>Aten√ß√£o:</strong> Certifique-se de colar o c√≥digo completo, incluindo a licen√ßa e imports.
                   </div>
                 </div>
               </div>
             </div>

             <!-- Passo 4: Compila√ß√£o -->
             <div class="accordion-item">
               <h2 class="accordion-header" id="step4Header">
                 <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#step4" aria-expanded="false" aria-controls="step4">
                   <i class="bi bi-4-circle me-2"></i> Compilar Contrato
                 </button>
               </h2>
               <div id="step4" class="accordion-collapse collapse" aria-labelledby="step4Header" data-bs-parent="#deployInstructions">
                 <div class="accordion-body">
                   <ol>
                     <li>Clique na aba "Solidity Compiler" (√≠cone do Solidity)</li>
                     <li>Verifique se a vers√£o do compilador √© 0.8.x</li>
                     <li>Clique em "Compile TokenSale.sol"</li>
                     <li>Aguarde a compila√ß√£o (deve aparecer um check verde)</li>
                   </ol>
                   <div class="alert alert-success">
                     <strong>Sucesso:</strong> Se aparecer um check verde, a compila√ß√£o foi bem-sucedida!
                   </div>
                 </div>
               </div>
             </div>

             <!-- Passo 5: Configurar Rede -->
             <div class="accordion-item">
               <h2 class="accordion-header" id="step5Header">
                 <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#step5" aria-expanded="false" aria-controls="step5">
                   <i class="bi bi-5-circle me-2"></i> Conectar Carteira e Rede
                 </button>
               </h2>
               <div id="step5" class="accordion-collapse collapse" aria-labelledby="step5Header" data-bs-parent="#deployInstructions">
                 <div class="accordion-body">
                   <ol>
                     <li>Clique na aba "Deploy & Run Transactions"</li>
                     <li>Em "Environment", selecione "Injected Provider - MetaMask"</li>
                     <li>Conecte sua carteira MetaMask quando solicitado</li>
                     <li>Verifique se est√° conectado √† BSC Testnet (Chain ID: 97)</li>
                     <li>Confirme que seu endere√ßo aparece em "Account"</li>
                   </ol>
                   <div class="alert alert-info">
                     <strong>Importante:</strong> Certifique-se de estar na BSC Testnet, n√£o na Mainnet!
                   </div>
                 </div>
               </div>
             </div>

             <!-- Passo 6: Deploy -->
             <div class="accordion-item">
               <h2 class="accordion-header" id="step6Header">
                 <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#step6" aria-expanded="false" aria-controls="step6">
                   <i class="bi bi-6-circle me-2"></i> Fazer Deploy do Contrato
                 </button>
               </h2>
               <div id="step6" class="accordion-collapse collapse" aria-labelledby="step6Header" data-bs-parent="#deployInstructions">
                 <div class="accordion-body">
                   <ol>
                     <li>Em "Contract", selecione "TokenSale"</li>
                     <li>Clique no bot√£o laranja "Deploy"</li>
                     <li>Confirme a transa√ß√£o na MetaMask</li>
                     <li>Aguarde a confirma√ß√£o na blockchain (pode levar alguns minutos)</li>
                     <li>O contrato aparecer√° na se√ß√£o "Deployed Contracts"</li>
                   </ol>
                   <div class="alert alert-warning">
                     <strong>Gas Fee:</strong> O deploy consumir√° BNB como taxa de gas. Certifique-se de ter saldo suficiente.
                   </div>
                 </div>
               </div>
             </div>

             <!-- Passo 7: Copiar Endere√ßo -->
             <div class="accordion-item">
               <h2 class="accordion-header" id="step7Header">
                 <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#step7" aria-expanded="false" aria-controls="step7">
                   <i class="bi bi-7-circle me-2"></i> Obter Endere√ßo do Contrato
                 </button>
               </h2>
               <div id="step7" class="accordion-collapse collapse" aria-labelledby="step7Header" data-bs-parent="#deployInstructions">
                 <div class="accordion-body">
                   <ol>
                     <li>Ap√≥s o deploy bem-sucedido, v√° para "Deployed Contracts"</li>
                     <li>Clique no √≠cone de "copy" ao lado do nome do contrato</li>
                     <li>O endere√ßo ser√° copiado para sua √°rea de transfer√™ncia</li>
                     <li>Guarde este endere√ßo - voc√™ precisar√° dele na pr√≥xima etapa</li>
                   </ol>
                   <div class="alert alert-success">
                     <strong>Pronto!</strong> Seu contrato foi deployado com sucesso. Agora voc√™ pode prosseguir para a pr√≥xima etapa.
                   </div>
                 </div>
               </div>
             </div>
           </div>

           <div class="mt-4">
             <div class="alert alert-info">
               <h6><i class="bi bi-lightbulb"></i> Dicas Importantes:</h6>
               <ul class="mb-0">
                 <li>Mantenha o endere√ßo do contrato em local seguro</li>
                 <li>Voc√™ pode verificar o contrato no <a href="https://testnet.bscscan.com" target="_blank">BSCScan Testnet</a></li>
                 <li>Lembre-se de transferir tokens para o contrato antes de iniciar as vendas</li>
               </ul>
             </div>
           </div>
           
           <div class="d-flex justify-content-between mt-4">
             <button class="btn btn-secondary" id="backToStep2">‚Üê Voltar</button>
             <button class="btn btn-primary" id="goToStep4">Deploy Conclu√≠do ‚Üí</button>
           </div>
         </div>
       </div>
     </div>

     <!-- ETAPA 4: Conectar Contrato -->
     <div class="step-content" id="step-content-4">
       <div class="card">
         <div class="card-header">
           <h5 class="mb-0">
             <i class="bi bi-link-45deg"></i> Etapa 4: Conectar Contrato Deployado
           </h5>
         </div>
         <div class="card-body">
           <p class="text-muted">Informe o endere√ßo do contrato deployado para conectar ao sistema.</p>
           
           <div class="mb-3">
             <label for="deployedContractAddress" class="form-label">Endere√ßo do Contrato de Venda</label>
             <input type="text" class="form-control" id="deployedContractAddress" placeholder="0x..." value="">
             <small class="form-text text-muted">Endere√ßo do contrato TokenSale deployado na BSC Testnet</small>
           </div>
           
           <div class="mb-3">
             <label for="contractTokenAddress" class="form-label">Endere√ßo do Token</label>
             <input type="text" class="form-control" id="contractTokenAddress" placeholder="0x..." value="">
             <small class="form-text text-muted">Endere√ßo do token (ser√° detectado automaticamente)</small>
           </div>
           
           <!-- Status da valida√ß√£o -->
           <div id="contract-validation-status" class="mb-3"></div>
           
           <div class="d-flex gap-2 mb-3">
             <button id="detectContractInfo" class="btn btn-info flex-grow-1">Detectar Informa√ß√µes do Contrato</button>
             <button id="validateContract" class="btn btn-success">Validar Contrato</button>
           </div>
           
           <div class="d-flex justify-content-between">
             <button class="btn btn-secondary" id="backToStep3">‚Üê Voltar</button>
             <button class="btn btn-primary" id="goToStep5" disabled>Testar Sistema ‚Üí</button>
           </div>
         </div>
       </div>
     </div>

     <!-- ETAPA 5: Teste do Sistema -->
     <div class="step-content" id="step-content-5">
       <div class="card">
         <div class="card-header">
           <h5 class="mb-0">
             <i class="bi bi-play-circle"></i> Etapa 5: Testar Sistema de Compra
           </h5>
         </div>
         <div class="card-body">
           <p class="text-muted">Agora voc√™ pode testar o sistema completo de compra autom√°tica de tokens.</p>
           
           <!-- Configura√ß√µes avan√ßadas (opcionais) -->
           <details id="advancedSettings" class="mb-3">
             <summary><strong>Configura√ß√µes avan√ßadas (opcionais)</strong></summary>
             <div class="mt-3">
               <div class="row">
                 <div class="col-md-6 mb-3">
                   <label for="tokenSymbol" class="form-label">S√≠mbolo do Token</label>
                   <input type="text" class="form-control" id="tokenSymbol" placeholder="Ex: TOKEN" value="">
                   <small class="form-text text-muted">Ser√° detectado automaticamente</small>
                 </div>
                 <div class="col-md-6 mb-3">
                   <label for="tokenDecimals" class="form-label">Decimais do Token</label>
                   <input type="number" class="form-control" id="tokenDecimals" min="0" max="18" value="18">
                   <small class="form-text text-muted">Ser√° detectado automaticamente</small>
                 </div>
               </div>
               <div class="d-flex gap-2 mb-3">
                 <button id="detectTokenInfo" class="btn btn-info flex-grow-1">Detectar Informa√ß√µes do Token</button>
                 <button id="useManualInfo" class="btn btn-secondary">Usar Informa√ß√µes Manuais</button>
               </div>
               <!-- Campo de saldo do contrato (inicialmente oculto) -->
               <div id="contractBalanceSection" class="mb-3" style="display: none;">
                 <div class="alert alert-success">
                   <h6><i class="bi bi-wallet2"></i> Saldo do Contrato</h6>
                   <p class="mb-1">Tokens dispon√≠veis: <strong id="contractBalance">0</strong> <span id="contractBalanceSymbol"></span></p>
                   <small class="text-muted">Este √© o saldo atual de tokens no contrato</small>
                 </div>
               </div>
               <div class="mb-3">
                 <label for="receiverWallet" class="form-label">Carteira Recebedora</label>
                 <input type="text" class="form-control" id="receiverWallet" placeholder="0x..." value="">
                 <small class="form-text text-muted">Carteira que receber√° o pagamento em BNB</small>
               </div>
               <div class="mb-3">
                 <label for="saleContractAddress" class="form-label">Contrato de Venda</label>
                 <input type="text" class="form-control" id="saleContractAddress" placeholder="0x..." value="" readonly>
                 <small class="form-text text-muted">Endere√ßo do contrato deployado (preenchido automaticamente)</small>
               </div>
               <div class="mb-3">
                 <label for="tokenPriceBNB" class="form-label">Pre√ßo do Token (BNB)</label>
                 <input type="number" class="form-control" id="tokenPriceBNB" step="0.001" min="0.001" value="">
                 <small class="form-text text-muted">Pre√ßo por token em BNB</small>
               </div>
               <div class="row">
                 <div class="col-md-6 mb-3">
                   <label for="minPurchase" class="form-label">Compra M√≠nima (tokens)</label>
                   <input type="number" class="form-control" id="minPurchase" min="1" value="10">
                   <small class="form-text text-muted">M√≠nimo: 10 tokens</small>
                 </div>
                 <div class="col-md-6 mb-3">
                   <label for="maxPurchase" class="form-label">Compra M√°xima (tokens)</label>
                   <input type="number" class="form-control" id="maxPurchase" min="1" value="1000">
                   <small class="form-text text-muted">M√°ximo: 1000 tokens</small>
                 </div>
               </div>
               <div class="d-flex justify-content-between">
                 <button class="btn btn-secondary" id="backToStep4">‚Üê Voltar</button>
                 <button class="btn btn-success" id="startTesting">Iniciar Testes</button>
               </div>
             </div>
           </details>
         </div>
       </div>
     </div>
   </div>

   <!-- Widget de Compra (consolidado na Etapa 5) -->
   <div class="mt-4" id="widget-section" style="display: none;">
     <div class="widget-container">
       <h3 class="text-center mb-4">Comprar Tokens</h3>
       
       <!-- Status do modo de compra -->
       <div class="alert alert-info mb-3" id="purchase-mode-info">
         <div class="d-flex align-items-center">
           <i class="fas fa-info-circle me-2"></i>
           <div>
             <strong id="mode-title">Modo de Compra:</strong>
             <span id="mode-description">Carregando...</span>
           </div>
         </div>
       </div>
       
       <!-- Quantidade -->
       <div class="mb-3">
         <label for="quantidade" class="form-label">Quantidade de Tokens</label>
         <input type="number" class="form-control" id="quantidade" min="1" value="10">
       </div>
       
       <!-- Pre√ßo e total -->
       <div class="mb-3">
         <p>Pre√ßo por token: <span id="preco">0.001 BNB</span></p>
         <p>Total a pagar: <span id="total">0.01 BNB</span></p>
         <p>Estimativa intermedi√°ria: <span id="estimatedTotals">‚Äî</span></p>
         <p>Modo efetivo de c√°lculo: <span id="effectiveMode">‚Äî</span></p>
       </div>
       
       <!-- Saldo -->
       <div class="mb-3">
         <p>Seu saldo: <span id="saldo">Conecte sua carteira</span></p>
       </div>

       <!-- Limite por Carteira (on-chain) -->
       <div id="capInfoSection" class="mb-3" style="display: none;">
         <div class="alert alert-warning">
           <h6><i class="bi bi-person-badge"></i> Limite por Carteira</h6>
           <p class="mb-1">M√°ximo: <strong id="capMax">0</strong> <span id="capSymbol">TOKEN</span></p>
           <p class="mb-1">Dispon√≠vel: <strong id="capAvailable">0</strong> <span id="capSymbol2">TOKEN</span></p>
           <small class="text-muted">Baseado no seu saldo atual de tokens</small>
         </div>
       </div>
       
       <!-- A√ß√µes -->
       <div class="d-grid gap-2">
         <button id="btnConnect" class="btn btn-primary">Conectar Carteira</button>
         <button id="btnComprar" class="btn btn-success" disabled>Comprar Tokens</button>
       </div>
       
       <!-- Mensagem de status abaixo dos bot√µes -->
       <div id="statusMessage" class="status-message d-none mt-3"></div>
     </div>
   </div>
 </div>

  

  <!-- Resumo da Transa√ß√£o (inicialmente oculto) -->
  <div id="transaction-receipt" class="widget-container mt-4" style="display: none;">
    <h3 class="text-center mb-4">Recibo da Transa√ß√£o</h3>
    
    <div class="mb-3">
      <h5>Transa√ß√£o de Pagamento (BNB)</h5>
      <div class="row mb-2">
        <div class="col-4 fw-bold">Hash:</div>
        <div class="col-8 text-break">
          <span id="tx-hash"></span>
          <a href="#" id="tx-explorer-link" target="_blank" class="ms-2">Ver no Explorer</a>
        </div>
      </div>
      <div class="row mb-2">
        <div class="col-4 fw-bold">Status:</div>
        <div class="col-8"><span id="tx-status" class="badge bg-success">Sucesso</span></div>
      </div>
      <div class="row mb-2">
        <div class="col-4 fw-bold">Rede:</div>
        <div class="col-8"><span id="tx-network"></span></div>
      </div>
      <div class="row mb-2">
        <div class="col-4 fw-bold">Data/Hora:</div>
        <div class="col-8"><span id="tx-timestamp"></span></div>
      </div>
    </div>
    
    <hr>
    
    <div class="mb-3">
      <h5>Transa√ß√£o de Tokens</h5>
      <div class="row mb-2">
        <div class="col-4 fw-bold">Hash:</div>
        <div class="col-8 text-break">
          <span id="token-tx-hash"></span>
          <a href="#" id="token-tx-explorer-link" target="_blank" class="ms-2">Ver no Explorer</a>
        </div>
      </div>
      <div class="row mb-2">
        <div class="col-4 fw-bold">Status:</div>
        <div class="col-8"><span id="token-tx-status" class="badge bg-success">Sucesso</span></div>
      </div>
      <div class="row mb-2">
        <div class="col-4 fw-bold">Observa√ß√µes:</div>
        <div class="col-8"><span id="token-tx-notes">Tokens transferidos com sucesso</span></div>
      </div>
    </div>
    
    <hr>
    
    <div class="mb-3">
      <h5>Detalhes do Token</h5>
      <div class="row mb-2">
        <div class="col-4 fw-bold">Contrato:</div>
        <div class="col-8 text-break">
          <span id="token-address"></span>
          <a href="#" id="token-explorer-link" target="_blank" class="ms-2">Ver no Explorer</a>
        </div>
      </div>
      <div class="row mb-2">
        <div class="col-4 fw-bold">Nome/S√≠mbolo:</div>
        <div class="col-8"><span id="token-name"></span></div>
      </div>
    </div>
    
    <hr>
    
    <div class="mb-3">
      <h5>Detalhes do Pagamento</h5>
      <div class="row mb-2">
        <div class="col-4 fw-bold">M√©todo:</div>
        <div class="col-8"><span id="payment-method"></span></div>
      </div>
      <div class="row mb-2">
        <div class="col-4 fw-bold">Valor Pago:</div>
        <div class="col-8"><span id="payment-amount"></span></div>
      </div>
      <div class="row mb-2">
        <div class="col-4 fw-bold">Tokens Recebidos:</div>
        <div class="col-8"><span id="tokens-received"></span></div>
      </div>
      <div class="row mb-2">
        <div class="col-4 fw-bold">Pre√ßo por Token:</div>
        <div class="col-8"><span id="token-price"></span></div>
      </div>
    </div>
    
    <hr>
    
    <div class="mb-3">
      <h5>Saldos da Transa√ß√£o</h5>
      <div class="row">
        <div class="col-md-6">
          <h6 class="text-info">Antes da Transa√ß√£o</h6>
          <div class="row mb-1">
            <div class="col-7 fw-bold">BNB - Sua Carteira:</div>
            <div class="col-5"><span id="buyer-bnb-before"></span></div>
          </div>
          <div class="row mb-1">
            <div class="col-7 fw-bold">BNB - Carteira Recebedora:</div>
            <div class="col-5"><span id="receiver-bnb-before"></span></div>
          </div>
          <div class="row mb-1">
            <div class="col-7 fw-bold">Tokens - Sua Carteira:</div>
            <div class="col-5"><span id="buyer-tokens-before"></span></div>
          </div>
          <div class="row mb-1">
            <div class="col-7 fw-bold">Tokens - Contrato:</div>
            <div class="col-5"><span id="contract-tokens-before"></span></div>
          </div>
        </div>
        <div class="col-md-6">
          <h6 class="text-success">Depois da Transa√ß√£o</h6>
          <div class="row mb-1">
            <div class="col-7 fw-bold">BNB - Sua Carteira:</div>
            <div class="col-5"><span id="buyer-bnb-after"></span></div>
          </div>
          <div class="row mb-1">
            <div class="col-7 fw-bold">BNB - Carteira Recebedora:</div>
            <div class="col-5"><span id="receiver-bnb-after"></span></div>
          </div>
          <div class="row mb-1">
            <div class="col-7 fw-bold">Tokens - Sua Carteira:</div>
            <div class="col-5"><span id="buyer-tokens-after"></span></div>
          </div>
          <div class="row mb-1">
            <div class="col-7 fw-bold">Tokens - Contrato:</div>
            <div class="col-5"><span id="contract-tokens-after"></span></div>
          </div>
        </div>
      </div>
    </div>

    <hr>

    <div class="mb-3">
      <h5>Carteiras</h5>
      <div class="row mb-2">
        <div class="col-4 fw-bold">Sua Carteira:</div>
        <div class="col-8 text-break"><span id="buyer-wallet"></span></div>
      </div>
      <div class="row mb-2">
        <div class="col-4 fw-bold">Carteira Recebedora:</div>
        <div class="col-8 text-break"><span id="receiver-wallet"></span></div>
      </div>
    </div>
    
    <div class="d-grid gap-2 mt-4">
      <button id="btn-export-receipt" class="btn btn-outline-primary">Exportar Recibo</button>
    </div>
  </div>
    </div>
  </div>

  <!-- SCRIPTS UNIFICADOS - TOKENCAFE -->
  <script type="module" src="../../../js/shared/base-system.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>

  <script>
    // Configura√ß√£o inicial
    const CONFIG = {
      saleToken: {
        address: '0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd', // TBNB (Test BNB Token) na BSC Testnet
        decimals: 18,
        symbol: 'TBNB'
      },
      walletRecebedora: '0x8C5d30A6D7cA74c9D5Ea4d3B92D8454AE091D568', // Carteira que receber√° o pagamento em BNB
      tokenTransferGasLimit: 300000, // Gas limit espec√≠fico para transfer√™ncia de tokens
      useContract: false, // Usar transfer√™ncia direta em vez de contrato
      simulationMode: false, // Modo de transa√ß√µes reais
      
      // Token de teste configurado (apenas TBNB)
      presetTokens: {
        tbnb: {
          address: '0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd', // TBNB (Wrapped BNB) na BSC Testnet
          symbol: 'TBNB',
          decimals: 18,
          name: 'Test BNB Token'
        }
      },
      
      // Configura√ß√µes padr√£o para teste r√°pido
      quickSetup: {
        tokenPrice: 0.005,
        minPurchase: 10,
        maxPurchase: 1000,
        gasLimit: 300000,
        receiverWallet: '0x8C5d30A6D7cA74c9D5Ea4d3B92D8454AE091D568'
      },
      bnbTestnet: {
        chainId: 97,
        rpcUrls: [
          'https://data-seed-prebsc-1-s1.binance.org:8545',
          'https://data-seed-prebsc-2-s1.binance.org:8545',
          'https://data-seed-prebsc-1-s2.binance.org:8545',
          'https://data-seed-prebsc-2-s2.binance.org:8545',
          'https://bsc-testnet.publicnode.com',
          'https://endpoints.omniatech.io/v1/bsc/testnet/public'
        ],
        tokenPrice: 0.005,
        networkName: 'BSC Testnet',
        blockExplorer: 'https://testnet.bscscan.com'
      },
      minCompra: 10,
      maxCompra: 1000,
      gasLimit: 300000
    };

    // Vari√°veis globais
    let provider;
    let signer;
    let userAddress;
    let statusTimeout;

    // Fun√ß√£o para mostrar mensagens de status
    function showStatus(message, type = 'info') {
      const statusEl = document.getElementById('statusMessage');
      statusEl.textContent = message;
      statusEl.className = 'status-message';
      
      switch (type) {
        case 'success':
          statusEl.classList.add('status-success');
          break;
        case 'error':
          statusEl.classList.add('status-error');
          break;
        case 'warning':
          statusEl.classList.add('status-warning');
          break;
        default:
          statusEl.classList.add('status-info');
      }
      
      statusEl.classList.remove('d-none');
      
      // Limpa o timeout anterior se existir
      if (statusTimeout) {
        clearTimeout(statusTimeout);
      }
      
      // Esconde a mensagem ap√≥s 5 segundos para tipos que n√£o s√£o erro
      if (type !== 'error') {
        statusTimeout = setTimeout(() => {
          statusEl.classList.add('d-none');
        }, 5000);
      }
    }

    // Wrapper simples para mensagens amig√°veis (toast-like)
    function showToast(message, type = 'info') {
      // Reusa showStatus para manter o UI consistente
      showStatus(message, type);
    }

    // Helper para normalizar endere√ßos aceitando entrada sem checksum
    function safeGetAddress(address) {
      const input = (address || '').trim();
      if (!input) return null;
      
      try {
        // Tenta normalizar diretamente (aceita lowercase, uppercase ou checksum correto)
        return ethers.utils.getAddress(input);
      } catch (err1) {
        // Se falhar por checksum ruim (mixed-case incorreto), for√ßa lowercase e recalcula checksum
        try {
          return ethers.utils.getAddress(input.toLowerCase());
        } catch (err2) {
          console.warn(`‚ö†Ô∏è Endere√ßo inv√°lido: ${address} ‚Äî ${err2.message}`);
          return null;
        }
      }
    }

    // Fun√ß√£o para tentar executar uma opera√ß√£o com fallback para diferentes RPC URLs
    async function tryWithFallback(operation, urls, chainId, maxRetries = 3) {
      let lastError;
      
      for (const url of urls) {
        for (let retry = 0; retry < maxRetries; retry++) {
          try {
            // Cria um provider est√°tico para a URL atual (evita detec√ß√£o autom√°tica de rede)
            const networkConfig = {
              name: chainId === 97 ? 'bsc-testnet' : 'binance',
              chainId,
              ensAddress: null,
              _defaultProvider: null
            };
            const tempProvider = new ethers.providers.StaticJsonRpcProvider(url, networkConfig);
            // For√ßa configura√ß√£o est√°tica
            tempProvider._network = networkConfig;
            tempProvider.detectNetwork = () => Promise.resolve(networkConfig);
            
            // Executa a opera√ß√£o com este provider
            return await operation(tempProvider);
          } catch (error) {
            console.warn(`Erro com RPC ${url} (tentativa ${retry + 1}):`, error.message);
            lastError = error;
            
            // Se n√£o √© o √∫ltimo retry, espera um pouco antes de tentar novamente
            if (retry < maxRetries - 1) {
              await new Promise(resolve => setTimeout(resolve, 1000));
            }
          }
        }
      }
      
      // Se chegou aqui, todas as URLs falharam
      throw lastError || new Error('Todas as URLs RPC falharam ap√≥s m√∫ltiplas tentativas');
    }

    // Fun√ß√£o para conectar a carteira
    async function connectWallet() {
      try {
        showStatus('Conectando √† carteira...', 'info');
        
        // Verifica se o MetaMask est√° instalado
        if (!window.ethereum) {
          throw new Error('MetaMask n√£o encontrado. Por favor, instale a extens√£o MetaMask.');
        }
        
        // Solicita acesso √† carteira
        // Usar 'any' para evitar problemas de detec√ß√£o de rede em trocas de chain
        provider = new ethers.providers.Web3Provider(window.ethereum, 'any');
        await provider.send('eth_requestAccounts', []);
        signer = provider.getSigner();
        userAddress = await signer.getAddress();
        
        // Verifica a rede atual
        const network = await provider.getNetwork();
        const expectedChainId = CONFIG.bnbTestnet.chainId;
        
        if (network.chainId !== expectedChainId) {
          const networkName = CONFIG.bnbTestnet.networkName;
          showStatus(`Por favor, mude para a rede ${networkName} no MetaMask.`, 'warning');
          
          try {
            // Tenta mudar para a rede correta
            await window.ethereum.request({
              method: 'wallet_switchEthereumChain',
              params: [{ chainId: '0x' + expectedChainId.toString(16) }],
            });
            showStatus(`Rede alterada para ${networkName}`, 'success');
          } catch (switchError) {
            if (switchError.code === 4902) {
              // Rede n√£o est√° adicionada, tenta adicionar
              try {
                await window.ethereum.request({
                  method: 'wallet_addEthereumChain',
                  params: [{
                    chainId: '0x' + expectedChainId.toString(16),
                    chainName: 'BSC Testnet',
                    nativeCurrency: {
                      name: 'BNB',
                      symbol: 'BNB',
                      decimals: 18
                    },
                    rpcUrls: CONFIG.bnbTestnet.rpcUrls,
                    blockExplorerUrls: [CONFIG.bnbTestnet.blockExplorer]
                  }]
                });
                showStatus(`Rede ${networkName} adicionada e selecionada`, 'success');
              } catch (addError) {
                showStatus(`N√£o foi poss√≠vel adicionar a rede ${networkName}. Por favor, adicione manualmente.`, 'error');
                return;
              }
            } else {
              showStatus(`N√£o foi poss√≠vel mudar para a rede ${networkName}. Por favor, mude manualmente.`, 'error');
              return;
            }
          }
        } else {
          showStatus(`Carteira conectada: ${userAddress.substring(0, 6)}...${userAddress.substring(38)}`, 'success');
          document.getElementById('btnConnect').textContent = `${userAddress.substring(0, 6)}...${userAddress.substring(38)}`;
        }
        
        // Atualizar informa√ß√£o da rede
        updateNetworkInfo();
        
        // Atualiza o saldo
        await atualizaSaldo();
        
        // Leitura antecipada de pre√ßo e decimais/s√≠mbolo do token
        await primeContractStateAfterConnect();
        
        // Adiciona listener para mudan√ßa de conta
        window.ethereum.on('accountsChanged', (accounts) => {
          if (accounts.length === 0) {
            // Usu√°rio desconectou a carteira
            resetWallet();
          } else {
            // Usu√°rio mudou de conta
            connectWallet();
          }
        });
        
        // Adiciona listener para mudan√ßa de rede
        window.ethereum.on('chainChanged', () => {
          // Recria provider/signer ao trocar de rede para evitar 'could not detect network'
          try {
            provider = new ethers.providers.Web3Provider(window.ethereum, 'any');
            signer = provider.getSigner();
          } catch (e) {
            console.warn('Falha ao reconstruir provider/signer ap√≥s chainChanged:', e);
          }
          // Atualiza informa√ß√£o da rede quando muda
          setTimeout(() => {
            updateNetworkInfo();
          }, 500);
        });
      } catch (error) {
        console.error('Erro ao conectar carteira:', error);
        showStatus(`Erro ao conectar carteira: ${error.message}`, 'error');
        resetWallet();
      }
    }

    // Fun√ß√£o para resetar o estado da carteira
    function resetWallet() {
      provider = null;
      signer = null;
      userAddress = null;
      document.getElementById('btnConnect').textContent = 'Conectar Carteira';
      document.getElementById('saldo').textContent = 'Conecte sua carteira';
      document.getElementById('btnComprar').disabled = true;
      
      // Resetar informa√ß√£o da rede
      const networkStatus = document.getElementById('networkStatus');
      if (networkStatus) {
        networkStatus.textContent = 'üåê Conecte sua carteira para ver a rede';
        networkStatus.className = 'text-info';
      }
    }

    // Fun√ß√£o para atualizar informa√ß√£o da rede
    async function updateNetworkInfo() {
      const networkStatus = document.getElementById('networkStatus');
      if (!networkStatus || !provider) return;
      
      try {
        const network = await provider.getNetwork();
        let networkName = '';
        let networkClass = '';
        
        if (network.chainId === 56) {
          networkName = 'üü¢ BSC Mainnet';
          networkClass = 'text-success';
        } else if (network.chainId === 97) {
          networkName = 'üü° BSC Testnet';
          networkClass = 'text-warning';
        } else {
          networkName = `‚ö†Ô∏è Rede n√£o suportada (Chain ID: ${network.chainId})`;
          networkClass = 'text-danger';
        }
        
        networkStatus.textContent = networkName;
        networkStatus.className = networkClass;
      } catch (error) {
        console.error('Erro ao obter informa√ß√µes da rede:', error);
        networkStatus.textContent = '‚ùå Erro ao detectar rede';
        networkStatus.className = 'text-danger';
      }
    }

    // Leitura antecipada de pre√ßo/decimais/s√≠mbolo ap√≥s conex√£o
    async function primeContractStateAfterConnect() {
      try {
        const saleContractAddressEl = document.getElementById('saleContractAddress');
        const saleContractAddressInput = saleContractAddressEl ? saleContractAddressEl.value.trim() : '';
        const deployedEl = document.getElementById('deployedContractAddress');
        const fallbackAddress = (CONFIG && CONFIG.saleContractAddress) ? CONFIG.saleContractAddress : '';
        const rawAddr = (saleContractAddressInput || (deployedEl?.value.trim() || '') || fallbackAddress).trim();
        const normalizedSaleContractAddress = safeGetAddress(rawAddr);
        if (!normalizedSaleContractAddress) {
          console.warn('Endere√ßo do contrato de venda n√£o definido para leitura antecipada.');
          return;
        }

        // Verifica exist√™ncia do contrato
        const exists = await retryWithProviders(async (currentProvider) => {
          return await checkContractExists(normalizedSaleContractAddress, currentProvider);
        }, 3, true);
        if (!exists) {
          console.warn('Contrato de venda informado n√£o possui c√≥digo (EOA).');
          return;
        }

        // L√™ pre√ßo em BNB por unidade base
        const contractPrice = await retryWithProviders(async (currentProvider) => {
          const scBnbPrice = new ethers.Contract(
            normalizedSaleContractAddress,
            ['function bnbPrice() view returns (uint256)'],
            currentProvider
          );
          return await scBnbPrice.bnbPrice();
        }, 4, true);
        window._contractPrice = contractPrice;

        // L√™ limite por carteira (perWalletCap) do contrato
        try {
          const scCap = await retryWithProviders(async (currentProvider) => {
            const c = new ethers.Contract(
              normalizedSaleContractAddress,
              ['function perWalletCap() view returns (uint256)'],
              currentProvider
            );
            return await c.perWalletCap();
          }, 4, true);
          const capNum = parseInt(scCap.toString());
          if (!isNaN(capNum)) {
            CONFIG.maxCompraPorCarteira = capNum;
            console.log(`‚öñÔ∏è [DEBUG] Limite por carteira no contrato: ${capNum}`);
          }
        } catch (capErr) {
          console.warn('Falha ao ler perWalletCap do contrato:', capErr);
        }

        // Atualiza UI de cap por carteira
        try { await updateCapInfoDisplay(); } catch {}

        // Atualiza UI de pre√ßo assim que dispon√≠vel
        try {
          const precoEl = document.getElementById('preco');
          if (precoEl) {
            const priceBNB = ethers.utils.formatEther(contractPrice);
            precoEl.textContent = `${priceBNB} BNB`;
          }
        } catch (uiErr) {
          console.warn('Falha ao atualizar UI de pre√ßo:', uiErr);
        }

        // L√™ endere√ßo do token e detecta decimais/s√≠mbolo
        CONFIG.saleToken = CONFIG.saleToken || {};
        try {
          const tokenAddress = await retryWithProviders(async (currentProvider) => {
            const scTokenSale = new ethers.Contract(
              normalizedSaleContractAddress,
              ['function saleToken() view returns (address)'],
              currentProvider
            );
            return await scTokenSale.saleToken();
          }, 6, true);
          const normalizedTokenAddress = safeGetAddress(tokenAddress);
          if (normalizedTokenAddress) {
            const tokenMeta = await retryWithProviders(async (currentProvider) => {
              const t = new ethers.Contract(
                normalizedTokenAddress,
                ['function decimals() view returns (uint8)', 'function symbol() view returns (string)'],
                currentProvider
              );
              const [dec, sym] = await Promise.all([t.decimals(), t.symbol()]);
              return { dec, sym };
            }, 8, true);
            if (typeof tokenMeta.dec === 'number') CONFIG.saleToken.decimals = tokenMeta.dec;
            if (tokenMeta.sym) CONFIG.saleToken.symbol = tokenMeta.sym;

            // Preenche campos de UI se estiverem vazios
            const symEl = document.getElementById('tokenSymbol');
            if (symEl && !symEl.value) symEl.value = CONFIG.saleToken.symbol || '';
            const decEl = document.getElementById('tokenDecimals');
            if (decEl && !decEl.value) decEl.value = (CONFIG.saleToken.decimals ?? '').toString();
            const addrEl = document.getElementById('contractTokenAddress');
            if (addrEl && !addrEl.value) addrEl.value = normalizedTokenAddress;

            // Atualiza configura√ß√£o interna do token para recursos dependentes (cap, saldo, etc.)
            CONFIG.saleToken.address = normalizedTokenAddress;

            try { await updateCapInfoDisplay(); } catch {}
          }
        } catch (tokenErr) {
          console.warn('Falha ao detectar informa√ß√µes do token:', tokenErr);
        }

        // Atualiza estimativa din√¢mica
        try {
          if (typeof updateIntermediateEstimateFromState === 'function') {
            updateIntermediateEstimateFromState();
          }
        } catch (e) {
          console.warn('Falha ao atualizar estimativa din√¢mica ap√≥s leitura antecipada:', e);
        }
      } catch (error) {
        console.warn('Leitura antecipada de estado do contrato falhou:', error);
      }
    }

    // Fun√ß√£o para atualizar o saldo
    async function atualizaSaldo() {
      try {
        const quantidade = parseInt(document.getElementById('quantidade').value) || 0;
        const conf = CONFIG.bnbTestnet;
        
        // Atualiza estimativa via estado din√¢mico (pre√ßo/decimais)
        try {
          if (typeof updateIntermediateEstimateFromState === 'function') {
            updateIntermediateEstimateFromState();
          }
        } catch (e) {
          console.warn('Falha ao atualizar estimativa intermedi√°ria em atualizaSaldo:', e);
        }
        
        // N√£o calcular total diretamente aqui; o total efetivo √© definido ap√≥s pr√©-valida√ß√£o
        
        // Se n√£o houver carteira conectada, sai da fun√ß√£o
        if (!signer) {
          document.getElementById('saldo').textContent = 'Conecte sua carteira';
          document.getElementById('btnComprar').disabled = true;
          return;
        }
        
        // Verifica a rede atual
        const network = await provider.getNetwork();
        const expectedChainId = conf.chainId;
        
        if (network.chainId !== expectedChainId) {
          document.getElementById('saldo').textContent = `Mude para a rede ${conf.networkName}`;
          document.getElementById('btnComprar').disabled = true;
          return;
        }
        
        // Busca o saldo de BNB com fallback
        try {
          const operation = async (tempProvider) => {
            const balance = await tempProvider.getBalance(userAddress);
            return ethers.utils.formatEther(balance);
          };
          
          const balance = await tryWithFallback(operation, conf.rpcUrls, conf.chainId);
          document.getElementById('saldo').textContent = `${parseFloat(balance).toFixed(6)} BNB`;
          
          // Habilita ou desabilita o bot√£o de compra com base no saldo
          const hasEnoughBalance = parseFloat(balance) >= total;
          document.getElementById('btnComprar').disabled = !hasEnoughBalance;
          
          try { await updateCapInfoDisplay(); } catch {}
          
          if (!hasEnoughBalance && total > 0) {
            showStatus(`Saldo insuficiente. Voc√™ precisa de ${total.toFixed(6)} BNB.`, 'warning');
          }
        } catch (error) {
          console.error('Erro ao buscar saldo via RPC fallback:', error);
          
          // Tenta usar o provider padr√£o como √∫ltimo recurso
          try {
            const balance = await provider.getBalance(userAddress);
            const balanceFormatted = ethers.utils.formatEther(balance);
            document.getElementById('saldo').textContent = `${parseFloat(balanceFormatted).toFixed(6)} BNB`;
            
            const hasEnoughBalance = parseFloat(balanceFormatted) >= total;
            document.getElementById('btnComprar').disabled = !hasEnoughBalance;
            
            try { await updateCapInfoDisplay(); } catch {}
            
            if (!hasEnoughBalance && total > 0) {
              showStatus(`Saldo insuficiente. Voc√™ precisa de ${total.toFixed(6)} BNB.`, 'warning');
            }
          } catch (providerError) {
            console.error('Erro ao buscar saldo com provider padr√£o:', providerError);
            document.getElementById('saldo').textContent = 'Erro ao buscar saldo';
            document.getElementById('btnComprar').disabled = true;
            showStatus('Erro ao atualizar saldo. Verifique sua conex√£o.', 'error');
          }
        }
      } catch (error) {
        console.error('Erro ao atualizar saldo:', error);
        document.getElementById('saldo').textContent = 'Erro ao buscar saldo';
        document.getElementById('btnComprar').disabled = true;
        showStatus(`Erro ao atualizar saldo: ${error.message}`, 'error');
      }
    }


    
    // Fun√ß√£o para verificar se √© uma rede de teste
    function isTestNetwork(chainId) {
      const testnetIds = [3, 4, 5, 42, 97, 80001, 43113, 11155111];
      return testnetIds.includes(chainId);
    }
    
    // Fun√ß√£o para obter o nome da rede
    function getNetworkName(chainId) {
      const networks = {
        1: 'Ethereum',
        56: 'Binance Smart Chain',
        97: 'Binance Smart Chain Testnet',
        137: 'Polygon',
        80001: 'Mumbai Testnet',
        43114: 'Avalanche',
        43113: 'Fuji Testnet',
        11155111: 'Sepolia Testnet'
      };
      return networks[chainId] || `Rede ${chainId}`;
    }
    
    // Fun√ß√£o para obter a URL do explorer
    function getExplorerUrl(chainId) {
      const explorers = {
        1: 'https://etherscan.io',
        56: 'https://bscscan.com',
        97: 'https://testnet.bscscan.com',
        137: 'https://polygonscan.com',
        80001: 'https://mumbai.polygonscan.com',
        43114: 'https://snowtrace.io',
        43113: 'https://testnet.snowtrace.io',
        11155111: 'https://sepolia.etherscan.io'
      };
      return explorers[chainId] || '';
    }
    
    // Fun√ß√£o para exportar o recibo como texto
    function exportReceipt() {
      try {
        // Cria um texto formatado com as informa√ß√µes do recibo
        const txHash = document.getElementById('tx-hash').textContent;
        const txNetwork = document.getElementById('tx-network').textContent;
        const txTimestamp = document.getElementById('tx-timestamp').textContent;
        const tokenAddress = document.getElementById('token-address').textContent;
        const tokenName = document.getElementById('token-name').textContent;
        const paymentMethod = document.getElementById('payment-method').textContent;
        const paymentAmount = document.getElementById('payment-amount').textContent;
        const tokensReceived = document.getElementById('tokens-received').textContent;
        const tokenPrice = document.getElementById('token-price').textContent;
        const buyerWallet = document.getElementById('buyer-wallet').textContent;
        const receiverWallet = document.getElementById('receiver-wallet').textContent;
        
        const receiptText = `RECIBO DE TRANSA√á√ÉO
===================
Data/Hora: ${txTimestamp}
Rede: ${txNetwork}
Hash da Transa√ß√£o: ${txHash}
Status: Sucesso

DETALHES DO TOKEN
===================
Contrato: ${tokenAddress}
Token: ${tokenName}

DETALHES DO PAGAMENTO
===================
M√©todo: ${paymentMethod}
Valor Pago: ${paymentAmount}
Tokens Recebidos: ${tokensReceived}
Pre√ßo por Token: ${tokenPrice}

CARTEIRAS
===================
Sua Carteira: ${buyerWallet}
Carteira Recebedora: ${receiverWallet}

Este recibo serve como comprovante da transa√ß√£o realizada.
TokenCafe - ${new Date().toISOString().split('T')[0]}
`;
        
        // Cria um blob e faz o download
        const blob = new Blob([receiptText], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `recibo-transacao-${Date.now()}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        showStatus('Recibo exportado com sucesso!', 'success');
      } catch (error) {
        console.error('Erro ao exportar recibo:', error);
        showStatus('Erro ao exportar recibo.', 'error');
      }
    }
    
    // Fun√ß√£o para capturar saldos das carteiras e contrato com fallback robusto
    async function captureBalances(buyerAddress, receiverAddress) {
      console.log('üîç [DEBUG] Iniciando captureBalances');
      console.log('   - Comprador:', buyerAddress);
      console.log('   - Recebedor:', receiverAddress);
      console.log('   - Token:', CONFIG.saleToken.address);
      
      const balances = {
        buyerBnb: 'N/A',
        receiverBnb: 'N/A',
        buyerTokens: 'N/A',
        contractTokens: 'N/A'
      };

      // Lista de RPCs de fallback para BSC Testnet
      const fallbackRpcs = [
        'https://data-seed-prebsc-1-s1.binance.org:8545/',
        'https://data-seed-prebsc-2-s1.binance.org:8545/',
        'https://data-seed-prebsc-1-s2.binance.org:8545/',
        'https://bsc-testnet.public.blastapi.io'
      ];

      // Fun√ß√£o para tentar capturar saldo BNB com retry e normaliza√ß√£o
      async function getBnbBalance(address, description) {
        let safeAddress;
        try {
          safeAddress = ethers.utils.getAddress(address);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Endere√ßo ${description} inv√°lido (checksum): ${address} ‚Äî ${err.message}`);
          return '0'; // fallback seguro
        }

        // Verifica√ß√£o de provider ativo
        if (!provider) {
          console.warn('‚ö†Ô∏è Provider RPC n√£o inicializado ‚Äî usando RPCs p√∫blicos para saldo BNB');
        } else {
          // Primeiro tenta com o provider atual (MetaMask)
          try {
            const balance = await provider.getBalance(safeAddress);
            return ethers.utils.formatEther(balance);
          } catch (error) {
            console.warn(`Erro ao obter saldo BNB ${description} via provider atual:`, error.message);
          }
        }

        // Fallback para RPCs diretos
        for (const rpcUrl of fallbackRpcs) {
          try {
            const fallbackProvider = new ethers.providers.JsonRpcProvider(rpcUrl);
            const balance = await fallbackProvider.getBalance(safeAddress);
            console.log(`Saldo BNB ${description} obtido via fallback RPC: ${rpcUrl}`);
            return ethers.utils.formatEther(balance);
          } catch (error) {
            console.warn(`Erro ao obter saldo BNB ${description} via ${rpcUrl}:`, error.message);
            continue;
          }
        }

        console.error(`N√£o foi poss√≠vel obter saldo BNB ${description} ap√≥s todos os fallbacks`);
        return '0'; // fallback seguro
      }

      // Fun√ß√£o para tentar capturar saldo de token com retry
      async function getTokenBalance(address, description, isContract = false) {
        console.log(`ü™ô [DEBUG] Obtendo saldo de token ${description}`);
        console.log(`   - Endere√ßo alvo: ${isContract ? CONFIG.saleToken.address : address}`);
        console.log(`   - √â contrato: ${isContract}`);
        
        if (!CONFIG.saleToken.address) {
          console.log('‚ö†Ô∏è [DEBUG] Endere√ßo do token n√£o configurado');
          return '0';
        }

        // Normaliza endere√ßos envolvidos
        let tokenAddr;
        let targetAddress;
        try {
          tokenAddr = ethers.utils.getAddress(CONFIG.saleToken.address);
          targetAddress = ethers.utils.getAddress(isContract ? CONFIG.saleToken.address : address);
        } catch (err) {
          console.warn(`‚ö†Ô∏è Endere√ßo inv√°lido ao obter saldo de token (${description}): ${err.message}`);
          return 'N/A';
        }

        // Primeiro tenta com o provider atual (MetaMask)
        try {
          const tokenContract = new ethers.Contract(
            tokenAddr,
            ['function balanceOf(address owner) view returns (uint256)'],
            provider
          );
          const balance = await tokenContract.balanceOf(targetAddress);
          const formattedBalance = ethers.utils.formatUnits(balance, CONFIG.saleToken.decimals);
          console.log(`‚úÖ [DEBUG] Saldo de token ${description} via MetaMask: ${formattedBalance}`);
          return formattedBalance;
        } catch (error) {
          console.warn(`‚ùå [DEBUG] Erro ao obter saldo de token ${description} via MetaMask:`, error.message);
        }

        // Fallback para RPCs diretos
        for (const rpcUrl of fallbackRpcs) {
          try {
            const fallbackProvider = new ethers.providers.JsonRpcProvider(rpcUrl);
            const tokenContract = new ethers.Contract(
              tokenAddr,
              ['function balanceOf(address owner) view returns (uint256)'],
              fallbackProvider
            );
            const balance = await tokenContract.balanceOf(targetAddress);
            console.log(`Saldo de token ${description} obtido via fallback RPC: ${rpcUrl}`);
            return ethers.utils.formatUnits(balance, CONFIG.saleToken.decimals);
          } catch (error) {
            console.warn(`Erro ao obter saldo de token ${description} via ${rpcUrl}:`, error.message);
            continue;
          }
        }

        console.error(`N√£o foi poss√≠vel obter saldo de token ${description} ap√≥s todos os fallbacks`);
        return 'N/A';
      }

      // Captura saldos de forma ass√≠ncrona e independente
      try {
        console.log('Iniciando captura de saldos...');
        
        // Executa todas as capturas em paralelo com timeout
        const promises = [
          getBnbBalance(buyerAddress, 'do comprador'),
          getBnbBalance(receiverAddress, 'do recebedor'),
          getTokenBalance(buyerAddress, 'do comprador'),
          getTokenBalance(CONFIG.saleToken.address, 'do contrato', true)
        ];

        // Aguarda todas as promessas com timeout de 10 segundos cada
        const results = await Promise.allSettled(
          promises.map(promise => 
            Promise.race([
              promise,
              new Promise((_, reject) => 
                setTimeout(() => reject(new Error('Timeout')), 10000)
              )
            ])
          )
        );

        // Processa os resultados
        if (results[0].status === 'fulfilled') {
          balances.buyerBnb = results[0].value;
          console.log('üí∞ [DEBUG] BNB do comprador:', results[0].value);
        } else {
          console.log('‚ùå [DEBUG] Falha ao obter BNB do comprador:', results[0].reason);
          balances.buyerBnb = '0';
        }
        
        if (results[1].status === 'fulfilled') {
          balances.receiverBnb = results[1].value;
          console.log('üè¶ [DEBUG] BNB do recebedor:', results[1].value);
        } else {
          console.log('‚ùå [DEBUG] Falha ao obter BNB do recebedor:', results[1].reason);
          balances.receiverBnb = '0';
        }
        
        if (results[2].status === 'fulfilled') {
          balances.buyerTokens = results[2].value;
          console.log('ü™ô [DEBUG] Tokens do comprador:', results[2].value, CONFIG.saleToken.symbol);
        } else {
          console.log('‚ùå [DEBUG] Falha ao obter tokens do comprador:', results[2].reason);
        }
        
        if (results[3].status === 'fulfilled') {
          balances.contractTokens = results[3].value;
          console.log('üì¶ [DEBUG] Tokens do contrato:', results[3].value, CONFIG.saleToken.symbol);
        } else {
          console.log('‚ùå [DEBUG] Falha ao obter tokens do contrato:', results[3].reason);
        }

        console.log('‚úÖ [DEBUG] Captura de saldos conclu√≠da:', balances);
        
      } catch (error) {
        console.error('Erro geral na captura de saldos:', error);
      }

      return balances;
    }

    // Fun√ß√£o para exibir o recibo da transa√ß√£o
    async function showTransactionReceipt(tx, modo, quantidade, total, balancesBefore, balancesAfter, tokenTx = null, tokenStatus = 'Sucesso') {
      try {
        // Garante que o painel de progresso exista
        ensureProgressLog();
        appendProgress('Gerando recibo da transa√ß√£o‚Ä¶', 'info');

        // Obt√©m informa√ß√µes da rede atual
        const network = await provider.getNetwork();
        const networkName = getNetworkName(network.chainId);
        const isTestnet = isTestNetwork(network.chainId);
        const explorerUrl = getExplorerUrl(network.chainId);
        
        // Preenche os dados do recibo
        document.getElementById('tx-hash').textContent = tx.hash;
        if (explorerUrl) {
          document.getElementById('tx-explorer-link').href = `${explorerUrl}/tx/${tx.hash}`;
          document.getElementById('tx-explorer-link').style.display = 'inline';
        } else {
          document.getElementById('tx-explorer-link').style.display = 'none';
        }
        
        document.getElementById('tx-status').textContent = 'Sucesso';
        document.getElementById('tx-network').textContent = `${networkName} ${isTestnet ? '(Testnet)' : '(Mainnet)'}`;
        document.getElementById('tx-timestamp').textContent = new Date().toLocaleString();
        
        document.getElementById('token-address').textContent = CONFIG.saleToken.address;
        if (explorerUrl) {
          document.getElementById('token-explorer-link').href = `${explorerUrl}/token/${CONFIG.saleToken.address}`;
          document.getElementById('token-explorer-link').style.display = 'inline';
        } else {
          document.getElementById('token-explorer-link').style.display = 'none';
        }
        document.getElementById('token-name').textContent = `${CONFIG.saleToken.symbol} (${CONFIG.saleToken.decimals} decimais)`;
        
        // Preenche informa√ß√µes da transa√ß√£o de tokens
        if (tokenTx) {
          // Caso com transa√ß√£o de tokens (via contrato de venda)
          document.getElementById('token-tx-hash').textContent = tokenTx.hash;
          if (explorerUrl) {
            document.getElementById('token-tx-explorer-link').href = `${explorerUrl}/tx/${tokenTx.hash}`;
            document.getElementById('token-tx-explorer-link').style.display = 'inline';
          } else {
            document.getElementById('token-tx-explorer-link').style.display = 'none';
          }
          
          const tokenStatusElement = document.getElementById('token-tx-status');
          const tokenNotesElement = document.getElementById('token-tx-notes');
          
          // Calcular diferen√ßa de tokens com base nos saldos
          let tokensDiff = null;
          const before = parseFloat(balancesBefore?.buyerTokens);
          const after = parseFloat(balancesAfter?.buyerTokens);
          if (!isNaN(before) && !isNaN(after)) {
            tokensDiff = after - before;
          }

          if (tokensDiff !== null && tokensDiff > 0) {
            tokenStatusElement.className = 'badge bg-success';
            tokenStatusElement.textContent = 'Sucesso';
            tokenNotesElement.textContent = `${quantidade} ${CONFIG.saleToken.symbol} transferidos automaticamente via contrato`;
          } else {
            // Tokens n√£o detectados ap√≥s a confirma√ß√£o
            tokenStatusElement.className = 'badge bg-warning';
            tokenStatusElement.textContent = 'Pendente';
            tokenNotesElement.innerHTML = `
              <strong>Tokens n√£o detectados ap√≥s a confirma√ß√£o.</strong><br>
              ‚Ä¢ Poss√≠veis causas: contrato sem saldo, venda pausada, regras de compra inv√°lidas<br>
              ‚Ä¢ A√ß√µes necess√°rias: reabastecer o contrato ou transferir tokens manualmente ao comprador
            `;
          }
        } else {
          // Caso de transfer√™ncia manual (fluxo padr√£o)
          document.getElementById('token-tx-hash').textContent = 'Transfer√™ncia Manual';
          document.getElementById('token-tx-explorer-link').style.display = 'none';
          
          const tokenStatusElement = document.getElementById('token-tx-status');
          const tokenNotesElement = document.getElementById('token-tx-notes');
          
          if (tokenStatus && tokenStatus.includes('Pagamento Confirmado')) {
            tokenStatusElement.className = 'badge bg-info';
            tokenStatusElement.textContent = 'Pendente';
            tokenNotesElement.innerHTML = `
              <strong>Transfer√™ncia Manual Necess√°ria:</strong><br>
              ‚Ä¢ O vendedor transferir√° ${quantidade} ${CONFIG.saleToken.symbol} manualmente<br>
              ‚Ä¢ Aguarde alguns minutos e verifique sua carteira<br>
              ‚Ä¢ Se o contrato estiver sem saldo, reabaste√ßa e confirme a entrega
            `;
          } else {
            tokenStatusElement.className = 'badge bg-warning';
            tokenStatusElement.textContent = 'N√£o executada';
            tokenNotesElement.textContent = 'Transfer√™ncia de tokens n√£o foi executada';
          }
        }
        
        document.getElementById('payment-method').textContent = 'BNB';
        document.getElementById('payment-amount').textContent = `${total.toFixed(6)} BNB`;
        document.getElementById('tokens-received').textContent = `${quantidade} ${CONFIG.saleToken.symbol}`;
        document.getElementById('token-price').textContent = `${(total / quantidade).toFixed(6)} BNB`;
        
        // Fun√ß√£o auxiliar para formatar saldos
        function formatBalance(balance, symbol = '') {
          if (balance === 'N/A' || balance === null || balance === undefined) {
            return 'N/A';
          }
          const numBalance = parseFloat(balance);
          if (isNaN(numBalance)) {
            return 'N/A';
          }
          return symbol ? `${numBalance.toFixed(symbol === 'BNB' ? 6 : 2)} ${symbol}` : numBalance.toFixed(6);
        }

        // Preenche os saldos antes da transa√ß√£o
        if (balancesBefore) {
          document.getElementById('buyer-bnb-before').textContent = formatBalance(balancesBefore.buyerBnb, 'BNB');
          document.getElementById('receiver-bnb-before').textContent = formatBalance(balancesBefore.receiverBnb, 'BNB');
          document.getElementById('buyer-tokens-before').textContent = formatBalance(balancesBefore.buyerTokens, CONFIG.saleToken.symbol);
          document.getElementById('contract-tokens-before').textContent = formatBalance(balancesBefore.contractTokens, CONFIG.saleToken.symbol);
        }
        
        // Preenche os saldos depois da transa√ß√£o
        if (balancesAfter) {
          document.getElementById('buyer-bnb-after').textContent = formatBalance(balancesAfter.buyerBnb, 'BNB');
          document.getElementById('receiver-bnb-after').textContent = formatBalance(balancesAfter.receiverBnb, 'BNB');
          document.getElementById('buyer-tokens-after').textContent = formatBalance(balancesAfter.buyerTokens, CONFIG.saleToken.symbol);
          document.getElementById('contract-tokens-after').textContent = formatBalance(balancesAfter.contractTokens, CONFIG.saleToken.symbol);
        }

        document.getElementById('buyer-wallet').textContent = userAddress;
        document.getElementById('receiver-wallet').textContent = CONFIG.walletRecebedora;
        
        // Adiciona evento para exportar o recibo
        document.getElementById('btn-export-receipt').addEventListener('click', exportReceipt);
        
        // Exibe o recibo
        document.getElementById('transaction-receipt').style.display = 'block';
        
        // Rola a p√°gina para o recibo
        document.getElementById('transaction-receipt').scrollIntoView({ behavior: 'smooth' });

        appendProgress('Recibo gerado e exibido na tela.', 'success');
      } catch (error) {
        console.error('Erro ao exibir recibo:', error);
        showStatus('Erro ao gerar recibo da transa√ß√£o.', 'error');
        appendProgress('Erro ao gerar recibo: ' + (error?.message || 'desconhecido'), 'error');
      }
    }

    // ===== Painel de Progresso (UI) =====
    function ensureProgressLog() {
      try {
        let container = document.getElementById('progress-log');
        if (!container) {
          container = document.createElement('div');
          container.id = 'progress-log';
          container.className = 'widget-container mt-3';
          container.innerHTML = `
            <h5 class="mb-2">Progresso da Compra</h5>
            <div id="progress-log-entries" style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; border-radius: 6px; padding: 8px; background: #fafafa;"></div>
          `;
          // Inserir antes do recibo, se existir; caso contr√°rio, adiciona ao final do body
          const receipt = document.getElementById('transaction-receipt');
          if (receipt && receipt.parentNode) {
            receipt.parentNode.insertBefore(container, receipt);
          } else {
            document.body.appendChild(container);
          }
        }
      } catch (e) {
        console.warn('Falha ao garantir painel de progresso:', e);
      }
    }

    function clearProgressLog() {
      try {
        const entries = document.getElementById('progress-log-entries');
        if (entries) entries.innerHTML = '';
      } catch (e) {
        console.warn('Falha ao limpar painel de progresso:', e);
      }
    }

    function appendProgress(message, status = 'info') {
      try {
        ensureProgressLog();
        const entries = document.getElementById('progress-log-entries');
        if (!entries) return;
        const row = document.createElement('div');
        const badgeClass = status === 'success' ? 'bg-success' : status === 'warning' ? 'bg-warning' : status === 'error' ? 'bg-danger' : 'bg-secondary';
        row.className = 'd-flex align-items-start mb-2';
        row.innerHTML = `
          <span class="badge ${badgeClass} me-2">${status.toUpperCase()}</span>
          <span class="flex-grow-1">${message}</span>
        `;
        entries.appendChild(row);
        // Scroll para o fim
        entries.scrollTop = entries.scrollHeight;
      } catch (e) {
        console.warn('Falha ao adicionar progresso:', e);
      }
    }

    function decodeRevertMessage(err) {
      try {
        // Tenta extrair mensagens comuns de revert
        const m = String(err?.message || '').toLowerCase();
        if (m.includes('execution reverted')) {
          // Extrai ap√≥s 'execution reverted: '
          const idx = m.indexOf('execution reverted');
          const colon = m.indexOf(':', idx);
          if (colon > -1) {
            return err.message.substring(colon + 1).trim();
          }
          return 'execution reverted';
        }
        if (err?.reason) return err.reason;
        return null;
      } catch (_) {
        return null;
      }
    }

    // Fun√ß√£o para calcular limite de g√°s automaticamente
    function getAutoGasLimit(transactionType = 'transfer') {
      switch (transactionType) {
        case 'transfer':
          return 150000; // Para transfer√™ncias simples de tokens
        case 'contract':
          return 300000; // Para intera√ß√µes com contratos
        case 'payment':
          return 21000;  // Para transfer√™ncias de BNB
        default:
          return 200000; // Valor padr√£o
      }
    }

    // Fun√ß√£o para comprar tokens
    async function buyTokens() {
      try {
        // Inicia painel de progresso
        ensureProgressLog();
        clearProgressLog();
        appendProgress('Iniciando compra de tokens‚Ä¶', 'info');
        // Verifica se a carteira est√° conectada
        if (!signer) {
          showToast('Por favor, conecte sua carteira primeiro.', 'warning');
          appendProgress('Carteira n√£o conectada.', 'error');
          return;
        }
        // Verifica se o provider est√° ativo
        if (!provider) {
          showToast('Provider RPC n√£o inicializado. Conecte a carteira novamente.', 'error');
          appendProgress('Provider RPC n√£o inicializado.', 'error');
          return;
        }
        // Loga rede da carteira para diagn√≥stico e orienta em caso de diverg√™ncia
        try {
          const net = await provider.getNetwork();
          console.log(`üîó [DEBUG] Rede da carteira: chainId=${net.chainId} name=${net.name}`);
          appendProgress(`Carteira conectada na rede chainId=${net.chainId}.`, 'success');
        } catch (netErr) {
          console.warn('‚ö†Ô∏è [DEBUG] Falha ao obter rede da carteira:', netErr);
          showToast('N√£o foi poss√≠vel identificar a rede da carteira. Verifique se a carteira est√° conectada √† rede correta (ex.: BSC Testnet).', 'warning');
          appendProgress('Falha ao identificar a rede da carteira.', 'warning');
        }
        
        const quantidade = parseInt(document.getElementById('quantidade').value) || 0;
        const conf = CONFIG.bnbTestnet;
        
        // Verifica se a quantidade est√° dentro dos limites
        if (quantidade < CONFIG.minCompra) {
          showToast(`A quantidade m√≠nima √© ${CONFIG.minCompra} tokens.`, 'warning');
          appendProgress(`Quantidade abaixo do m√≠nimo (${CONFIG.minCompra}).`, 'warning');
          return;
        }
        
        if (quantidade > CONFIG.maxCompra) {
          showToast(`A quantidade m√°xima √© ${CONFIG.maxCompra} tokens.`, 'warning');
          appendProgress(`Quantidade acima do m√°ximo (${CONFIG.maxCompra}).`, 'warning');
          return;
        }
        
        // Verifica se a quantidade n√£o excede o saldo do contrato
        const contractBalance = CONFIG.contractBalance || 0;
        if (contractBalance > 0 && quantidade > contractBalance) {
          showToast(`A quantidade solicitada (${quantidade}) excede o saldo dispon√≠vel no contrato (${contractBalance.toLocaleString()} tokens).`, 'warning');
          appendProgress('Quantidade excede o saldo de tokens do contrato.', 'warning');
          return;
        }

        // Verifica√ß√£o de limite por carteira (UI + leitura do saldo atual do token)
        try {
          const perWalletCap = (typeof CONFIG.maxCompraPorCarteira === 'number' && CONFIG.maxCompraPorCarteira > 0)
            ? CONFIG.maxCompraPorCarteira
            : (typeof CONFIG.maxCompra === 'number' ? CONFIG.maxCompra : null);

          if (perWalletCap && CONFIG.saleToken && CONFIG.saleToken.address) {
            const buyerAddr = await signer.getAddress();
            const currentBalanceStr = await getTokenBalance(buyerAddr, 'comprador');
            const currentBalanceNum = parseFloat(currentBalanceStr) || 0;
            const projected = currentBalanceNum + quantidade;

            if (projected > perWalletCap) {
              const remaining = Math.max(perWalletCap - currentBalanceNum, 0);
              showToast(`Limite por carteira: m√°ximo ${perWalletCap} ${CONFIG.saleToken.symbol}. Dispon√≠vel para compra agora: ${remaining.toFixed(0)} ${CONFIG.saleToken.symbol}.`, 'warning');
              appendProgress(`Compra bloqueada: limite por carteira excedido (cap=${perWalletCap}, atual=${currentBalanceNum}, solicitada=${quantidade}).`, 'error');
              return;
            }
          }
        } catch (capErr2) {
          console.warn('Falha na checagem de limite por carteira em buyTokens:', capErr2);
        }
        
        // Verifica a rede atual e tenta mudar automaticamente se necess√°rio
        const network = await provider.getNetwork();
        const correctNetwork = 97; // 97 = BSC Testnet
        if (network.chainId !== correctNetwork) {
          const networkName = 'BSC Testnet (ChainID: 97)';
          showToast(`Mudando para a rede ${networkName}...`, 'info');
          appendProgress(`Tentando mudar para ${networkName}‚Ä¶`, 'info');
          try {
            await window.ethereum.request({
              method: 'wallet_switchEthereumChain',
              params: [{ chainId: '0x61' }], // 0x61 = 97
            });
            // Recria provider/signer ap√≥s mudan√ßa de rede
            provider = new ethers.providers.Web3Provider(window.ethereum, 'any');
            signer = provider.getSigner();
            showToast(`Rede alterada para ${networkName}`, 'success');
            appendProgress(`Rede alterada para ${networkName}.`, 'success');
          } catch (switchError) {
            if (switchError.code === 4902) {
              try {
                await window.ethereum.request({
                  method: 'wallet_addEthereumChain',
                  params: [{
                    chainId: '0x61',
                    chainName: 'BSC Testnet',
                    nativeCurrency: { name: 'BNB', symbol: 'BNB', decimals: 18 },
                    rpcUrls: CONFIG.bnbTestnet.rpcUrls,
                    blockExplorerUrls: [CONFIG.bnbTestnet.blockExplorer]
                  }]
                });
                provider = new ethers.providers.Web3Provider(window.ethereum, 'any');
                signer = provider.getSigner();
                showToast(`Rede BSC Testnet adicionada e selecionada`, 'success');
                appendProgress('Rede BSC Testnet adicionada e selecionada.', 'success');
              } catch (addError) {
                showToast(`N√£o foi poss√≠vel adicionar a rede ${networkName}. Por favor, adicione manualmente.`, 'error');
                appendProgress('Falha ao adicionar rede BSC Testnet.', 'error');
                return;
              }
            } else {
              showToast(`N√£o foi poss√≠vel mudar para a rede ${networkName}. Por favor, mude manualmente.`, 'error');
              appendProgress('Falha ao mudar de rede.', 'error');
              return;
            }
          }
        }
        
        // Calcula o valor total a ser pago (ser√° baseado no pre√ßo do contrato)
        appendProgress(`Calculando total com pre√ßo do contrato‚Ä¶`, 'info');
        
        // Captura endere√ßo do comprador de forma segura
        const buyerAddressRaw = await signer.getAddress();
        const buyerAddress = safeGetAddress(buyerAddressRaw);
        if (!buyerAddress) {
          showToast('Endere√ßo do comprador inv√°lido (checksum).', 'error');
          appendProgress('Endere√ßo do comprador inv√°lido (checksum).', 'error');
          return;
        }
        
        // Verifica o saldo antes da transa√ß√£o via RPCs p√∫blicos (evita -32603 da carteira)
        let balanceFormatted = '0';
        try {
          const balanceWei = await retryWithProviders(async (currentProvider) => {
            return await currentProvider.getBalance(buyerAddress);
          }, 8, true);
          balanceFormatted = ethers.utils.formatEther(balanceWei);
        } catch (balErr) {
          console.warn('‚ö†Ô∏è [DEBUG] Falha ao obter saldo via RPC p√∫blico:', balErr);
          showToast('N√£o foi poss√≠vel verificar seu saldo via RPC p√∫blico. Tente novamente.', 'warning');
          appendProgress('Falha ao verificar saldo via RPC p√∫blico.', 'warning');
        }
        
        if (parseFloat(balanceFormatted) < total) {
          showToast(`Saldo insuficiente. Voc√™ tem ${balanceFormatted} BNB, mas precisa de ${total.toFixed(6)} BNB.`, 'error');
           appendProgress(`Saldo insuficiente: ${balanceFormatted} BNB < ${total.toFixed(6)} BNB.`, 'error');
          return;
        }

        // Captura saldos ANTES da transa√ß√£o
        showToast('Capturando saldos antes da transa√ß√£o...', 'info');
        appendProgress('Capturando saldos antes da transa√ß√£o‚Ä¶', 'info');
        console.log('üîç [DEBUG] Iniciando captura de saldos antes da transa√ß√£o');
        // buyerAddress j√° obtido acima
        const receiverAddress = safeGetAddress(CONFIG.walletRecebedora);
        if (!receiverAddress) {
          showToast('Endere√ßo da carteira recebedora inv√°lido (checksum).', 'error');
          appendProgress('Carteira recebedora inv√°lida (checksum).', 'error');
          return;
        }
        console.log('üë§ [DEBUG] Endere√ßo do comprador:', buyerAddress);
        console.log('üè¶ [DEBUG] Endere√ßo da carteira recebedora:', receiverAddress);
        
        const balancesBefore = await captureBalances(buyerAddress, receiverAddress);
        console.log('üìä [DEBUG] Saldos antes da transa√ß√£o:', balancesBefore);
        appendProgress('Saldos capturados (antes).', 'success');
        
        // Desabilita o bot√£o de compra durante a transa√ß√£o
        document.getElementById('btnComprar').disabled = true;
        showToast('Processando transa√ß√£o...', 'info');
        appendProgress('Processando transa√ß√£o‚Ä¶', 'info');
        
        let tx;
        
        // Converte o valor para a unidade correta (com decimais)
        const valorComDecimals = ethers.utils.parseEther(total.toString());
        
        // Verifica se deve usar o contrato de venda
        const saleContractAddress = CONFIG.saleContractAddress;
        const normalizedSaleContractAddress = safeGetAddress(saleContractAddress || '');
        console.log('üè™ [DEBUG] Endere√ßo do contrato de venda configurado:', saleContractAddress);
        appendProgress('Modo contrato: validando par√¢metros e ambiente‚Ä¶', 'info');
        
        try {
          if (normalizedSaleContractAddress) {
            // Usar contrato de venda (transa√ß√£o √∫nica autom√°tica)
            showToast('üöÄ Comprando tokens via contrato autom√°tico...', 'info');
            console.log('üí∞ [DEBUG] Iniciando transa√ß√£o √∫nica via contrato TokenSale');
            console.log('üì¶ [DEBUG] Quantidade de tokens:', quantidade);
            console.log('üíµ [DEBUG] Valor total calculado:', total, 'BNB');
            console.log('üè™ [DEBUG] Contrato de venda:', normalizedSaleContractAddress);
            
            const saleContract = new ethers.Contract(
              normalizedSaleContractAddress,
              [
                'function buy(uint256 quantity) payable'
              ],
              signer
            );
            
            // Verifica informa√ß√µes do contrato com retry/backoff e fallback de providers
            try {
              const contractPrice = await retryWithProviders(async (currentProvider) => {
                const c = new ethers.Contract(
                  normalizedSaleContractAddress,
                  ['function bnbPrice() view returns (uint256)'],
                  currentProvider
                );
                return await c.bnbPrice();
              }, 8, true);

              const tokenAddress = await retryWithProviders(async (currentProvider) => {
                const c = new ethers.Contract(
                  normalizedSaleContractAddress,
                  ['function saleToken() view returns (address)'],
                  currentProvider
                );
                return await c.saleToken();
              }, 8, true);

              const destinationWallet = await retryWithProviders(async (currentProvider) => {
                const c = new ethers.Contract(
                  normalizedSaleContractAddress,
                  ['function destinationWallet() view returns (address)'],
                  currentProvider
                );
                return await c.destinationWallet();
              }, 8, true);
              
              console.log(`üíé [DEBUG] Pre√ßo no contrato: ${ethers.utils.formatEther(contractPrice)} BNB por token`);
              console.log(`ü™ô [DEBUG] Token do contrato: ${tokenAddress}`);
              CONFIG.saleToken.address = safeGetAddress(tokenAddress);
              try { await updateCapInfoDisplay(); } catch {}
              console.log(`üí∞ [DEBUG] Carteira de destino: ${destinationWallet}`);
              appendProgress('Dados do contrato obtidos (pre√ßo, token, destino).', 'success');

              // Leitura do limite por carteira (perWalletCap)
              try {
                const cCap = await retryWithProviders(async (currentProvider) => {
                  const c = new ethers.Contract(
                    normalizedSaleContractAddress,
                    ['function perWalletCap() view returns (uint256)'],
                    currentProvider
                  );
                  return await c.perWalletCap();
                }, 8, true);
                const capNum = parseInt(cCap.toString());
                if (!isNaN(capNum)) {
                  CONFIG.maxCompraPorCarteira = capNum;
                  console.log(`‚öñÔ∏è [DEBUG] Limite por carteira detectado: ${capNum}`);
                }
              } catch (capErr) {
                console.log('‚ÑπÔ∏è Contrato n√£o possui perWalletCap() ou leitura falhou. Fallback em uso.');
              }

              try { await updateCapInfoDisplay(); } catch {}

              // Valida√ß√£o expl√≠cita da carteira de destino
              const destNorm = safeGetAddress(destinationWallet || '');
              if (!destNorm) {
                showToast('Carteira de destino inv√°lida/sem checksum no contrato.', 'error');
                throw new Error('destinationWallet inv√°lida');
              }
              if (destNorm.toLowerCase() === '0x0000000000000000000000000000000000000000') {
                showToast('Carteira de destino n√£o configurada (0x0) no contrato.', 'error');
                console.warn('Destino 0x0 detectado no contrato de venda. Atualize destinationWallet.');
                throw new Error('destinationWallet zero');
              }
              if (destNorm.toLowerCase() === normalizedSaleContractAddress.toLowerCase()) {
                showToast('Carteira de destino n√£o pode ser o pr√≥prio contrato de venda.', 'error');
                console.warn('destinationWallet == saleContractAddress. Isso pode causar falhas internas.');
                throw new Error('destinationWallet √© o pr√≥prio contrato');
              }
              appendProgress('Carteira de destino validada.', 'success');

              // Normaliza o endere√ßo do token retornado pelo contrato
              const normalizedTokenAddress = safeGetAddress(tokenAddress || '');
              if (!normalizedTokenAddress) {
                throw new Error('Endere√ßo de token inv√°lido retornado pelo contrato');
              }

              // Pr√©-checagem: garantir que o token √© contrato v√°lido
              const tokenCode = await retryWithProviders(async (currentProvider) => {
                return await currentProvider.getCode(normalizedTokenAddress);
              }, 8, true);
              if (!tokenCode || tokenCode === '0x') {
                showToast('‚ùå Endere√ßo do token no contrato n√£o √© um contrato v√°lido.', 'error');
                throw new Error('Endere√ßo do token n√£o √© contrato ERC-20');
              }
              appendProgress('Token do contrato validado (ERC-20).', 'success');
              
              // Detecta automaticamente decimais e s√≠mbolo do token
              const tokenMeta = await retryWithProviders(async (currentProvider) => {
                const t = new ethers.Contract(
                  normalizedTokenAddress,
                  ['function decimals() view returns (uint8)', 'function symbol() view returns (string)'],
                  currentProvider
                );
                const [dec, sym] = await Promise.all([t.decimals(), t.symbol()]);
                return { dec, sym };
              }, 8, true);
              const tokenDecimalsDetected = tokenMeta.dec;
              const tokenSymbolDetected = tokenMeta.sym;
              if (typeof tokenDecimalsDetected === 'number' && tokenDecimalsDetected >= 0 && tokenDecimalsDetected <= 18) {
                CONFIG.saleToken.decimals = tokenDecimalsDetected;
              }
              if (typeof tokenSymbolDetected === 'string' && tokenSymbolDetected.length > 0) {
                CONFIG.saleToken.symbol = tokenSymbolDetected;
              }
              appendProgress(`Decimais detectados: ${CONFIG.saleToken.decimals} | S√≠mbolo: ${CONFIG.saleToken.symbol}`, 'info');
window._contractPrice = contractPrice;
 const precoEl = document.getElementById('preco');
 if (precoEl) {
   const priceBNB = ethers.utils.formatEther(contractPrice);
   precoEl.textContent = `${priceBNB} BNB`;
 }
 try {
   if (typeof updateIntermediateEstimateFromState === 'function') {
     updateIntermediateEstimateFromState();
   }
 } catch (e) {
   console.warn('Falha ao atualizar estimativa ap√≥s leitura de pre√ßo:', e);
 }
              
              // Pr√©-checagem: carteira de destino deve ser EOA (sem c√≥digo)
              const destinationCode = await retryWithProviders(async (currentProvider) => {
                const destNorm = safeGetAddress(destinationWallet || '');
                return destNorm ? await currentProvider.getCode(destNorm) : '0x';
              }, 8, true);
              if (destinationCode && destinationCode !== '0x') {
                showToast('‚ö†Ô∏è Carteira de destino √© um contrato e pode recusar BNB. Use um endere√ßo EOA.', 'warning');
                throw new Error('Carteira de destino n√£o aceita BNB (contrato sem receive/fallback payable)');
              }
              
              // Calcula candidatos de valor (humano vs unidades base)
              const quantidadeUnits = ethers.utils.parseUnits(quantidade.toString(), CONFIG.saleToken.decimals);
              const expectedValueHuman = contractPrice.mul(ethers.BigNumber.from(quantidade.toString()));
              const expectedValueUnits = contractPrice.mul(quantidadeUnits);
              console.log(`üí∞ [DEBUG] Valor humano (price*qty): ${ethers.utils.formatEther(expectedValueHuman)} BNB`);
              console.log(`üí∞ [DEBUG] Valor unidades (price*qtyUnits): ${ethers.utils.formatEther(expectedValueUnits)} BNB`);
              const totalHumanBNBPreview = parseFloat(ethers.utils.formatEther(expectedValueHuman));
              const totalUnitsBNBPreview = parseFloat(ethers.utils.formatEther(expectedValueUnits));
              const estimatedTotalsEl = document.getElementById('estimatedTotals');
const symbol = (CONFIG && CONFIG.saleToken && CONFIG.saleToken.symbol) ? CONFIG.saleToken.symbol : 'TOKEN';
const decimalsInfo = (CONFIG && CONFIG.saleToken && typeof CONFIG.saleToken.decimals === 'number') ? CONFIG.saleToken.decimals : '‚Äî';
const estimateText = `${totalHumanBNBPreview.toFixed(6)} BNB (${quantidade} ${symbol}, modo humano) | ${totalUnitsBNBPreview.toFixed(6)} BNB (unidades base, decimais ${decimalsInfo})`;
if (estimatedTotalsEl) estimatedTotalsEl.textContent = estimateText;
appendProgress(`Estimativa intermedi√°ria: ${estimateText}`, 'info');
showToast(`Estimativa: ${estimateText}`, 'info');
              
              // Verifica se o contrato tem tokens suficientes
              // Usar RPCs p√∫blicos para leitura (evita depender do MetaMask para chamadas de leitura)
              const contractTokenBalance = await retryWithProviders(async (currentProvider) => {
                const tokenContract = new ethers.Contract(
                  normalizedTokenAddress,
                  ['function balanceOf(address account) view returns (uint256)'],
                  currentProvider
                );
                return await tokenContract.balanceOf(normalizedSaleContractAddress);
              }, 8, true);
              const contractTokenBalanceFormatted = ethers.utils.formatUnits(contractTokenBalance, CONFIG.saleToken.decimals);
              
              console.log(`üì¶ [DEBUG] Saldo de tokens no contrato: ${contractTokenBalanceFormatted} ${CONFIG.saleToken.symbol}`);

              // Mensagem espec√≠fica para saldo zero
              if (contractTokenBalance.eq(ethers.constants.Zero)) {
                showToast('‚ö†Ô∏è Contrato sem tokens dispon√≠veis para venda.', 'warning');
                throw new Error('Contrato sem tokens dispon√≠veis para venda');
              }
              
              if (contractTokenBalance.lt(ethers.utils.parseUnits(quantidade.toString(), CONFIG.saleToken.decimals))) {
                showToast(`‚ùå Contrato n√£o tem tokens suficientes. Dispon√≠vel: ${contractTokenBalanceFormatted} ${CONFIG.saleToken.symbol}`, 'error');
                throw new Error(`Contrato n√£o tem tokens suficientes. Dispon√≠vel: ${contractTokenBalanceFormatted} ${CONFIG.saleToken.symbol}`);
              }
              appendProgress(`Saldo do contrato: ${contractTokenBalanceFormatted} ${CONFIG.saleToken.symbol}.`, 'success');
              
              // Verifica se a quantidade solicitada √© v√°lida
              if (quantidade < CONFIG.minCompra || quantidade > CONFIG.maxCompra) {
                showToast(`‚ùå Quantidade inv√°lida. M√≠n: ${CONFIG.minCompra}, M√°x: ${CONFIG.maxCompra}`, 'error');
                throw new Error(`Quantidade deve estar entre ${CONFIG.minCompra} e ${CONFIG.maxCompra} tokens`);
              }
              
              showToast('‚úÖ Contrato validado! Enviando transa√ß√£o autom√°tica...', 'info');
              appendProgress('Contrato validado! Preparando pr√©-valida√ß√£o‚Ä¶', 'info');
              
              const gasLimit = CONFIG.gasLimit === 'auto' ? getAutoGasLimit('contract') : CONFIG.gasLimit;
              console.log('‚õΩ [DEBUG] Gas limit:', gasLimit);
              
              // Sele√ß√£o din√¢mica de quantidade/valor com callStatic
              let selectedQuantity = quantidade;
              let selectedValue = expectedValueHuman;
              try {
                await retryWithProviders(async (currentProvider) => {
                  const staticContract = new ethers.Contract(
                    normalizedSaleContractAddress,
                    ['function buy(uint256 quantity) payable'],
                    currentProvider
                  );
                  return await staticContract.callStatic.buy(quantidadeUnits, { value: expectedValueUnits, from: buyerAddress });
                }, 8, true);
                console.log('üß™ [DEBUG] Pr√©-v√¥o aprovado com unidades base');
                appendProgress('Pr√©-valida√ß√£o aprovada (quantidade em unidades base).', 'success');
                selectedQuantity = quantidadeUnits;
                selectedValue = expectedValueUnits;
                // Atualiza UI com modo efetivo e total calculado
                try {
                  const effectiveModeEl = document.getElementById('effectiveMode');
                  const totalEl = document.getElementById('total');
                  if (effectiveModeEl) {
                    const d = (CONFIG && CONFIG.saleToken && typeof CONFIG.saleToken.decimals === 'number') ? CONFIG.saleToken.decimals : '‚Äî';
                    effectiveModeEl.textContent = `unidades base (decimais ${d})`;
                  }
                  if (totalEl) {
                    const totalBNB = parseFloat(ethers.utils.formatEther(selectedValue));
                    totalEl.textContent = `${totalBNB.toFixed(6)} BNB`;
                  }
                } catch (uiErr) {
                  console.warn('Falha ao atualizar modo/total na UI:', uiErr);
                }
              } catch (preErrUnits) {
                console.warn('‚ö†Ô∏è [DEBUG] Pr√©-v√¥o com unidades base falhou:', preErrUnits);
                // Tenta com quantidade humana
                try {
                  await retryWithProviders(async (currentProvider) => {
                    const staticContract = new ethers.Contract(
                      normalizedSaleContractAddress,
                      ['function buy(uint256 quantity) payable'],
                      currentProvider
                    );
                    return await staticContract.callStatic.buy(quantidade, { value: expectedValueHuman, from: buyerAddress });
                  }, 8, true);
                  console.log('üß™ [DEBUG] Pr√©-v√¥o aprovado com quantidade humana');
                  appendProgress('Pr√©-valida√ß√£o aprovada (quantidade humana).', 'success');
                  selectedQuantity = quantidade;
                  selectedValue = expectedValueHuman;
                  try {
                    const effectiveModeEl = document.getElementById('effectiveMode');
                    const totalEl = document.getElementById('total');
                    if (effectiveModeEl) effectiveModeEl.textContent = 'quantidade humana';
                    if (totalEl) {
                      const totalBNB = parseFloat(ethers.utils.formatEther(selectedValue));
                      totalEl.textContent = `${totalBNB.toFixed(6)} BNB`;
                    }
                  } catch (uiErr) {
                    console.warn('Falha ao atualizar modo/total na UI:', uiErr);
                  }
                } catch (preErrHuman) {
                  console.warn('‚ùå [DEBUG] callStatic.buy falhou com ambas as abordagens:', preErrUnits, preErrHuman);
                  showToast('‚ùå Pr√©-valida√ß√£o falhou: contrato reverteu. Verifique pre√ßo, quantidade e carteira de destino.', 'error');
                  appendProgress('Pr√©-valida√ß√£o falhou: ' + (decodeRevertMessage(preErrHuman) || preErrHuman.message || 'revert'), 'error');
                  throw new Error(`Pr√©-valida√ß√£o do contrato falhou: ${preErrHuman.message}`);
                }
              }

              const totalBNB = parseFloat(ethers.utils.formatEther(selectedValue));
              appendProgress(`Total final via contrato: ${totalBNB.toFixed(6)} BNB`, 'info');

              // Chama a fun√ß√£o buy() do contrato que faz tudo automaticamente
              try {
                tx = await saleContract.buy(selectedQuantity, { value: selectedValue });
              } catch (sendErr) {
                if (sendErr && sendErr.code === 'UNPREDICTABLE_GAS_LIMIT') {
                  const manualGas = (typeof CONFIG.gasLimit === 'number' && CONFIG.gasLimit > 0) ? CONFIG.gasLimit : 250000;
                  showToast('‚ö†Ô∏è Estimativa de g√°s falhou. Aplicando gasLimit manual e reenviando...', 'warning');
                  console.warn('‚õΩ [DEBUG] Reenvio com gasLimit manual:', manualGas);
                  tx = await saleContract.buy(selectedQuantity, { value: selectedValue, gasLimit: manualGas });
                } else if (
                  sendErr && (
                    sendErr.code === -32603 ||
                    (typeof sendErr.message === 'string' && sendErr.message.includes('Internal JSON-RPC'))
                  )
                ) {
                  const manualGas = (typeof CONFIG.gasLimit === 'number' && CONFIG.gasLimit > 0) ? CONFIG.gasLimit : 250000;
                  showToast('‚ö†Ô∏è RPC da carteira retornou erro interno (-32603). Tentando com gasLimit manual‚Ä¶', 'warning');
                  console.warn('üõ†Ô∏è [DEBUG] MetaMask -32603 no envio. Tentativa com gasLimit manual:', manualGas, sendErr);
                  try {
                    tx = await saleContract.buy(selectedQuantity, { value: selectedValue, gasLimit: manualGas });
                  } catch (secondErr) {
                    console.error('‚ùå [DEBUG] Reenvio com gasLimit manual falhou:', secondErr);
                    showToast('Falha ao enviar via carteira (-32603). Troque a rede/RPC ou tente novamente.', 'error');
                    appendProgress('Falha no envio (-32603).', 'error');
                    throw secondErr;
                  }
                } else {
                  throw sendErr;
                }
              }

              showToast(`üéØ Transa√ß√£o autom√°tica enviada! Hash: ${tx.hash}`, 'info');
              appendProgress(`Transa√ß√£o enviada: ${tx.hash} | valor: ${ethers.utils.formatEther(selectedValue)} BNB`, 'info');
              console.log('‚úÖ [DEBUG] Transa√ß√£o √∫nica autom√°tica enviada:', tx.hash);
              console.log('üîÑ [DEBUG] O contrato far√° automaticamente:');
              console.log('   1. Receber o BNB');
              console.log('   2. Transferir tokens para o comprador');
              console.log('   3. Enviar BNB para a carteira de destino');
              

            } catch (contractError) {
              console.error('‚ùå [DEBUG] Erro ao validar contrato:', contractError);
              throw new Error(`Erro no contrato: ${contractError.message}`);
            }
            
          } else {
            // Transfer√™ncia direta de BNB para a carteira recebedora (m√©todo antigo)
            showToast('Enviando pagamento em BNB...', 'info');
            appendProgress('Enviando pagamento direto em BNB‚Ä¶', 'info');
            
            const gasLimit = CONFIG.gasLimit === 'auto' ? getAutoGasLimit('payment') : CONFIG.gasLimit;
            
            // Deixar a carteira estimar gas/price automaticamente
            try {
              tx = await signer.sendTransaction({
                to: receiverAddress,
                value: valorComDecimals
              });
            } catch (payErr) {
              if (
                payErr && (
                  payErr.code === -32603 ||
                  (typeof payErr.message === 'string' && payErr.message.includes('Internal JSON-RPC'))
                )
              ) {
                const manualGas = 21000; // transfer√™ncia simples
                showToast('‚ö†Ô∏è RPC da carteira retornou erro interno (-32603). Tentando pagamento com gasLimit manual‚Ä¶', 'warning');
                console.warn('üõ†Ô∏è [DEBUG] MetaMask -32603 em sendTransaction. Tentativa com gasLimit manual:', manualGas, payErr);
                tx = await signer.sendTransaction({
                  to: receiverAddress,
                  value: valorComDecimals,
                  gasLimit: manualGas
                });
              } else {
                throw payErr;
              }
            }
            
            showToast(`Pagamento enviado! Aguardando confirma√ß√£o...`, 'info');
            appendProgress('Pagamento enviado. Aguardando confirma√ß√µes‚Ä¶', 'info');
          }
        } catch (error) {
          console.error('Erro ao enviar transa√ß√£o:', error);
          
          if (error.code === 'INSUFFICIENT_FUNDS') {
            showToast('Saldo insuficiente para completar a transa√ß√£o.', 'error');
            appendProgress('Falha: saldo insuficiente.', 'error');
          } else if (error.code === 'CALL_EXCEPTION') {
            showToast('Transa√ß√£o rejeitada. Verifique os par√¢metros da transa√ß√£o.', 'error');
            appendProgress('Falha: CALL_EXCEPTION ao enviar.', 'error');
          } else if (error.code === 4001) {
            showToast('Transa√ß√£o cancelada pelo usu√°rio.', 'warning');
            appendProgress('Transa√ß√£o cancelada pelo usu√°rio.', 'warning');
          } else {
            showToast('Erro ao processar a transa√ß√£o. Por favor, tente novamente.', 'error');
            appendProgress('Erro ao processar a transa√ß√£o no envio.', 'error');
          }
          
          document.getElementById('btnComprar').disabled = false;
          return;
        }
        
        showToast(`Pagamento enviado! Aguarde a confirma√ß√£o. Hash: ${tx.hash}`, 'info');
        console.log('Transa√ß√£o de pagamento enviada:', tx);
        appendProgress('Transa√ß√£o enviada. Aguardando confirma√ß√µes‚Ä¶', 'info');
        
        try {
          // Aguarda a confirma√ß√£o da transa√ß√£o
          const receipt = await tx.wait(2);
          console.log('Recibo da transa√ß√£o:', receipt);
          appendProgress('Confirma√ß√µes recebidas. Analisando recibo‚Ä¶', 'info');
          
          if (receipt.status === 1) {
            // Captura saldos DEPOIS da transa√ß√£o
          console.log('üìä [DEBUG] Capturando saldos ap√≥s a transa√ß√£o');
          const balancesAfter = await captureBalances(buyerAddress, receiverAddress);
          console.log('üìà [DEBUG] Saldos depois da transa√ß√£o:', balancesAfter);
          appendProgress('Saldos capturados (depois).', 'success');
          
          if (normalizedSaleContractAddress) {
            // Transa√ß√£o √∫nica via contrato - tokens transferidos automaticamente pelo contrato
            console.log('üéâ [DEBUG] Transa√ß√£o autom√°tica completada com sucesso!');
            console.log('üîÑ [DEBUG] Comparando saldos de tokens:');
            console.log('   - Antes:', balancesBefore.buyerTokens, CONFIG.saleToken.symbol);
            console.log('   - Depois:', balancesAfter.buyerTokens, CONFIG.saleToken.symbol);
            
            const tokensDifference = parseFloat(balancesAfter.buyerTokens) - parseFloat(balancesBefore.buyerTokens);
            console.log('   - Diferen√ßa (tokens recebidos):', tokensDifference, CONFIG.saleToken.symbol);
            appendProgress(`Tokens recebidos: ${tokensDifference} ${CONFIG.saleToken.symbol}.`, 'success');
            
            if (tokensDifference > 0) {
              showToast(`üéØ Compra autom√°tica conclu√≠da! Tokens transferidos automaticamente pelo contrato!`, 'success');
              showToast(`üí∞ Pagamento: ${totalBNB.toFixed(6)} BNB | ü™ô Tokens recebidos: ${tokensDifference} ${CONFIG.saleToken.symbol}`, 'success');
              appendProgress('Compra autom√°tica conclu√≠da com sucesso.', 'success');
            } else {
              showToast(`‚ö†Ô∏è Pagamento processado, mas tokens n√£o foram detectados ainda. Verifique sua carteira.`, 'warning');
              appendProgress('Pagamento processado, tokens n√£o detectados ainda.', 'warning');
            }
            
            // Exibe o recibo da transa√ß√£o autom√°tica
            await showTransactionReceipt(tx, 'bnb', quantidade, totalBNB, balancesBefore, balancesAfter, tx, 'Sucesso - Transa√ß√£o Autom√°tica via Contrato');
          } else {
            // Fluxo simplificado - apenas pagamento em BNB
            console.log('üí° [INFO] Transfer√™ncia autom√°tica de tokens n√£o √© poss√≠vel');
            console.log('üîí [INFO] Apenas o dono do contrato pode transferir tokens');
            console.log('üìã [INFO] O vendedor far√° a transfer√™ncia manual ap√≥s confirmar o pagamento');
            
            showToast('‚úÖ Pagamento enviado com sucesso!', 'success');
            showToast('üìã Os tokens ser√£o transferidos pelo vendedor ap√≥s confirma√ß√£o do pagamento', 'info');
            showToast('‚è∞ Verifique sua carteira em alguns minutos', 'info');
            appendProgress('Pagamento confirmado. Transfer√™ncia manual de tokens pendente.', 'info');
            
            // Exibe o recibo apenas com informa√ß√µes do pagamento
            await showTransactionReceipt(tx, 'bnb', quantidade, totalBNB, balancesBefore, balancesAfter, null, 'Pagamento Confirmado - Transfer√™ncia Manual Pendente');
          }
          
          } else {
            // Status 0: inclu√≠da por√©m revertida/falhou
            showToast('Transa√ß√£o inclu√≠da por√©m falhou (status 0). Verifique destino e saldo de tokens.', 'error');
            console.warn('‚ö†Ô∏è [DEBUG] Status 0 na transa√ß√£o. Recibo:', receipt);
            appendProgress('Transa√ß√£o falhou (status 0). Investigando motivo‚Ä¶', 'error');
            const balancesAfter = await captureBalances(buyerAddress, receiverAddress);
            await showTransactionReceipt(tx, 'bnb', quantidade, totalBNB, balancesBefore, balancesAfter, tx, 'Falha - status 0');
            // Tentativa de reproduzir motivo com callStatic p√≥s-falha
            try {
              await retryWithProviders(async (currentProvider) => {
                const staticContract = new ethers.Contract(
                  normalizedSaleContractAddress,
                  ['function buy(uint256 quantity) payable'],
                  currentProvider
                );
                return await staticContract.callStatic.buy(quantidade, { value: expectedValue, from: buyerAddress });
              }, 4, true);
              appendProgress('Pr√©-valida√ß√£o p√≥s-falha n√£o reproduziu o erro.', 'warning');
            } catch (postErr) {
              const reason = decodeRevertMessage(postErr);
              if (reason) {
                appendProgress('Motivo do revert detectado: ' + reason, 'error');
              } else {
                appendProgress('Contrato reverteu sem mensagem clara.', 'error');
              }
            }
            return;
          }
        } catch (error) {
          console.error('Erro ao aguardar confirma√ß√£o da transa√ß√£o:', error);
          // Tratar CALL_EXCEPTION com acesso ao receipt
          const r = (error && error.receipt) ? error.receipt : null;
          if (r && r.status === 0) {
            showToast('Transa√ß√£o revertida no bloco (status 0). Destino/saldo podem estar incorretos.', 'error');
            console.warn('‚ùå [DEBUG] Revert on-chain detectado. Hash:', r.transactionHash);
            appendProgress('Transa√ß√£o revertida no bloco. Buscando motivo‚Ä¶', 'error');
            const balancesAfter = await captureBalances(buyerAddress, receiverAddress);
            await showTransactionReceipt(tx, 'bnb', quantidade, totalBNB, balancesBefore, balancesAfter, tx, 'Falha - revertida');
            // Tentativa de decodificar motivo de revert
            try {
              await retryWithProviders(async (currentProvider) => {
                const staticContract = new ethers.Contract(
                  normalizedSaleContractAddress,
                  ['function buy(uint256 quantity) payable'],
                  currentProvider
                );
                return await staticContract.callStatic.buy(quantidade, { value: expectedValue, from: buyerAddress });
              }, 4, true);
              appendProgress('Pr√©-valida√ß√£o p√≥s-revert n√£o reproduziu erro.', 'warning');
            } catch (postErr2) {
              const reason2 = decodeRevertMessage(postErr2);
              if (reason2) {
                appendProgress('Motivo prov√°vel: ' + reason2, 'error');
              } else {
                appendProgress('Motivo n√£o dispon√≠vel. Verifique destino, pre√ßo e saldo do contrato.', 'error');
              }
            }
          } else {
            showToast('Erro ao confirmar a transa√ß√£o. Verifique o console para mais detalhes.', 'error');
            appendProgress('Erro ao confirmar a transa√ß√£o (sem recibo).', 'error');
          }
        }
        
        // Atualiza o saldo ap√≥s a transa√ß√£o
        setTimeout(atualizaSaldo, 3000);
      } catch (error) {
        console.error('Erro ao comprar tokens:', error);
        showToast(`Erro ao processar a compra: ${error.message}`, 'error');
        appendProgress('Erro geral ao processar compra: ' + (error?.message || 'desconhecido'), 'error');
      } finally {
        document.getElementById('btnComprar').disabled = false;
        appendProgress('Fluxo de compra finalizado.', 'info');
      }
    }

    // Fun√ß√£o para aplicar configura√ß√µes de teste
    function applyTestConfig() {
      try {
        // L√™ elementos de forma segura e usa valores de CONFIG como fallback
        const tokenAddressEl = document.getElementById('tokenAddress');
        const tokenSymbolEl = document.getElementById('tokenSymbol');
        const tokenDecimalsEl = document.getElementById('tokenDecimals');
        const receiverWalletEl = document.getElementById('receiverWallet');
        const saleContractAddressEl = document.getElementById('saleContractAddress');
        const tokenPriceBNBEl = document.getElementById('tokenPriceBNB');
        const minPurchaseEl = document.getElementById('minPurchase');
        const maxPurchaseEl = document.getElementById('maxPurchase');

        // Valores com fallback
        const tokenAddressInput = tokenAddressEl ? tokenAddressEl.value.trim() : '';
        const tokenAddress = tokenAddressInput
          || (document.getElementById('contractTokenAddress')?.value.trim() || '')
          || (CONFIG.saleToken?.address || '');

        const tokenSymbolInput = tokenSymbolEl ? tokenSymbolEl.value.trim() : '';
        const tokenSymbol = tokenSymbolInput || (CONFIG.saleToken?.symbol || '');

        const tokenDecimalsInput = tokenDecimalsEl ? parseInt(tokenDecimalsEl.value) : NaN;
        const tokenDecimals = Number.isFinite(tokenDecimalsInput) ? tokenDecimalsInput : ((CONFIG.saleToken?.decimals ?? 18));

        const receiverWalletInput = receiverWalletEl ? receiverWalletEl.value.trim() : '';
        let receiverWallet = receiverWalletInput || (CONFIG.walletRecebedora || '');

        const saleContractAddressInput = saleContractAddressEl ? saleContractAddressEl.value.trim() : '';
        const saleContractAddress = saleContractAddressInput
          || (document.getElementById('deployedContractAddress')?.value.trim() || '')
          || (CONFIG.saleContractAddress || '');

        const tokenPriceBNBInput = tokenPriceBNBEl ? parseFloat(tokenPriceBNBEl.value) : NaN;
        const tokenPriceBNB = Number.isFinite(tokenPriceBNBInput) ? tokenPriceBNBInput : ((CONFIG.bnbTestnet?.tokenPrice) ?? 0.001);

        const minPurchaseInput = minPurchaseEl ? parseInt(minPurchaseEl.value) : NaN;
        const maxPurchaseInput = maxPurchaseEl ? parseInt(maxPurchaseEl.value) : NaN;
        const minPurchase = Number.isFinite(minPurchaseInput) ? minPurchaseInput : ((CONFIG.minCompra) ?? 1);
        const maxPurchase = Number.isFinite(maxPurchaseInput) ? maxPurchaseInput : ((CONFIG.maxCompra) ?? 100);

        // Valida√ß√µes (suaves) com helper
        if (tokenAddress && !isValidEthereumAddress(tokenAddress)) {
          showStatus('Endere√ßo do token inv√°lido. Use um endere√ßo Ethereum v√°lido (0x...).', 'error');
          return;
        }

        // Se estiver em modo contrato, a carteira recebedora pode ser omitida
        const isContractMode = !!saleContractAddress && isValidEthereumAddress(saleContractAddress);
        if (!isContractMode) {
          if (!receiverWallet || !isValidEthereumAddress(receiverWallet)) {
            showStatus('Endere√ßo da carteira recebedora inv√°lido ou ausente. Informe um endere√ßo Ethereum v√°lido (0x...).', 'error');
            return;
          }
        }

        if (saleContractAddress && !isValidEthereumAddress(saleContractAddress)) {
          showStatus('Endere√ßo do contrato de venda inv√°lido. Use um endere√ßo Ethereum v√°lido (0x...).', 'error');
          return;
        }

        if (isNaN(tokenDecimals) || tokenDecimals < 0 || tokenDecimals > 18) {
          showStatus('Decimais do token inv√°lidos. Deve ser um n√∫mero entre 0 e 18.', 'error');
          return;
        }

        // Atualiza a configura√ß√£o com os valores obtidos
        if (tokenAddress) CONFIG.saleToken.address = tokenAddress;
        if (tokenSymbol) CONFIG.saleToken.symbol = tokenSymbol;
        CONFIG.saleToken.decimals = tokenDecimals;
        if (receiverWallet) CONFIG.walletRecebedora = receiverWallet;
        if (saleContractAddress) CONFIG.saleContractAddress = saleContractAddress;
        CONFIG.bnbTestnet.tokenPrice = tokenPriceBNB;
        CONFIG.minCompra = minPurchase;
        CONFIG.maxCompra = maxPurchase;
        CONFIG.gasLimit = CONFIG.gasLimit || 'auto';
        CONFIG.maxCompraPorCarteira = (typeof CONFIG.maxCompraPorCarteira === 'number' ? CONFIG.maxCompraPorCarteira : maxPurchase);

        // Atualiza visualmente com estimativa din√¢mica (placeholder at√© pre√ßo do contrato)
        const precoEl = document.getElementById('preco');
        const totalEl = document.getElementById('total');
        if (precoEl) {
          const priceWei = window._contractPrice;
          if (priceWei) {
            const priceBNB = ethers.utils.formatEther(priceWei);
            precoEl.innerText = `${priceBNB} BNB`;
          } else {
            precoEl.innerText = 'Aguardando pre√ßo do contrato‚Ä¶';
          }
        }
        if (typeof updateIntermediateEstimateFromState === 'function') {
          try {
            updateIntermediateEstimateFromState();
          } catch (e) {
            console.warn('Falha ao atualizar estimativa din√¢mica ap√≥s aplicar config:', e);
          }
        } else if (totalEl) {
          totalEl.textContent = '‚Äî';
        }

        // Feedback ao usu√°rio
        showStatus('Configura√ß√µes aplicadas com sucesso!', 'success');

        // Atualiza o saldo e modo de compra se a carteira estiver conectada
        if (signer) {
          atualizaSaldo();
          updatePurchaseMode();
        }
      } catch (error) {
        console.error('Erro ao aplicar configura√ß√µes:', error);
        showStatus(`Erro ao aplicar configura√ß√µes: ${error.message}`, 'error');
      }
    }
    
    // Cache para informa√ß√µes de tokens
    const tokenInfoCache = new Map();

    // Fun√ß√£o para validar endere√ßo Ethereum
    function isValidEthereumAddress(address) {
      if (!address || typeof address !== 'string') {
        return false;
      }
      
      // Deve come√ßar com 0x
      if (!address.startsWith('0x')) {
        return false;
      }
      
      // Deve ter exatamente 42 caracteres (0x + 40 hex chars)
      if (address.length !== 42) {
        return false;
      }
      
      // Deve conter apenas caracteres hexadecimais v√°lidos
      const hexPattern = /^0x[a-fA-F0-9]{40}$/;
      return hexPattern.test(address);
    }

    // Fun√ß√£o para detectar informa√ß√µes do token automaticamente
    async function autoDetectTokenInfo() {
      // Definir elementos fora do bloco try para garantir acesso no finally
      const tokenAddressElement = document.getElementById('contractTokenAddress');
      const tokenNameElement = document.getElementById('contractTokenName');
      const tokenSymbolElement = document.getElementById('contractTokenSymbol');
      const tokenDecimalsElement = document.getElementById('contractTokenDecimals');
      const statusElement = document.getElementById('tokenInfoStatus');
      const spinnerElement = document.getElementById('autoDetectSpinner');
      const textElement = document.getElementById('autoDetectText');
      
      try {
        
        if (!tokenAddressElement) {
          showTokenInfoStatus('Elemento de endere√ßo do token n√£o encontrado', 'error');
          return;
        }
        
        const tokenAddress = tokenAddressElement.value.trim();
        
        // Valida√ß√£o pr√©via do formato do endere√ßo
        if (!isValidEthereumAddress(tokenAddress)) {
          showTokenInfoStatus('‚ùå Formato de endere√ßo inv√°lido. Use um endere√ßo Ethereum v√°lido (0x...)', 'error');
          return;
        }

        // Verificar cache primeiro
        if (tokenInfoCache.has(tokenAddress)) {
          const cachedInfo = tokenInfoCache.get(tokenAddress);
          if (tokenNameElement) tokenNameElement.value = cachedInfo.name;
          if (tokenSymbolElement) tokenSymbolElement.value = cachedInfo.symbol;
          if (tokenDecimalsElement) tokenDecimalsElement.value = cachedInfo.decimals;
          showTokenInfoStatus(`‚úÖ Informa√ß√µes do cache: ${cachedInfo.name} (${cachedInfo.symbol}), Decimais: ${cachedInfo.decimals}`, 'success');
          return;
        }

        // Mostrar loading
        if (spinnerElement) spinnerElement.classList.remove('d-none');
        if (textElement) textElement.textContent = 'Buscando...';
        showTokenInfoStatus('üîç Buscando informa√ß√µes do token...', 'info');

        // Conectar ao provider se necess√°rio
        if (!provider) {
          await connectWallet();
          if (!provider) {
            throw new Error('N√£o foi poss√≠vel conectar √† rede');
          }
        }
        
        // Verifica se o MetaMask est√° instalado
        if (!window.ethereum) {
          throw new Error('MetaMask n√£o encontrado. Por favor, instale a extens√£o MetaMask.');
        }
        
        // Valores padr√£o para o caso de falha na detec√ß√£o
        let symbol = 'TOKEN';
        let name = 'Token';
        let decimals = 18;
        let totalSupply = ethers.BigNumber.from('0');
        
        try {
          // Fun√ß√£o auxiliar para criar provider com fallback (BSC TESTNET)
          const createProviderWithFallback = async () => {
            const providers = [];
            
            // Provider principal (MetaMask)
            if (provider) {
              providers.push(provider);
            }
            
            // Providers de fallback (RPCs p√∫blicos da BSC TESTNET)
            const fallbackRpcs = Array.isArray(CONFIG?.bnbTestnet?.rpcUrls) && CONFIG.bnbTestnet.rpcUrls.length
              ? CONFIG.bnbTestnet.rpcUrls
              : [
                  'https://data-seed-prebsc-1-s1.binance.org:8545/',
                  'https://data-seed-prebsc-2-s1.binance.org:8545/',
                  'https://bsc-testnet.public.blastapi.io',
                  'https://bsc-testnet-rpc.publicnode.com',
                  'https://data-seed-prebsc-1-s2.binance.org:8545/',
                  'https://data-seed-prebsc-2-s2.binance.org:8545/',
                  'https://bsc-testnet.blockpi.network/v1/rpc/public',
                  'https://endpoints.omniatech.io/v1/bsc/testnet/public'
                ];
            
            // Configura√ß√£o est√°tica de rede para evitar "could not detect network"
            const networkConfig = {
              name: 'bsc-testnet',
              chainId: 97,
              ensAddress: null,
              _defaultProvider: null
            };
            
            for (const rpc of fallbackRpcs) {
              try {
                const staticProvider = new ethers.providers.StaticJsonRpcProvider(rpc, networkConfig);
                // For√ßar configura√ß√£o est√°tica e pular detec√ß√£o
                staticProvider._network = networkConfig;
                staticProvider.detectNetwork = () => Promise.resolve(networkConfig);
                providers.push(staticProvider);
              } catch (e) {
                console.warn(`Falha ao criar provider fallback (testnet): ${rpc}`, e);
              }
            }
            
            return providers;
          };

          // Fun√ß√£o para tentar getCode com retry e fallback
          const getCodeWithFallback = async (address, maxRetries = 3) => {
            const providers = await createProviderWithFallback();
            
            for (const currentProvider of providers) {
              for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                  console.log(`Tentativa ${attempt} com provider:`, currentProvider.connection?.url || 'MetaMask');
                  const code = await Promise.race([
                    currentProvider.getCode(address),
                    new Promise((_, reject) => 
                      setTimeout(() => reject(new Error('Timeout')), 10000)
                    )
                  ]);
                  
                  // Valida√ß√£o mais robusta do c√≥digo retornado
                  if (code && code !== '0x' && code.length > 2) {
                    console.log('‚úÖ C√≥digo do contrato obtido com sucesso');
                    return { code, provider: currentProvider };
                  } else if (code === '0x') {
                    // Este √© um endere√ßo v√°lido mas n√£o √© um contrato
                    console.log('‚ö†Ô∏è Endere√ßo v√°lido mas n√£o √© um contrato');
                    throw new Error('INVALID_CONTRACT');
                  }
                } catch (error) {
                  console.warn(`Tentativa ${attempt} falhou:`, error.message);
                  
                  // Tratamento espec√≠fico para diferentes tipos de erro
                  if (error.message === 'INVALID_CONTRACT') {
                    // Se n√£o √© um contrato, n√£o adianta tentar outros providers
                    throw new Error('Endere√ßo fornecido n√£o √© um contrato v√°lido');
                  }
                  
                  // Se √© erro RPC espec√≠fico ou de conectividade, tenta pr√≥ximo provider
                  if (error.code === -32603 || 
                      error.message.includes('Internal JSON-RPC error') ||
                      error.message.includes('network error') ||
                      error.message.includes('timeout') ||
                      error.message.includes('Timeout') ||
                      error.message.includes('NETWORK_ERROR') ||
                      error.message.includes('CONNECTION_ERROR')) {
                    console.log('üîÑ Erro de conectividade detectado, tentando pr√≥ximo provider...');
                    break; // Vai para o pr√≥ximo provider
                  }
                  
                  // Para outros erros, tenta retry com delay apenas se n√£o for o √∫ltimo attempt
                  if (attempt < maxRetries) {
                    const delay = Math.min(attempt * 1000, 3000); // Max 3s delay
                    console.log(`‚è≥ Aguardando ${delay}ms antes da pr√≥xima tentativa...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                  }
                }
              }
            }
            
            throw new Error('Falha ao verificar contrato ap√≥s todas as tentativas');
          };

          // Verifica se o contrato existe na blockchain com fallback
          const { code, provider: workingProvider } = await getCodeWithFallback(tokenAddress);
          
          // Cria um contrato para o token usando o provider que funcionou
          const tokenContract = new ethers.Contract(
            tokenAddress,
            [
              'function symbol() view returns (string)',
              'function name() view returns (string)',
              'function decimals() view returns (uint8)',
              'function totalSupply() view returns (uint256)'
            ],
            workingProvider
          );
          
          // Obt√©m as informa√ß√µes do token com timeout individual
          const [tokenSymbol, tokenName, tokenDecimals, tokenTotalSupply] = await Promise.allSettled([
            tokenContract.symbol(),
            tokenContract.name(),
            tokenContract.decimals(),
            tokenContract.totalSupply()
          ]);
          
          // Processa os resultados
          if (tokenSymbol.status === 'fulfilled') {
            symbol = tokenSymbol.value;
          }
          if (tokenName.status === 'fulfilled') {
            name = tokenName.value;
          }
          if (tokenDecimals.status === 'fulfilled') {
            decimals = tokenDecimals.value;
          }
          if (tokenTotalSupply.status === 'fulfilled') {
            totalSupply = tokenTotalSupply.value;
          }
          
          // Atualiza os campos se existirem
          if (tokenNameElement) {
            tokenNameElement.value = name;
          }
          if (tokenSymbolElement) {
            tokenSymbolElement.value = symbol;
          }
          if (tokenDecimalsElement) {
            tokenDecimalsElement.value = decimals;
          }
          
          // Salvar no cache
          tokenInfoCache.set(tokenAddress, { name, symbol, decimals });
          
          // Exibe informa√ß√µes adicionais
          const formattedTotalSupply = ethers.utils.formatUnits(totalSupply, decimals);
          
          let statusMessage = `‚úÖ Token detectado: ${name} (${symbol}), Decimais: ${decimals}`;
          if (totalSupply.gt(0)) {
            statusMessage += `, Supply Total: ${parseFloat(formattedTotalSupply).toLocaleString()}`;
          }
          showTokenInfoStatus(statusMessage, 'success');
          
        } catch (rpcError) {
          console.error('Erro ao detectar informa√ß√µes do token:', rpcError);
          
          // Tratamento espec√≠fico para diferentes tipos de erro com feedback melhorado
          let errorMessage = '';
          let errorType = 'error';
          
          if (rpcError.code === -32603 || rpcError.message?.includes('Internal JSON-RPC error')) {
            errorMessage = 'üîÑ Erro de conectividade RPC. Tentando com providers alternativos...';
            errorType = 'warning';
            console.log('üîÑ Erro RPC detectado - sistema de fallback ativo');
          } else if (rpcError.message?.includes('n√£o √© um contrato v√°lido')) {
            errorMessage = '‚ùå O endere√ßo fornecido n√£o √© um contrato v√°lido na BSC. Verifique se o endere√ßo est√° correto.';
            errorType = 'error';
          } else if (rpcError.message?.includes('Timeout')) {
            errorMessage = '‚è±Ô∏è Timeout na consulta. Verifique sua conex√£o de internet e tente novamente.';
            errorType = 'warning';
          } else if (rpcError.message?.includes('Falha ao verificar contrato')) {
            errorMessage = 'üîç N√£o foi poss√≠vel verificar o contrato ap√≥s m√∫ltiplas tentativas. Usando valores padr√£o.';
            errorType = 'warning';
          } else if (rpcError.message?.includes('network error') || rpcError.message?.includes('CONNECTION_ERROR')) {
            errorMessage = 'üåê Erro de rede detectado. Verificando providers alternativos...';
            errorType = 'warning';
          } else {
            errorMessage = `‚ö†Ô∏è Erro na detec√ß√£o: ${rpcError.message || 'Erro desconhecido'}. Usando valores padr√£o.`;
            errorType = 'warning';
          }
          
          // Exibir mensagem de erro espec√≠fica
          showTokenInfoStatus(errorMessage, errorType);
          
          // Se n√£o √© erro de contrato inv√°lido, usar valores padr√£o
          if (!rpcError.message?.includes('n√£o √© um contrato v√°lido')) {
            if (tokenNameElement) {
              tokenNameElement.value = name;
            }
            if (tokenSymbolElement) {
              tokenSymbolElement.value = symbol;
            }
            if (tokenDecimalsElement) {
              tokenDecimalsElement.value = decimals;
            }
            
            // Mostrar mensagem adicional sobre valores padr√£o apenas se aplicou fallback
            setTimeout(() => {
              showTokenInfoStatus(`üìù Valores padr√£o aplicados: ${name} (${symbol}), Decimais: ${decimals}. Voc√™ pode edit√°-los manualmente.`, 'info');
            }, 3000);
          }
        }
        
      } catch (error) {
        console.error('Erro ao detectar informa√ß√µes do token:', error);
        showTokenInfoStatus(`‚ùå Erro: ${error.message}`, 'error');
        
        // Usa valores padr√£o mesmo com erro
        if (tokenNameElement) {
          tokenNameElement.value = name;
        }
        if (tokenSymbolElement) {
          tokenSymbolElement.value = symbol;
        }
        if (tokenDecimalsElement) {
          tokenDecimalsElement.value = decimals;
        }
      } finally {
        // Esconder loading
        if (spinnerElement) spinnerElement.classList.add('d-none');
        if (textElement) textElement.textContent = 'üîç Buscar Info';
      }
    }

    // Fun√ß√£o para mostrar status das informa√ß√µes do token
    function showTokenInfoStatus(message, type) {
      const statusElement = document.getElementById('tokenInfoStatus');
      if (!statusElement) return;
      
      let className = 'alert alert-info';
      if (type === 'success') className = 'alert alert-success';
      else if (type === 'error') className = 'alert alert-danger';
      else if (type === 'warning') className = 'alert alert-warning';
      
      statusElement.innerHTML = `<div class="${className} py-2 px-3 mb-0 small">${message}</div>`;
    }
    
    // Fun√ß√£o para detectar saldo do contrato
    async function detectContractBalance(tokenAddress, symbol, decimals) {
      try {
        const operation = async (tempProvider) => {
          // Cria um contrato para o token
          const tokenContract = new ethers.Contract(
            tokenAddress,
            [
              'function balanceOf(address) view returns (uint256)'
            ],
            tempProvider
          );
          
          // Obt√©m o saldo do contrato (o contrato possui tokens para venda)
          const contractBalance = await tokenContract.balanceOf(tokenAddress);
          return contractBalance;
        };
        
        const balance = await tryWithFallback(operation, CONFIG.bnbTestnet.rpcUrls, CONFIG.bnbTestnet.chainId);
        const formattedBalance = ethers.utils.formatUnits(balance, decimals);
        const balanceNumber = parseFloat(formattedBalance);
        
        // Atualiza a configura√ß√£o global com o saldo do contrato
        CONFIG.contractBalance = balanceNumber;
        
        // Exibe o campo de saldo do contrato
        const contractBalanceSection = document.getElementById('contractBalanceSection');
        const contractBalanceElement = document.getElementById('contractBalance');
        const contractBalanceSymbolElement = document.getElementById('contractBalanceSymbol');
        
        if (contractBalanceSection && contractBalanceElement && contractBalanceSymbolElement) {
          contractBalanceElement.textContent = balanceNumber.toLocaleString();
          contractBalanceSymbolElement.textContent = symbol;
          contractBalanceSection.style.display = 'block';
        }
        
        // Atualiza a valida√ß√£o da compra m√°xima
        updateMaxPurchaseValidation();
        
      } catch (error) {
        console.error('Erro ao detectar saldo do contrato:', error);
        // Em caso de erro, define saldo como 0
        CONFIG.contractBalance = 0;
        
        const contractBalanceSection = document.getElementById('contractBalanceSection');
        const contractBalanceElement = document.getElementById('contractBalance');
        const contractBalanceSymbolElement = document.getElementById('contractBalanceSymbol');
        
        if (contractBalanceSection && contractBalanceElement && contractBalanceSymbolElement) {
          contractBalanceElement.textContent = '0';
          contractBalanceSymbolElement.textContent = symbol;
          contractBalanceSection.style.display = 'block';
        }
      }
    }

    // Fun√ß√£o para atualizar valida√ß√£o da compra m√°xima
    function updateMaxPurchaseValidation() {
      const maxPurchaseElement = document.getElementById('maxPurchase');
      if (!maxPurchaseElement) return;
      
      const contractBalance = CONFIG.contractBalance || 0;
      
      // Atualiza o valor m√°ximo permitido
      if (contractBalance > 0) {
        maxPurchaseElement.max = contractBalance;
        
        // Se o valor atual excede o saldo do contrato, ajusta
        const currentValue = parseInt(maxPurchaseElement.value) || 0;
        if (currentValue > contractBalance) {
          maxPurchaseElement.value = Math.floor(contractBalance);
        }
        
        // Atualiza a mensagem de ajuda
        const helpText = maxPurchaseElement.nextElementSibling;
        if (helpText && helpText.classList.contains('form-text')) {
          helpText.textContent = `M√°ximo dispon√≠vel: ${contractBalance.toLocaleString()} tokens`;
        }
      }
    }

    // Fun√ß√£o para usar informa√ß√µes manuais do token
    function useManualInfo() {
      try {
        // Verificar se os elementos existem antes de acessar seus valores
        const tokenAddressElement = document.getElementById('tokenAddress');
        const tokenSymbolElement = document.getElementById('tokenSymbol');
        const tokenDecimalsElement = document.getElementById('tokenDecimals');
        
        if (!tokenAddressElement || !tokenSymbolElement || !tokenDecimalsElement) {
          showStatus('Elementos de formul√°rio n√£o encontrados no HTML', 'error');
          return;
        }
        
        const tokenAddress = tokenAddressElement.value.trim();
        const symbol = tokenSymbolElement.value.trim();
        const decimals = parseInt(tokenDecimalsElement.value) || 18;
        
        // Valida o endere√ßo do token
        if (tokenAddress && (!tokenAddress.startsWith('0x') || tokenAddress.length !== 42)) {
          showStatus('Endere√ßo do token inv√°lido. Deve come√ßar com 0x e ter 42 caracteres.', 'error');
          return;
        }
        
        // Valida o s√≠mbolo
        if (!symbol) {
          showStatus('S√≠mbolo do token n√£o pode estar vazio.', 'error');
          return;
        }
        
        // Valida os decimais
        if (isNaN(decimals) || decimals < 0 || decimals > 18) {
          showStatus('Decimais do token inv√°lidos. Deve ser um n√∫mero entre 0 e 18.', 'error');
          return;
        }
        
        // Atualiza a configura√ß√£o
        if (tokenAddress) {
          CONFIG.saleToken.address = tokenAddress;
        }
        CONFIG.saleToken.symbol = symbol;
        CONFIG.saleToken.decimals = decimals;
        
        // Feedback ao usu√°rio
        let message = `Informa√ß√µes do token configuradas manualmente: S√≠mbolo: ${symbol}, Decimais: ${decimals}`;
        if (tokenAddress) {
          message += `, Endere√ßo: ${tokenAddress}`;
        }
        showStatus(message, 'success');
      } catch (error) {
        console.error('Erro ao usar informa√ß√µes manuais:', error);
        showStatus(`Erro ao configurar informa√ß√µes manuais: ${error.message}`, 'error');
      }
    }
    
    // Fun√ß√£o para configura√ß√£o r√°pida de teste
    function quickSetup() {
      try {
        const setup = CONFIG.quickSetup;
        
        // Configura token padr√£o (TBNB)
        document.getElementById('tokenAddress').value = CONFIG.presetTokens.tbnb.address;
        document.getElementById('tokenSymbol').value = CONFIG.presetTokens.tbnb.symbol;
        document.getElementById('tokenDecimals').value = CONFIG.presetTokens.tbnb.decimals;
        
        // Configura outros valores
        document.getElementById('receiverWallet').value = setup.receiverWallet;
        document.getElementById('tokenPriceBNB').value = setup.tokenPrice;
        document.getElementById('minPurchase').value = setup.minPurchase;
        document.getElementById('maxPurchase').value = setup.maxPurchase;
        document.getElementById('gasLimit').value = setup.gasLimit;
        
        // Atualiza CONFIG
        CONFIG.saleToken = { ...CONFIG.presetTokens.tbnb };
        CONFIG.walletRecebedora = setup.receiverWallet;
        CONFIG.bnbTestnet.tokenPrice = setup.tokenPrice;
        CONFIG.minCompra = setup.minPurchase;
        CONFIG.maxCompra = setup.maxPurchase;
        CONFIG.gasLimit = setup.gasLimit;
        
        // Atualiza interface
        document.getElementById('preco').textContent = `${setup.tokenPrice} BNB`;
        const quantidade = parseInt(document.getElementById('quantidade').value) || 10;
        document.getElementById('total').textContent = `${(quantidade * setup.tokenPrice).toFixed(6)} BNB`;
        
        showStatus('Configura√ß√£o r√°pida aplicada! Token: TBNB (Test BNB Token), Pre√ßo: 0.005 BNB', 'success');
      } catch (error) {
        console.error('Erro na configura√ß√£o r√°pida:', error);
        showStatus(`Erro na configura√ß√£o r√°pida: ${error.message}`, 'error');
      }
    }

    // Fun√ß√£o para lidar com sele√ß√£o de tokens pr√©-configurados
    function handlePresetTokenChange() {
      const selectedToken = document.getElementById('presetTokens').value;
      
      if (selectedToken && selectedToken !== 'custom' && CONFIG.presetTokens[selectedToken]) {
        const token = CONFIG.presetTokens[selectedToken];
        document.getElementById('tokenAddress').value = token.address;
        document.getElementById('tokenSymbol').value = token.symbol;
        document.getElementById('tokenDecimals').value = token.decimals;
        
        showStatus(`Token selecionado: ${token.name} (${token.symbol})`, 'info');
      } else if (selectedToken === 'custom') {
        document.getElementById('tokenAddress').value = '';
        document.getElementById('tokenSymbol').value = '';
        document.getElementById('tokenDecimals').value = '18';
        showStatus('Modo personalizado ativado. Insira os dados manualmente.', 'info');
      }
    }

    // Fun√ß√£o para lidar com sele√ß√£o de carteiras pr√©-configuradas
    function handlePresetWalletChange() {
      const selectedWallet = document.getElementById('presetWallets').value;
      
      if (selectedWallet && selectedWallet !== 'custom') {
        document.getElementById('receiverWallet').value = selectedWallet;
        showStatus('Carteira recebedora selecionada.', 'info');
      } else if (selectedWallet === 'custom') {
        document.getElementById('receiverWallet').value = '';
        showStatus('Modo personalizado ativado. Insira o endere√ßo manualmente.', 'info');
      }
    }

    // Fun√ß√£o para lidar com sele√ß√£o de pre√ßos pr√©-configurados
    function handlePresetPriceChange() {
      const selectedPrice = document.getElementById('presetPrices').value;
      
      if (selectedPrice && selectedPrice !== 'custom') {
        document.getElementById('tokenPriceBNB').value = selectedPrice;
        showStatus(`Pre√ßo selecionado: ${selectedPrice} BNB por token`, 'info');
      } else if (selectedPrice === 'custom') {
        showStatus('Modo personalizado ativado. Insira o pre√ßo manualmente.', 'info');
      }
    }

    // Fun√ß√£o para lidar com sele√ß√£o de limites de g√°s pr√©-configurados
    function handlePresetGasChange() {
      const selectedGas = document.getElementById('presetGasLimits').value;
      
      if (selectedGas && selectedGas !== 'custom') {
        document.getElementById('gasLimit').value = selectedGas;
        showStatus(`Limite de g√°s selecionado: ${parseInt(selectedGas).toLocaleString()}`, 'info');
      } else if (selectedGas === 'custom') {
        showStatus('Modo personalizado ativado. Insira o limite manualmente.', 'info');
      }
    }

    // Fun√ß√£o para verificar o saldo do contrato de venda (usando RPCs p√∫blicos e retry/backoff)
    async function checkContractBalance() {
      const saleContractAddress = CONFIG.saleContractAddress;
      const tokenAddress = CONFIG.saleToken.address;
      
      if (!saleContractAddress || !tokenAddress) {
        return null;
      }

      // Normaliza endere√ßos e garante formato checksum
      const normalizedSale = safeGetAddress(saleContractAddress || '');
      const normalizedToken = safeGetAddress(tokenAddress || '');
      if (!normalizedSale || !normalizedToken) {
        console.warn('‚ö†Ô∏è [DEBUG] Endere√ßos inv√°lidos ao verificar saldo do contrato');
        return null;
      }
      
      try {
        // Usa retry com backoff e ignora MetaMask para leituras
        const result = await retryWithProviders(async (currentProvider) => {
          // Pr√©-checagem: o endere√ßo do token precisa ser um contrato
          const code = await currentProvider.getCode(normalizedToken);
          if (!code || code === '0x') {
            throw new Error('Endere√ßo informado n√£o √© um contrato ERC-20');
          }

          const tokenContract = new ethers.Contract(normalizedToken, [
            'function balanceOf(address) view returns (uint256)',
            'function symbol() view returns (string)',
            'function decimals() view returns (uint8)'
          ], currentProvider);

          const [rawBalance, decimals, symbol] = await Promise.all([
            tokenContract.balanceOf(normalizedSale),
            tokenContract.decimals(),
            tokenContract.symbol()
          ]);

          return { rawBalance, decimals, symbol };
        }, 8, true);
        
        const formattedBalance = ethers.utils.formatUnits(result.rawBalance, result.decimals);
        console.log(`‚úÖ [DEBUG] Saldo do contrato via fallback: ${formattedBalance} ${result.symbol}`);
        
        return {
          balance: formattedBalance,
          symbol: result.symbol,
          raw: result.rawBalance
        };
      } catch (error) {
        // Tratamento amig√°vel para erros comuns de RPC e chamadas a EOAs
        const msg = (error && error.message) ? error.message : String(error);
        if (msg.includes('CALL_EXCEPTION') || msg.includes('missing trie node') || msg.includes('Internal JSON-RPC error')) {
          console.warn('‚ùå [DEBUG] Falha na leitura do saldo do contrato (RPC/MetaMask). Tentativas com fallback esgotadas.');
        }
        console.error('Erro ao verificar saldo do contrato (fallback RPC):', error);
        return null;
      }
    }

    // Exibe/atualiza informa√ß√µes de limite por carteira na UI
    async function updateCapInfoDisplay() {
      try {
        const capSection = document.getElementById('capInfoSection');
        const capMaxEl = document.getElementById('capMax');
        const capAvailableEl = document.getElementById('capAvailable');
        const capSymbolEl = document.getElementById('capSymbol');
        const capSymbolEl2 = document.getElementById('capSymbol2');
        if (!capSection || !capMaxEl || !capAvailableEl || !capSymbolEl || !capSymbolEl2) return;

        const capValue = (typeof CONFIG.maxCompraPorCarteira === 'number' && CONFIG.maxCompraPorCarteira > 0)
          ? CONFIG.maxCompraPorCarteira
          : ((typeof CONFIG.maxCompra === 'number' && CONFIG.maxCompra > 0) ? CONFIG.maxCompra : null);

        if (!capValue || !CONFIG.saleToken || !CONFIG.saleToken.address) {
          capSection.style.display = 'none';
          return;
        }

        const symbol = CONFIG.saleToken.symbol || (document.getElementById('tokenSymbol')?.value || 'TOKEN');
        capMaxEl.textContent = capValue.toLocaleString();
        capSymbolEl.textContent = symbol;
        capSymbolEl2.textContent = symbol;

        if (typeof getTokenBalance === 'function' && signer) {
          const buyerAddr = await signer.getAddress();
          const currentBalanceStr = await getTokenBalance(buyerAddr, 'comprador');
          const currentBalanceNum = parseFloat(currentBalanceStr) || 0;
          const availableToBuy = Math.max(capValue - currentBalanceNum, 0);
          capAvailableEl.textContent = availableToBuy.toFixed(0);
          capSection.style.display = 'block';
        } else {
          capAvailableEl.textContent = '‚Äî';
          capSection.style.display = 'block';
        }
      } catch (err) {
        console.warn('Falha ao atualizar info de cap por carteira:', err);
      }
    }

    // Fun√ß√£o para atualizar o modo de compra na interface
    async function updatePurchaseMode() {
      const saleContractAddress = CONFIG.saleContractAddress;
      const modeInfo = document.getElementById('purchase-mode-info');
      const modeTitle = document.getElementById('mode-title');
      const modeDescription = document.getElementById('mode-description');
      
      if (saleContractAddress && saleContractAddress.trim() !== '') {
        modeInfo.className = 'alert alert-success mb-3';
        modeTitle.textContent = 'Modo Autom√°tico:';
        
        // Verifica o saldo do contrato
        const contractBalance = await checkContractBalance();
        
        if (contractBalance) {
          modeDescription.innerHTML = `
            <strong>Transfer√™ncia Autom√°tica via Contrato</strong><br>
            <small>‚Ä¢ Uma √∫nica transa√ß√£o transfere BNB e recebe tokens automaticamente<br>
            ‚Ä¢ Contrato: ${saleContractAddress.substring(0, 10)}...${saleContractAddress.substring(32)}<br>
            ‚Ä¢ Saldo dispon√≠vel: ${parseFloat(contractBalance.balance).toFixed(2)} ${contractBalance.symbol}<br>
            ‚Ä¢ Processo 100% autom√°tico e seguro</small>
          `;
          
          // Mostra se√ß√£o de saldo do contrato
          const contractBalanceSection = document.getElementById('contractBalanceSection');
          const contractBalanceEl = document.getElementById('contractBalance');
          const contractBalanceSymbolEl = document.getElementById('contractBalanceSymbol');
          
          if (contractBalanceSection && contractBalanceEl && contractBalanceSymbolEl) {
            const balanceNum = parseFloat(contractBalance.balance);
            contractBalanceEl.textContent = balanceNum.toFixed(2);
            contractBalanceSymbolEl.textContent = contractBalance.symbol;
            contractBalanceSection.style.display = 'block';

            // Atualiza configura√ß√£o e valida√ß√£o m√°xima
            CONFIG.contractBalance = balanceNum;
            updateMaxPurchaseValidation();
          }
        } else {
          modeDescription.innerHTML = `
            <strong>Transfer√™ncia Autom√°tica via Contrato</strong><br>
            <small>‚Ä¢ Uma √∫nica transa√ß√£o transfere BNB e recebe tokens automaticamente<br>
            ‚Ä¢ Contrato: ${saleContractAddress.substring(0, 10)}...${saleContractAddress.substring(32)}<br>
            ‚Ä¢ Verificando saldo do contrato...<br>
            ‚Ä¢ Processo 100% autom√°tico e seguro</small>
          `;
        }
      } else {
        modeInfo.className = 'alert alert-warning mb-3';
        modeTitle.textContent = 'Modo Manual:';
        modeDescription.innerHTML = `
          <strong>Transfer√™ncia Manual de Tokens</strong><br>
          <small>‚Ä¢ Voc√™ envia BNB, o vendedor transfere tokens manualmente<br>
          ‚Ä¢ Aguarde alguns minutos ap√≥s o pagamento<br>
          ‚Ä¢ Configure um contrato de venda para modo autom√°tico</small>
        `;
        
        // Oculta se√ß√£o de saldo do contrato
        const contractBalanceSection = document.getElementById('contractBalanceSection');
        if (contractBalanceSection) {
          contractBalanceSection.style.display = 'none';
        }
      }
    }

    // Gerador de c√≥digo Solidity
    function generateSolidityContract() {
      // Verificar se os elementos existem antes de acessar suas propriedades
      const tokenAddressEl = document.getElementById('contractTokenAddress');
      const tokenNameEl = document.getElementById('contractTokenName');
      const tokenDecimalsEl = document.getElementById('contractTokenDecimals');
      const destinationWalletEl = document.getElementById('contractDestinationWallet');
      const tokenPriceBNBEl = document.getElementById('contractBnbPrice');
      const acceptUSDTEl = document.getElementById('contractAcceptUsdt');
      const tokenPriceUSDTEl = document.getElementById('contractUsdtPrice');
      const minPurchaseEl = document.getElementById('contractMinPurchase');
      const maxPurchaseEl = document.getElementById('contractMaxPurchase');

      // Validar se todos os elementos necess√°rios existem
      if (!tokenAddressEl || !tokenNameEl || !tokenDecimalsEl || !destinationWalletEl || !tokenPriceBNBEl) {
        alert('Erro: Alguns campos obrigat√≥rios n√£o foram encontrados no formul√°rio.');
        return '';
      }

      const tokenAddress = tokenAddressEl.value.trim();
      const tokenName = tokenNameEl.value.trim();
      const tokenDecimals = tokenDecimalsEl.value.trim();
      const destinationWallet = destinationWalletEl.value.trim();
      const tokenPriceBNB = tokenPriceBNBEl.value.trim();
      const acceptUSDT = acceptUSDTEl ? acceptUSDTEl.checked : false;
      const tokenPriceUSDT = tokenPriceUSDTEl ? tokenPriceUSDTEl.value.trim() : '1.00';
      const minPurchase = minPurchaseEl ? minPurchaseEl.value.trim() : '1';
      const maxPurchase = maxPurchaseEl ? maxPurchaseEl.value.trim() : '1000';

      // Valida√ß√µes adicionais
      if (!tokenAddress || !tokenAddress.startsWith('0x') || tokenAddress.length !== 42) {
        alert('Erro: Endere√ßo do token inv√°lido. Deve come√ßar com 0x e ter 42 caracteres.');
        return '';
      }

      if (!destinationWallet || !destinationWallet.startsWith('0x') || destinationWallet.length !== 42) {
        alert('Erro: Endere√ßo da carteira de destino inv√°lido. Deve come√ßar com 0x e ter 42 caracteres.');
        return '';
      }

      if (!tokenPriceBNB || parseFloat(tokenPriceBNB) <= 0) {
        alert('Erro: Pre√ßo do token em BNB deve ser maior que zero.');
        return '';
      }

      if (!tokenDecimals || parseInt(tokenDecimals) < 0 || parseInt(tokenDecimals) > 18) {
        alert('Erro: Decimais do token devem estar entre 0 e 18.');
        return '';
      }

      const solidityCode = `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function decimals() external view returns (uint8);
}

contract TokenSale {
    IERC20 public saleToken;
    address public destinationWallet;
    uint256 public bnbPrice; // Pre√ßo em wei (1 BNB = 10^18 wei)
    ${acceptUSDT ? 'IERC20 public usdtToken;\n    uint256 public usdtPrice; // Pre√ßo em unidades USDT (considerando 18 decimais)' : ''}
    uint256 public minPurchase;
    uint256 public maxPurchase;
    address public owner;
    
    event TokensPurchased(address indexed buyer, uint256 amount, uint256 cost, string paymentMethod);
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Apenas o proprietario pode executar esta funcao");
        _;
    }
    
    constructor() {
        saleToken = IERC20(${tokenAddress || '0x0000000000000000000000000000000000000000'});
        destinationWallet = ${destinationWallet || 'msg.sender'};
        bnbPrice = ${Math.floor(parseFloat(tokenPriceBNB || '0.001') * 1e18)}; // ${tokenPriceBNB || '0.001'} BNB por token
        ${acceptUSDT ? `usdtToken = IERC20(0x55d398326f99059fF775485246999027B3197955); // USDT BSC Mainnet\n        usdtPrice = ${Math.floor(parseFloat(tokenPriceUSDT || '1') * 1e18)}; // ${tokenPriceUSDT || '1'} USDT por token` : ''}
        minPurchase = ${minPurchase || '1'} * 10**${tokenDecimals || '18'};
        maxPurchase = ${maxPurchase || '1000'} * 10**${tokenDecimals || '18'};
        owner = msg.sender;
    }
    
    // Fun√ß√£o para comprar tokens com BNB
    function buy() external payable {
        require(msg.value > 0, "Valor deve ser maior que zero");
        
        uint256 tokenAmount = (msg.value * 10**${tokenDecimals}) / bnbPrice;
        
        require(tokenAmount >= minPurchase, "Quantidade minima nao atingida");
        require(tokenAmount <= maxPurchase, "Quantidade maxima excedida");
        require(saleToken.balanceOf(address(this)) >= tokenAmount, "Tokens insuficientes no contrato");
        
        // Transfere tokens para o comprador
        require(saleToken.transfer(msg.sender, tokenAmount), "Falha na transferencia de tokens");
        
        // Transfere BNB para a carteira de destino
        payable(destinationWallet).transfer(msg.value);
        
        emit TokensPurchased(msg.sender, tokenAmount, msg.value, "BNB");
    }
    
    ${acceptUSDT ? `// Fun√ß√£o para comprar tokens com USDT
    function buyWithUSDT(uint256 usdtAmount) external {
        require(usdtAmount > 0, "Quantidade USDT deve ser maior que zero");
        
        uint256 tokenAmount = (usdtAmount * 10**${tokenDecimals}) / usdtPrice;
        
        require(tokenAmount >= minPurchase, "Quantidade minima nao atingida");
        require(tokenAmount <= maxPurchase, "Quantidade maxima excedida");
        require(saleToken.balanceOf(address(this)) >= tokenAmount, "Tokens insuficientes no contrato");
        
        // Transfere USDT do comprador para a carteira de destino
        require(usdtToken.transferFrom(msg.sender, destinationWallet, usdtAmount), "Falha na transferencia de USDT");
        
        // Transfere tokens para o comprador
        require(saleToken.transfer(msg.sender, tokenAmount), "Falha na transferencia de tokens");
        
        emit TokensPurchased(msg.sender, tokenAmount, usdtAmount, "USDT");
    }` : ''}
    
    // Fun√ß√£o para verificar saldo de tokens no contrato
    function balanceOf() external view returns (uint256) {
        return saleToken.balanceOf(address(this));
    }
    
    // Fun√ß√£o para retirar tokens n√£o vendidos (apenas owner)
    function withdrawTokens(uint256 amount) external onlyOwner {
        require(saleToken.transfer(owner, amount), "Falha na retirada de tokens");
    }
    
    // Fun√ß√£o para atualizar pre√ßos (apenas owner)
    function updatePrices(uint256 newBnbPrice${acceptUSDT ? ', uint256 newUsdtPrice' : ''}) external onlyOwner {
        bnbPrice = newBnbPrice;
        ${acceptUSDT ? 'usdtPrice = newUsdtPrice;' : ''}
    }
    
    // Fun√ß√£o para atualizar limites de compra (apenas owner)
    function updateLimits(uint256 newMinPurchase, uint256 newMaxPurchase) external onlyOwner {
        minPurchase = newMinPurchase;
        maxPurchase = newMaxPurchase;
    }
    
    // Fun√ß√£o para emerg√™ncia - retirar BNB (apenas owner)
    function emergencyWithdrawBNB() external onlyOwner {
        payable(owner).transfer(address(this).balance);
    }
}`;

      return solidityCode;
    }

    // Sistema de navega√ß√£o entre etapas
    let currentStep = 1;
    const totalSteps = 5;

    function showStep(stepNumber) {
      // Oculta todas as etapas
      for (let i = 1; i <= totalSteps; i++) {
        const stepContent = document.getElementById(`step-content-${i}`);
        if (stepContent) {
          stepContent.style.display = 'none';
        }
      }

      // Mostra a etapa atual
      const currentStepContent = document.getElementById(`step-content-${stepNumber}`);
      if (currentStepContent) {
        currentStepContent.style.display = 'block';
      }

      // Atualiza indicadores visuais
      updateStepIndicators(stepNumber);
      currentStep = stepNumber;

      // Mostra/oculta widget de compra na etapa 5
      const widgetSection = document.getElementById('widget-section');
      if (widgetSection) {
        widgetSection.style.display = stepNumber === 5 ? 'block' : 'none';
      }
    }

    function updateStepIndicators(activeStep) {
      for (let i = 1; i <= totalSteps; i++) {
        const stepElement = document.querySelector(`.step-${i}`);
        if (stepElement) {
          stepElement.classList.remove('active', 'completed');
          if (i < activeStep) {
            stepElement.classList.add('completed');
          } else if (i === activeStep) {
            stepElement.classList.add('active');
          }
        }
      }
    }

    function validateStep1() {
      const tokenAddressEl = document.getElementById('contractTokenAddress');
      const tokenNameEl = document.getElementById('contractTokenName');
      const destinationWalletEl = document.getElementById('contractDestinationWallet');
      const tokenPriceBNBEl = document.getElementById('contractBnbPrice');
      const minPurchaseEl = document.getElementById('contractMinPurchase');
      const maxPurchaseEl = document.getElementById('contractMaxPurchase');

      const tokenAddress = tokenAddressEl ? tokenAddressEl.value.trim() : '';
      const tokenName = tokenNameEl ? tokenNameEl.value.trim() : '';
      const destinationWallet = destinationWalletEl ? destinationWalletEl.value.trim() : '';
      const tokenPriceBNB = tokenPriceBNBEl ? tokenPriceBNBEl.value : '';
      const minPurchase = minPurchaseEl ? minPurchaseEl.value : '';
      const maxPurchase = maxPurchaseEl ? maxPurchaseEl.value : '';

      return tokenAddress && tokenName && destinationWallet && tokenPriceBNB && minPurchase && maxPurchase;
    }

    function downloadSolidityFile(content, filename) {
      const blob = new Blob([content], { type: 'text/plain' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
    }

    // Inicializa√ß√£o
    document.addEventListener('DOMContentLoaded', function() {
      // Event listeners para sistema de etapas
      const skipToStep4 = document.getElementById('skipToStep4');
      if (skipToStep4) {
        skipToStep4.addEventListener('click', () => showStep(4));
      }

      const goToStep2 = document.getElementById('goToStep2');
      if (goToStep2) {
        goToStep2.addEventListener('click', () => {
          if (validateStep1()) {
            showStep(2);
          } else {
            alert('Por favor, preencha todos os campos obrigat√≥rios.');
          }
        });
      }

      const generateContract = document.getElementById('generateContract');
      if (generateContract) {
        generateContract.addEventListener('click', () => {
          const solidityCode = generateSolidityContract();
          if (solidityCode && solidityCode.trim() !== '') {
            const codeArea = document.getElementById('generatedContract');
            if (codeArea) {
              codeArea.textContent = solidityCode;
              showStep(2); // Avan√ßa para a etapa 2 ap√≥s gerar o contrato
            }
          }
          // Se solidityCode estiver vazio, a fun√ß√£o generateSolidityContract j√° mostrou o erro
          
          // Habilita bot√µes de a√ß√£o
          const downloadBtn = document.getElementById('downloadContract');
          const copyBtn = document.getElementById('copyContract');
          const goToStep3Btn = document.getElementById('goToStep3');
          
          if (downloadBtn) downloadBtn.disabled = false;
          if (copyBtn) copyBtn.disabled = false;
          if (goToStep3Btn) goToStep3Btn.disabled = false;
        });
      }

      const downloadContract = document.getElementById('downloadContract');
      if (downloadContract) {
        downloadContract.addEventListener('click', () => {
          const code = document.getElementById('generatedContract').textContent;
          const tokenNameEl = document.getElementById('contractTokenName');
          const tokenName = tokenNameEl ? tokenNameEl.value : 'Token';
          const filename = `${tokenName}Sale.sol`;
          downloadSolidityFile(code, filename);
        });
      }

      const copyContract = document.getElementById('copyContract');
      if (copyContract) {
        copyContract.addEventListener('click', () => {
          const code = document.getElementById('generatedContract').textContent;
          navigator.clipboard.writeText(code).then(() => {
            alert('C√≥digo copiado para a √°rea de transfer√™ncia!');
          });
        });
      }

      // Navega√ß√£o entre etapas
      const backToStep1 = document.getElementById('backToStep1');
      if (backToStep1) {
        backToStep1.addEventListener('click', () => showStep(1));
      }

      const goToStep3 = document.getElementById('goToStep3');
      if (goToStep3) {
        goToStep3.addEventListener('click', () => showStep(3));
      }

      const backToStep2 = document.getElementById('backToStep2');
      if (backToStep2) {
        backToStep2.addEventListener('click', () => showStep(2));
      }

      const goToStep4 = document.getElementById('goToStep4');
      if (goToStep4) {
        goToStep4.addEventListener('click', () => showStep(4));
      }

      const backToStep3 = document.getElementById('backToStep3');
      if (backToStep3) {
        backToStep3.addEventListener('click', () => showStep(3));
      }

      const goToStep5 = document.getElementById('goToStep5');
      if (goToStep5) {
        goToStep5.addEventListener('click', () => {
          // Copia dados do contrato para os campos de teste
          const contractAddressEl = document.getElementById('deployedContractAddress');
          const tokenAddressEl = document.getElementById('contractTokenAddress');
          const contractAddress = contractAddressEl ? contractAddressEl.value.trim() : '';
          const tokenAddress = tokenAddressEl ? tokenAddressEl.value.trim() : '';
          
          if (contractAddress && tokenAddress) {
            const saleContractEl = document.getElementById('saleContractAddress');
            const tokenEl = document.getElementById('tokenAddress');
            if (saleContractEl) saleContractEl.value = contractAddress;
            if (tokenEl) tokenEl.value = tokenAddress;

            // Reutiliza e aplica configura√ß√£o sem exigir reentrada
            try {
              CONFIG.saleContractAddress = contractAddress;
              CONFIG.saleToken.address = tokenAddress;
              // Atualiza modo de compra imediatamente
              updatePurchaseMode();
            } catch (e) {
              console.warn('Aviso ao aplicar config ao entrar na etapa 5:', e);
            }
            showStep(5);
            // Atualiza pre√ßo/total baseado em CONFIG atual
            try {
              applyTestConfig();
            } catch (e) {
              console.warn('Aviso ao atualizar UI na etapa 5:', e);
            }
          } else {
            alert('Por favor, informe o endere√ßo do contrato deployado.');
          }
        });
      }

      const backToStep4 = document.getElementById('backToStep4');
      if (backToStep4) {
        backToStep4.addEventListener('click', () => showStep(4));
      }

      const startTesting = document.getElementById('startTesting');
      if (startTesting) {
        startTesting.addEventListener('click', () => {
          // Aplica configura√ß√µes e inicia testes
          applyTestConfig();
          alert('Configura√ß√µes aplicadas! Agora voc√™ pode testar o sistema de compra.');
        });
      }

      // Rate limiting para evitar m√∫ltiplas chamadas simult√¢neas
      let isDetecting = false;
      let lastDetectionTime = 0;
      const DETECTION_COOLDOWN = 2000; // 2 segundos entre detec√ß√µes

      // Event listener para busca autom√°tica de informa√ß√µes do token
      const autoDetectBtn = document.getElementById('autoDetectTokenInfo');
      if (autoDetectBtn) {
        autoDetectBtn.addEventListener('click', async function() {
          // Verificar se j√° est√° detectando
          if (isDetecting) {
            showTokenInfoStatus('üîÑ Detec√ß√£o j√° em andamento...', 'info');
            return;
          }

          // Verificar cooldown
          const now = Date.now();
          if (now - lastDetectionTime < DETECTION_COOLDOWN) {
            const remainingTime = Math.ceil((DETECTION_COOLDOWN - (now - lastDetectionTime)) / 1000);
            showTokenInfoStatus(`‚è≥ Aguarde ${remainingTime}s antes de tentar novamente`, 'warning');
            return;
          }

          // Marcar como detectando
          isDetecting = true;
          lastDetectionTime = now;

          try {
            await autoDetectTokenInfo();
          } finally {
            // Sempre liberar o lock
            isDetecting = false;
          }
        });
      }

      // Event listeners para bot√µes da Etapa 4
      const detectContractInfo = document.getElementById('detectContractInfo');
      if (detectContractInfo) {
        detectContractInfo.addEventListener('click', async function() {
          await detectContractInformation();
        });
      }

      const validateContract = document.getElementById('validateContract');
      if (validateContract) {
        validateContract.addEventListener('click', async function() {
          await validateContractFunction();
        });
      }

      // Debounce timer para evitar m√∫ltiplas chamadas
      let debounceTimer = null;

      // Event listener para busca autom√°tica quando o endere√ßo muda
      const contractTokenAddress = document.getElementById('contractTokenAddress');
      if (contractTokenAddress) {
        contractTokenAddress.addEventListener('input', function() {
          const address = this.value.trim();
          
          // Limpar campos quando o endere√ßo √© alterado
          const tokenNameEl = document.getElementById('contractTokenName');
          const tokenSymbolEl = document.getElementById('contractTokenSymbol');
          const tokenDecimalsEl = document.getElementById('contractTokenDecimals');
          const statusEl = document.getElementById('tokenInfoStatus');
          
          if (tokenNameEl) tokenNameEl.value = '';
          if (tokenSymbolEl) tokenSymbolEl.value = '';
          if (tokenDecimalsEl) tokenDecimalsEl.value = '18';
          if (statusEl) statusEl.innerHTML = '';
          
          // Cancelar timer anterior se existir
          if (debounceTimer) {
            clearTimeout(debounceTimer);
          }
          
          // Se o endere√ßo est√° vazio, n√£o fazer nada
          if (!address) {
            return;
          }
          
          // Debounce de 1 segundo para auto-detec√ß√£o
          debounceTimer = setTimeout(async () => {
            // Verificar se j√° est√° detectando
            if (isDetecting) {
              console.log('üîÑ Detec√ß√£o j√° em andamento, ignorando...');
              return;
            }
            
            // Verificar cooldown
            const now = Date.now();
            if (now - lastDetectionTime < DETECTION_COOLDOWN) {
              console.log('‚è≥ Cooldown ativo, ignorando auto-detec√ß√£o');
              return;
            }
            
            // Marcar como detectando
            isDetecting = true;
            lastDetectionTime = now;
            
            try {
              await autoDetectTokenInfo();
            } finally {
              // Sempre liberar o lock
              isDetecting = false;
            }
          }, 1000); // 1 segundo de debounce
          
          // Valida√ß√£o em tempo real
          if (address.length > 0 && (!address.startsWith('0x') || address.length > 42)) {
            showTokenInfoStatus('‚ùå Endere√ßo inv√°lido. Deve come√ßar com 0x e ter 42 caracteres.', 'error');
          } else if (address.length === 42 && address.startsWith('0x')) {
            showTokenInfoStatus('‚úÖ Endere√ßo v√°lido. Clique em "Buscar Info" para detectar informa√ß√µes.', 'success');
          }
        });
        
        contractTokenAddress.addEventListener('blur', function() {
          const address = this.value.trim();
          if (address && address.startsWith('0x') && address.length === 42) {
            autoDetectTokenInfo();
          }
        });
      }

      // Event listeners originais (com verifica√ß√£o de exist√™ncia)
      const btnConnect = document.getElementById('btnConnect');
      if (btnConnect) {
        btnConnect.addEventListener('click', connectWallet);
      }
      
      const btnComprar = document.getElementById('btnComprar');
      if (btnComprar) {
        btnComprar.addEventListener('click', buyTokens);
      }

      // Atualiza estimativa intermedi√°ria com base no estado atual (pre√ßo/decimais)
      async function updateIntermediateEstimateFromState() {
        try {
          const estimatedTotalsEl = document.getElementById('estimatedTotals');
          const effectiveModeEl = document.getElementById('effectiveMode');
          const totalEl = document.getElementById('total');
          const qtyEl = document.getElementById('quantidade');

          if (!estimatedTotalsEl || !qtyEl) return;

          const qtyStr = (qtyEl.value || '0').toString();
          const qty = parseInt(qtyStr) || 0;

          const priceWei = window._contractPrice;
          const decimals = (CONFIG && CONFIG.saleToken && typeof CONFIG.saleToken.decimals === 'number')
            ? CONFIG.saleToken.decimals : null;
          const symbol = (CONFIG && CONFIG.saleToken && CONFIG.saleToken.symbol) ? CONFIG.saleToken.symbol : 'TOKEN';

          if (!priceWei || decimals === null) {
            estimatedTotalsEl.textContent = 'Aguardando pre√ßo e decimais do token‚Ä¶';
            if (totalEl) totalEl.textContent = '‚Äî';
            if (effectiveModeEl) effectiveModeEl.textContent = '‚Äî';
            return;
          }

          const expectedValueHuman = ethers.BigNumber.from(priceWei).mul(ethers.BigNumber.from(qty.toString()));
          const quantidadeUnits = ethers.utils.parseUnits(qtyStr, decimals);
          const expectedValueUnits = ethers.BigNumber.from(priceWei).mul(quantidadeUnits);

          const totalHumanBNBPreview = parseFloat(ethers.utils.formatEther(expectedValueHuman));
          const totalUnitsBNBPreview = parseFloat(ethers.utils.formatEther(expectedValueUnits));

          estimatedTotalsEl.textContent =
            `${totalHumanBNBPreview.toFixed(6)} BNB (${qty} ${symbol}, modo humano) | ${totalUnitsBNBPreview.toFixed(6)} BNB (unidades base, decimais ${decimals})`;

          // O total efetivo ser√° definido ap√≥s a pr√©-valida√ß√£o; mant√©m placeholder
          if (totalEl) totalEl.textContent = '‚Äî';

          // Limite por carteira (UI)
          try {
            const btnComprar = document.getElementById('btnComprar');
            const perWalletCap = (typeof CONFIG.maxCompraPorCarteira === 'number' && CONFIG.maxCompraPorCarteira > 0)
              ? CONFIG.maxCompraPorCarteira
              : (typeof CONFIG.maxCompra === 'number' ? CONFIG.maxCompra : null);

            if (perWalletCap && signer && CONFIG.saleToken && CONFIG.saleToken.address) {
              const buyerAddress = await signer.getAddress();
              const currentBalanceStr = await getTokenBalance(buyerAddress, 'comprador');
              const currentBalance = parseFloat(currentBalanceStr) || 0;

              const availableToBuy = Math.max(perWalletCap - currentBalance, 0);

              // Sempre atualiza o estado do bot√£o de compra
              if (btnComprar) btnComprar.disabled = qty > availableToBuy || qty <= 0;

              // Se exceder, mostra aviso de forma discreta
              if (qty > availableToBuy) {
                showStatus(`Limite por carteira: m√°ximo ${perWalletCap} ${symbol}. Dispon√≠vel: ${availableToBuy.toFixed(0)} ${symbol}.`, 'warning');
              }
            }
          } catch (capErr) {
            console.warn('Falha na checagem de limite por carteira:', capErr);
          }
        } catch (e) {
          console.warn('Falha ao atualizar estimativa intermedi√°ria:', e);
        }
      }
      
      const quantidade = document.getElementById('quantidade');
      if (quantidade) {
        quantidade.addEventListener('input', function() {
          updateIntermediateEstimateFromState();
          
          // Atualiza o saldo e modo de compra se a carteira estiver conectada
          if (signer) {
            atualizaSaldo();
            updatePurchaseMode();
          }
        });
      }
      
      const applyConfig = document.getElementById('applyConfig');
      if (applyConfig) {
        applyConfig.addEventListener('click', applyTestConfig);
      }

      // Atualiza cap na UI quando o m√°ximo manual muda
      const maxPurchaseEl = document.getElementById('maxPurchase');
      if (maxPurchaseEl) {
        maxPurchaseEl.addEventListener('input', () => {
          const val = parseInt(maxPurchaseEl.value);
          if (!isNaN(val)) {
            CONFIG.maxCompra = val;
          }
          updateCapInfoDisplay();
        });
      }
      
      const detectTokenInfo = document.getElementById('detectTokenInfo');
      if (detectTokenInfo) {
        detectTokenInfo.addEventListener('click', detectTokenInfo);
      }
      
      const useManualInfo = document.getElementById('useManualInfo');
      if (useManualInfo) {
        useManualInfo.addEventListener('click', useManualInfo);
      }

      // Inicializa na etapa 1
      showStep(1);
      
      // Atualiza o pre√ßo exibido (com verifica√ß√£o)
      const precoEl = document.getElementById('preco');
      if (precoEl) {
        precoEl.innerText = 'Aguardando pre√ßo do contrato‚Ä¶';
      }
      
      // Inicializa total e modo efetivo
      const quantidadeEl = document.getElementById('quantidade');
      const totalEl = document.getElementById('total');
      const effectiveModeEl = document.getElementById('effectiveMode');
      if (totalEl) totalEl.textContent = '‚Äî';
      if (effectiveModeEl) effectiveModeEl.textContent = '‚Äî';
      // Atualiza estimativa se j√° houver estado carregado
      updateIntermediateEstimateFromState();
      
      // Atualiza o modo de compra inicial
      updatePurchaseMode();
      
      // Desabilita o bot√£o de compra at√© que a carteira seja conectada (com verifica√ß√£o)
      const btnComprarFinal = document.getElementById('btnComprar');
      if (btnComprarFinal) {
        btnComprarFinal.disabled = true;
      }
    });

    // Fun√ß√£o para detectar informa√ß√µes do contrato deployado
    // Vari√°vel global para controlar se MetaMask est√° funcionando
    let metamaskBlacklisted = false;
    
    // Fun√ß√£o auxiliar para testar se MetaMask est√° funcionando
    async function testMetaMaskHealth() {
      if (!window.ethereum || metamaskBlacklisted) {
        return false;
      }
      
      try {
        // Usar 'any' para evitar falhas de detec√ß√£o de rede
        const provider = new ethers.providers.Web3Provider(window.ethereum, 'any');
        
        // Teste rigoroso: usar exatamente a mesma opera√ß√£o que est√° falhando
        // Usar endere√ßo de contrato BSC TESTNET conhecido (PancakeSwap Router Testnet)
        const testContractAddress = '0xD99D1c33F9fC3444f8101754aBC46c52416550D1';
        
        // Criar promise com timeout de 3 segundos
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Timeout: MetaMask n√£o respondeu em 3 segundos')), 3000);
        });
        
        // Testar getCode() com timeout - exatamente a opera√ß√£o que est√° falhando
        const codePromise = provider.getCode(testContractAddress);
        
        await Promise.race([codePromise, timeoutPromise]);
        
        console.log('‚úÖ MetaMask passou no teste rigoroso de getCode()');
        return true;
      } catch (error) {
        console.warn('‚ùå MetaMask falhou no teste rigoroso:', error.message);
        
        // Blacklist imediata para qualquer erro relacionado a RPC
        if (error.message.includes('Internal JSON-RPC error') || 
            error.message.includes('Timeout') ||
            error.message.includes('missing trie node') ||
            error.code === -32603 ||
            error.code === -32002) {
          metamaskBlacklisted = true;
          console.warn('üö´ MetaMask foi adicionado √† blacklist devido a problemas de RPC detectados no teste rigoroso');
        }
        return false;
      }
    }
    
    // Fun√ß√£o auxiliar para criar providers alternativos
    async function getAlternativeProviders(skipMetaMask = false) {
      const providers = [];
      
      // Testar MetaMask primeiro antes de adicionar √† lista (a menos que seja ignorado)
      let metamaskWorking = false;
      if (!skipMetaMask) {
        metamaskWorking = await testMetaMaskHealth();
      }
      
      if (metamaskWorking) {
        console.log('MetaMask est√° funcionando, adicionando √† lista de providers');
        providers.push(new ethers.providers.Web3Provider(window.ethereum));
      } else {
        console.log(skipMetaMask ? 'Ignorando MetaMask por escolha, usando RPCs p√∫blicos' : 'MetaMask n√£o est√° dispon√≠vel ou com problemas, usando apenas RPCs p√∫blicos');
        
        // Mostrar feedback imediato para o usu√°rio
        const statusEl = document.getElementById('contract-validation-status');
        if (statusEl) {
          if (skipMetaMask) {
            statusEl.innerHTML = '<div class="alert alert-info">üîÑ Validando usando RPCs p√∫blicos da BSC Testnet (ignorando MetaMask).</div>';
          } else if (!statusEl.innerHTML.includes('MetaMask indispon√≠vel')) {
            statusEl.innerHTML = '<div class="alert alert-warning">‚ö†Ô∏è MetaMask indispon√≠vel. Usando RPCs p√∫blicos BSC...</div>';
          }
        }
      }
      
      // Melhores RPCs BSC TESTNET de 2024 (ordenados por performance)
      const bscRPCs = [
        'https://data-seed-prebsc-1-s1.binance.org:8545/',  // Binance oficial testnet
        'https://data-seed-prebsc-2-s1.binance.org:8545/',  // Binance oficial testnet
        'https://bsc-testnet.public.blastapi.io',           // BlastAPI testnet
        'https://bsc-testnet-rpc.publicnode.com',           // PublicNode testnet
        'https://data-seed-prebsc-1-s2.binance.org:8545/',  // Binance backup
        'https://data-seed-prebsc-2-s2.binance.org:8545/',  // Binance backup
        'https://bsc-testnet.blockpi.network/v1/rpc/public', // BlockPI testnet
        'https://endpoints.omniatech.io/v1/bsc/testnet/public' // OmniaTech testnet
      ];
      
      bscRPCs.forEach(rpc => {
        try {
          // SOLU√á√ÉO RADICAL: Provider com configura√ß√£o est√°tica completa da BSC TESTNET
          // N√£o permite detec√ß√£o autom√°tica de rede para evitar "could not detect network"
          const networkConfig = {
            name: "bsc-testnet",
            chainId: 97,
            ensAddress: null,
            _defaultProvider: null
          };
          
          const provider = new ethers.providers.StaticJsonRpcProvider(rpc, networkConfig);
          
          // For√ßar configura√ß√£o est√°tica para evitar detec√ß√£o autom√°tica
          provider._network = networkConfig;
          provider.detectNetwork = () => Promise.resolve(networkConfig);
          
          providers.push(provider);
        } catch (e) {
          console.warn(`Falha ao criar provider para ${rpc}:`, e);
        }
      });
      
      return providers;
    }
    
    // Fun√ß√£o auxiliar SIMPLIFICADA para retry com diferentes providers
    // FALLBACK DIRETO sem valida√ß√µes que causam problemas
    async function retryWithProviders(operation, maxRetries = 8, skipMetaMask = false) {
      const providers = await getAlternativeProviders(skipMetaMask); // Agora √© async
      let lastError;
      const backoffBaseMs = 300; // backoff exponencial leve
      
      if (providers.length === 0) {
        throw new Error('Nenhum provider dispon√≠vel');
      }
      
      for (let i = 0; i < providers.length && i < maxRetries; i++) {
        try {
          const isMetaMask = providers[i] instanceof ethers.providers.Web3Provider;
          const providerName = isMetaMask ? 'MetaMask' : `RPC BSC ${i + 1}`;
          
          console.log(`Tentativa ${i + 1} com provider ${providerName}`);
          
          // SOLU√á√ÉO RADICAL: Executar opera√ß√£o diretamente sem valida√ß√µes pr√©vias
          return await operation(providers[i]);
        } catch (error) {
          lastError = error;
          console.warn(`Tentativa ${i + 1} falhou:`, error.message);
          
          // FALLBACK DIRETO: Qualquer erro, passa para o pr√≥ximo provider
          // N√£o fazer distin√ß√£o de tipos de erro para evitar complica√ß√µes
          console.log(`üîÑ Passando para pr√≥ximo provider...`);
          // Backoff leve antes da pr√≥xima tentativa
          const delay = Math.min(backoffBaseMs * (i + 1), 2000);
          await new Promise(resolve => setTimeout(resolve, delay));
          continue;
        }
      }
      
      throw lastError;
    }
    
    // Fun√ß√£o auxiliar SIMPLIFICADA para verificar se contrato existe
    // REMOVIDA valida√ß√£o de rede que causava "could not detect network"
    async function checkContractExists(address, provider) {
      try {
        // SOLU√á√ÉO RADICAL: Ir direto ao getCode sem validar rede
        // Isso evita o erro "could not detect network" completamente
        const code = await provider.getCode(address);
        return code !== '0x';
      } catch (error) {
        console.warn('Erro ao verificar c√≥digo do contrato:', error);
        return false;
      }
    }

    async function detectContractInformation() {
      try {
        const contractAddressEl = document.getElementById('deployedContractAddress');
        const tokenAddressEl = document.getElementById('contractTokenAddress');
        
        if (!contractAddressEl || !tokenAddressEl) {
          alert('Campos de endere√ßo n√£o encontrados');
          return;
        }
        
        const contractAddress = contractAddressEl.value.trim();
        const tokenAddress = tokenAddressEl.value.trim();
        
        if (!contractAddress) {
          alert('Por favor, informe o endere√ßo do contrato de venda deployado');
          return;
        }
        
        // Validar formato dos endere√ßos
        if (!isValidEthereumAddress(contractAddress)) {
          alert('Endere√ßo do contrato inv√°lido');
          return;
        }
        
        // Conectar ao provider se necess√°rio
        if (!provider) {
          await connectWallet();
          if (!provider) {
            throw new Error('N√£o foi poss√≠vel conectar √† rede');
          }
        }
        
        // Mostrar status de carregamento
        const statusEl = document.getElementById('contract-validation-status');
        if (statusEl) {
          statusEl.innerHTML = '<div class="alert alert-info">üîç Verificando exist√™ncia do contrato...</div>';
        }
        
        // Verificar se o contrato existe usando retry
        const contractExists = await retryWithProviders(async (currentProvider) => {
          return await checkContractExists(contractAddress, currentProvider);
        });
        
        if (!contractExists) {
          if (statusEl) {
            statusEl.innerHTML = '<div class="alert alert-danger">‚ùå Contrato n√£o encontrado no endere√ßo informado. Verifique se o endere√ßo est√° correto e se o contrato foi deployado.</div>';
          }
          return;
        }
        
        if (statusEl) {
          statusEl.innerHTML = '<div class="alert alert-info">üîç Detectando informa√ß√µes do contrato...</div>';
        }
        
        // Se n√£o tiver endere√ßo do token, tentar detectar automaticamente
        if (!tokenAddress) {
          try {
            const detectedTokenAddress = await retryWithProviders(async (currentProvider) => {
              // Tentar m√∫ltiplas assinaturas comuns para endere√ßo de token
              try {
                const cSaleToken = new ethers.Contract(contractAddress, ["function saleToken() view returns (address)"], currentProvider);
                return await cSaleToken.saleToken();
              } catch (_) {
                try {
                  const cToken = new ethers.Contract(contractAddress, ["function token() view returns (address)"], currentProvider);
                  return await cToken.token();
                } catch (_) {
                  try {
                    const cTokenAddr = new ethers.Contract(contractAddress, ["function tokenAddress() view returns (address)"], currentProvider);
                    return await cTokenAddr.tokenAddress();
                  } catch (_) {
                    try {
                      const cPaymentToken = new ethers.Contract(contractAddress, ["function paymentToken() view returns (address)"], currentProvider);
                      return await cPaymentToken.paymentToken();
                    } catch (_) {
                      const cGetToken = new ethers.Contract(contractAddress, ["function getToken() view returns (address)"], currentProvider);
                      return await cGetToken.getToken();
                    }
                  }
                }
              }
            }, 8, true);
            
            if (detectedTokenAddress && detectedTokenAddress !== '0x0000000000000000000000000000000000000000') {
              tokenAddressEl.value = detectedTokenAddress;
              
              if (statusEl) {
                statusEl.innerHTML = '<div class="alert alert-info">üîç Detectando informa√ß√µes do token...</div>';
              }
              
              // Detectar informa√ß√µes do token automaticamente com retry
              const tokenInfo = await retryWithProviders(async (currentProvider) => {
                const tokenContract = new ethers.Contract(detectedTokenAddress, [
                  "function name() view returns (string)",
                  "function symbol() view returns (string)",
                  "function decimals() view returns (uint8)"
                ], currentProvider);
                
                const [name, symbol, decimals] = await Promise.all([
                  tokenContract.name(),
                  tokenContract.symbol(),
                  tokenContract.decimals()
                ]);
                
                return { name, symbol, decimals };
              });
              
              if (statusEl) {
                statusEl.innerHTML = `
                  <div class="alert alert-success">
                    ‚úÖ Informa√ß√µes detectadas automaticamente:<br>
                    <strong>Token:</strong> ${tokenInfo.name} (${tokenInfo.symbol})<br>
                    <strong>Endere√ßo do Token:</strong> ${detectedTokenAddress}<br>
                    <strong>Decimais:</strong> ${tokenInfo.decimals}
                  </div>
                `;
              }
            } else {
              throw new Error('Endere√ßo do token n√£o encontrado no contrato');
            }
          } catch (error) {
            console.error('Erro ao detectar token:', error);
            if (statusEl) {
              const errorMsg = error.message.includes('missing trie node') 
                ? 'Problema tempor√°rio de sincroniza√ß√£o da rede. Tente novamente em alguns segundos.'
                : 'N√£o foi poss√≠vel detectar automaticamente o endere√ßo do token. Por favor, informe manualmente.';
              statusEl.innerHTML = `<div class="alert alert-warning">‚ö†Ô∏è ${errorMsg}</div>`;
            }
          }
        } else {
          // Se j√° tem o endere√ßo do token, apenas validar
          try {
            if (statusEl) {
              statusEl.innerHTML = '<div class="alert alert-info">üîç Validando informa√ß√µes do token...</div>';
            }
            
            const tokenInfo = await retryWithProviders(async (currentProvider) => {
              const tokenContract = new ethers.Contract(tokenAddress, [
                "function name() view returns (string)",
                "function symbol() view returns (string)",
                "function decimals() view returns (uint8)"
              ], currentProvider);
              
              const [name, symbol, decimals] = await Promise.all([
                tokenContract.name(),
                tokenContract.symbol(),
                tokenContract.decimals()
              ]);
              
              return { name, symbol, decimals };
            });
            
            if (statusEl) {
              statusEl.innerHTML = `
                <div class="alert alert-success">
                  ‚úÖ Token validado:<br>
                  <strong>Nome:</strong> ${tokenInfo.name} (${tokenInfo.symbol})<br>
                  <strong>Decimais:</strong> ${tokenInfo.decimals}
                </div>
              `;
            }
          } catch (error) {
            console.error('Erro ao validar token:', error);
            if (statusEl) {
              const errorMsg = error.message.includes('missing trie node') 
                ? 'Problema tempor√°rio de sincroniza√ß√£o da rede. Tente novamente em alguns segundos.'
                : 'Erro ao validar o token. Verifique o endere√ßo.';
              statusEl.innerHTML = `<div class="alert alert-danger">‚ùå ${errorMsg}</div>`;
            }
          }
        }
        
      } catch (error) {
        console.error('Erro ao detectar informa√ß√µes do contrato:', error);
        const statusEl = document.getElementById('contract-validation-status');
        if (statusEl) {
          let errorMsg = error.message;
          if (error.message.includes('missing trie node') || error.message.includes('Internal JSON-RPC error')) {
            errorMsg = 'Problema tempor√°rio de sincroniza√ß√£o da rede. Tente novamente em alguns segundos.';
          }
          statusEl.innerHTML = `<div class="alert alert-danger">‚ùå Erro: ${errorMsg}</div>`;
        }
      }
    }
    
    // Fun√ß√£o para validar o contrato de venda
    async function validateContractFunction() {
      try {
        const contractAddressEl = document.getElementById('deployedContractAddress');
        const tokenAddressEl = document.getElementById('contractTokenAddress');
        
        if (!contractAddressEl || !tokenAddressEl) {
          alert('Campos de endere√ßo n√£o encontrados');
          return;
        }
        
        const contractAddress = contractAddressEl.value.trim();
        const tokenAddress = tokenAddressEl.value.trim();
        
        if (!contractAddress || !tokenAddress) {
          alert('Por favor, informe os endere√ßos do contrato e do token');
          return;
        }
        
        // N√£o obrigar conex√£o de carteira para valida√ß√£o de leitura
        // Se MetaMask/provider padr√£o n√£o estiver dispon√≠vel, usaremos RPCs p√∫blicos via retryWithProviders
        if (!provider) {
          console.warn('Provider padr√£o indispon√≠vel, usando RPCs p√∫blicos para validar.');
        }
        
        const statusEl = document.getElementById('contract-validation-status');
        if (statusEl) {
          statusEl.innerHTML = '<div class="alert alert-info">üîç Validando contrato...</div>';
        }
        
        // Validar informa√ß√µes do contrato usando fallback robusto e ignorando MetaMask
        const { contractToken, tokenPrice, owner, isPaused } = await retryWithProviders(async (currentProvider) => {
          const exists = await checkContractExists(contractAddress, currentProvider);
          if (!exists) {
            throw new Error('Contrato n√£o encontrado ou sem c√≥digo na BSC Testnet (97)');
          }

          // Resgatar endere√ßo do token: tentar v√°rias assinaturas comuns
          let ct;
          try {
            const scSaleToken = new ethers.Contract(contractAddress, ["function saleToken() view returns (address)"], currentProvider);
            ct = await scSaleToken.saleToken();
          } catch (_) {
            try {
              const scToken = new ethers.Contract(contractAddress, ["function token() view returns (address)"], currentProvider);
              ct = await scToken.token();
            } catch (_) {
              try {
                const scTokenAddr = new ethers.Contract(contractAddress, ["function tokenAddress() view returns (address)"], currentProvider);
                ct = await scTokenAddr.tokenAddress();
              } catch (_) {
                try {
                  const scPaymentToken = new ethers.Contract(contractAddress, ["function paymentToken() view returns (address)"], currentProvider);
                  ct = await scPaymentToken.paymentToken();
                } catch (_) {
                  const scGetToken = new ethers.Contract(contractAddress, ["function getToken() view returns (address)"], currentProvider);
                  ct = await scGetToken.getToken();
                }
              }
            }
          }

          // Resgatar pre√ßo (BNB) preferencialmente; fallback para tokenPrice()
          let tp;
          try {
            const scBnbPrice = new ethers.Contract(contractAddress, ["function bnbPrice() view returns (uint256)"], currentProvider);
            tp = await scBnbPrice.bnbPrice();
          } catch (_) {
            const scTokenPrice = new ethers.Contract(contractAddress, ["function tokenPrice() view returns (uint256)"], currentProvider);
            tp = await scTokenPrice.tokenPrice();
          }

          // Owner
          let ow;
          try {
            const scOwner = new ethers.Contract(contractAddress, ["function owner() view returns (address)"], currentProvider);
            ow = await scOwner.owner();
          } catch (_) {
            const scGetOwner = new ethers.Contract(contractAddress, ["function getOwner() view returns (address)"], currentProvider);
            ow = await scGetOwner.getOwner();
          }

          // Pausa (opcional). Se n√£o existir, assume false
          let ps = false;
          try {
            const scPaused = new ethers.Contract(contractAddress, ["function paused() view returns (bool)"], currentProvider);
            ps = await scPaused.paused();
          } catch (_) {
            try {
              const scIsPaused = new ethers.Contract(contractAddress, ["function isPaused() view returns (bool)"], currentProvider);
              ps = await scIsPaused.isPaused();
            } catch (_) {
              ps = false;
            }
          }

          return { contractToken: ct, tokenPrice: tp, owner: ow, isPaused: ps };
        }, 8, true);
        
        // Verificar se o token do contrato corresponde ao informado
        if (contractToken.toLowerCase() !== tokenAddress.toLowerCase()) {
          throw new Error(`Token do contrato (${contractToken}) n√£o corresponde ao informado (${tokenAddress})`);
        }
        
        // Obter informa√ß√µes do token via fallback
        const { tokenName, tokenSymbol, tokenDecimals } = await retryWithProviders(async (currentProvider) => {
          const tc = new ethers.Contract(tokenAddress, [
            "function name() view returns (string)",
            "function symbol() view returns (string)",
            "function decimals() view returns (uint8)"
          ], currentProvider);
          const [tn, ts, td] = await Promise.all([
            tc.name(),
            tc.symbol(),
            tc.decimals()
          ]);
          return { tokenName: tn, tokenSymbol: ts, tokenDecimals: td };
        }, 8, true);
        
        const priceInBNB = ethers.utils.formatEther(tokenPrice);
        
        if (statusEl) {
          statusEl.innerHTML = `
            <div class="alert alert-success">
              ‚úÖ <strong>Contrato validado com sucesso!</strong><br><br>
              <strong>Token:</strong> ${tokenName} (${tokenSymbol})<br>
              <strong>Pre√ßo:</strong> ${priceInBNB} BNB por token<br>
              <strong>Owner:</strong> ${owner}<br>
              <strong>Status:</strong> ${isPaused ? '‚è∏Ô∏è Pausado' : '‚ñ∂Ô∏è Ativo'}<br>
              <strong>Decimais:</strong> ${tokenDecimals}
            </div>
          `;
        }
        
        // Habilitar o bot√£o "Testar Sistema"
        const goToStep5Btn = document.getElementById('goToStep5');
        if (goToStep5Btn) {
          goToStep5Btn.disabled = false;
          goToStep5Btn.classList.remove('btn-secondary');
          goToStep5Btn.classList.add('btn-primary');
        }
        
      } catch (error) {
        console.error('Erro ao validar contrato:', error);
        const statusEl = document.getElementById('contract-validation-status');
        if (statusEl) {
          let msg = error && error.message ? error.message : String(error);
          if (msg.includes('Internal JSON-RPC error') || msg.includes('-32603')) {
            msg = 'Falha no RPC (MetaMask). Validando via RPCs p√∫blicos da BSC Testnet. Tente novamente.';
          } else if (msg.includes('CALL_EXCEPTION') || msg.includes('token()')) {
            msg = 'A chamada token() reverteu. Verifique se o endere√ßo √© do contrato de venda correto e se a fun√ß√£o token() existe no ABI.';
          }
          statusEl.innerHTML = `<div class="alert alert-danger">‚ùå Erro na valida√ß√£o: ${msg}</div>`;
        }
        
        // Desabilitar o bot√£o "Testar Sistema"
        const goToStep5Btn = document.getElementById('goToStep5');
        if (goToStep5Btn) {
          goToStep5Btn.disabled = true;
          goToStep5Btn.classList.remove('btn-primary');
          goToStep5Btn.classList.add('btn-secondary');
        }
      }
    }
  </script>
</body>
</html>